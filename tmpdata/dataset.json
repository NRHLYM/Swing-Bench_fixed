{"repo":"rustzx\/rustzx","pull_number":102,"instance_id":"rustzx__rustzx-102","issue_numbers":["109"],"base_commit":"b9c9363fb1150537daade203f72528db2c802d64","patch":"diff --git a\/.cargo\/config.toml b\/.cargo\/config.toml\nindex aee7c78..e0d3538 100644\n--- a\/.cargo\/config.toml\n+++ b\/.cargo\/config.toml\n@@ -3,3 +3,4 @@ rustzx-fmt = \"fmt --all\"\n rustzx-clippy = \"clippy --workspace --all-features\"\n rustzx-run = \"run --release --bin rustzx --\"\n rustzx-install = \"install --path rustzx\"\n+rustzx-build-assets = \"run -p rustzx-test --bin build-assets\"\ndiff --git a\/.github\/workflows\/ci.yml b\/.github\/workflows\/ci.yml\nindex 709df8b..1c90350 100644\n--- a\/.github\/workflows\/ci.yml\n+++ b\/.github\/workflows\/ci.yml\n@@ -38,6 +38,9 @@ jobs:\n           toolchain: stable\n           override: true\n           components: rustfmt, clippy\n+      - name: Install linux dev dependencies\n+        if: ${{ matrix.os_name == 'linux' }}\n+        run: sudo apt-get install -y libasound2-dev\n       - name: Rustfmt\n         uses: actions-rs\/cargo@v1\n         with:\n@@ -58,11 +61,16 @@ jobs:\n         with:\n           command: build\n           args: --release -p rustzx-core -p rustzx-utils --verbose\n+      - name: Clippy(rustzx-core\/rustzx-utils) - Minimal\n+        uses: actions-rs\/cargo@v1\n+        with:\n+          command: clippy\n+          args: -p rustzx-core -p rustzx-utils --verbose\n       - name: Test\n         uses: actions-rs\/cargo@v1\n         with:\n           command: test\n-          args: --workspace --all-features --verbose\n+          args: --workspace --exclude rustzx-test --exclude rustzx-z80 --all-features --verbose\n       - name: Upload artifacts\n         uses: actions\/upload-artifact@v2\n         with:\n@@ -70,3 +78,18 @@ jobs:\n           path: |\n             target\/release\/rustzx${{ matrix.executable_suffix }}\n             target\/release\/vtx${{ matrix.executable_suffix }}\n+  integration-test:\n+    name: \"rustzx-test integration tests\"\n+    runs-on: ubuntu-20.04\n+    steps:\n+      - uses: actions\/checkout@v2\n+      - uses: actions-rs\/toolchain@v1\n+        with:\n+          profile: minimal\n+          toolchain: stable\n+          override: true\n+      - name: Test\n+        uses: actions-rs\/cargo@v1\n+        with:\n+          command: test\n+          args: -p rustzx-test\ndiff --git a\/.gitignore b\/.gitignore\nindex 39d0eb8..3cd6174 100644\n--- a\/.gitignore\n+++ b\/.gitignore\n@@ -17,3 +17,4 @@\n # RustZX-specific\n *.rustzx.last.sna\n *.rustzx.prev.sna\n+\/artifacts\ndiff --git a\/CHANGELOG.md b\/CHANGELOG.md\nindex 5e1c6f4..d3c8af1 100644\n--- a\/CHANGELOG.md\n+++ b\/CHANGELOG.md\n@@ -1,3 +1,13 @@\n+### RustZX v0.15\n+<!-- START_CHANGELOG|v0.15.0 -->\n+- **[Feature]** Added new `cpal` sound backend (#101)\n+- **[Feature]** Added support for `.gz`-compressed assets (#109)\n+- **[Feature]** Added support for non-standard Kempston joy buttons in rustzx-core (#113)\n+- **[Fix]** Fixed bug with integer overflow panic in tape loader (#100)\n+- **[Testing]** Added integration tests for rustzx-core (#92)\n+- **[Refactoring]** Removed cyclic dependencies between `rustzx-core` and `rustzx-utils`(#99)\n+<!-- END_CHANGELOG|v0.15.0 -->\n+\n ### RustZX v0.14\n - **[Refactoring]** Moved z80 emulation to the separate crate (`rustzx-z80`)\n - **[Feature]** Added support for `*.scr` screenshot format loading\ndiff --git a\/Cargo.lock b\/Cargo.lock\nindex 881e4c0..72533cd 100644\n--- a\/Cargo.lock\n+++ b\/Cargo.lock\n@@ -23,6 +23,28 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"alsa\"\n+version = \"0.5.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"75c4da790adcb2ce5e758c064b4f3ec17a30349f9961d3e5e6c9688b052a9e18\"\n+dependencies = [\n+ \"alsa-sys\",\n+ \"bitflags\",\n+ \"libc\",\n+ \"nix\",\n+]\n+\n+[[package]]\n+name = \"alsa-sys\"\n+version = \"0.3.1\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"db8fee663d06c4e303404ef5f40488a53e062f89ba8bfed81f42325aafad1527\"\n+dependencies = [\n+ \"libc\",\n+ \"pkg-config\",\n+]\n+\n [[package]]\n name = \"ansi_term\"\n version = \"0.11.0\"\n@@ -34,9 +56,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.40\"\n+version = \"1.0.44\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"28b2cd92db5cbd74e8e5028f7e27dd7aa3090e89e4f2a197cc7c8dfb69c7063b\"\n+checksum = \"61604a8f862e1d5c3229fdd78f8b02c68dcf73a4c4b05fd636d12240aaa242c1\"\n \n [[package]]\n name = \"atty\"\n@@ -57,17 +79,42 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"aym\"\n-version = \"0.1.1\"\n+version = \"0.15.0\"\n dependencies = [\n  \"libm\",\n  \"num-traits\",\n ]\n \n+[[package]]\n+name = \"base64\"\n+version = \"0.13.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"904dfeac50f3cdaba28fc6f57fdcddb75f49ed61346676a78c4ffe55877802fd\"\n+\n+[[package]]\n+name = \"bindgen\"\n+version = \"0.56.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"2da379dbebc0b76ef63ca68d8fc6e71c0f13e59432e0987e508c1820e6ab5239\"\n+dependencies = [\n+ \"bitflags\",\n+ \"cexpr\",\n+ \"clang-sys\",\n+ \"lazy_static\",\n+ \"lazycell\",\n+ \"peeking_take_while\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"regex\",\n+ \"rustc-hash\",\n+ \"shlex\",\n+]\n+\n [[package]]\n name = \"bitflags\"\n-version = \"1.2.1\"\n+version = \"1.3.2\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n+checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n [[package]]\n name = \"block-buffer\"\n@@ -78,17 +125,47 @@ dependencies = [\n  \"generic-array\",\n ]\n \n+[[package]]\n+name = \"bumpalo\"\n+version = \"3.7.1\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"d9df67f7bf9ef8498769f994239c45613ef0c5899415fb58e9add412d2c1a538\"\n+\n [[package]]\n name = \"byteorder\"\n version = \"1.4.3\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610\"\n \n+[[package]]\n+name = \"bytes\"\n+version = \"1.0.1\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"b700ce4376041dcd0a327fd0097c41095743c4c8af8887265942faf1100bd040\"\n+\n [[package]]\n name = \"cc\"\n version = \"1.0.67\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"e3c69b077ad434294d3ce9f1f6143a2a4b89a8a2d54ef813d85003a4fd1137fd\"\n+dependencies = [\n+ \"jobserver\",\n+]\n+\n+[[package]]\n+name = \"cesu8\"\n+version = \"1.1.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"6d43a04d8753f35258c91f8ec639f792891f748a1edbd759cf1dcea3382ad83c\"\n+\n+[[package]]\n+name = \"cexpr\"\n+version = \"0.4.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"f4aedb84272dbe89af497cf81375129abda4fc0a9e7c5d317498c15cc30c0d27\"\n+dependencies = [\n+ \"nom\",\n+]\n \n [[package]]\n name = \"cfg-if\"\n@@ -115,6 +192,17 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"clang-sys\"\n+version = \"1.2.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"10612c0ec0e0a1ff0e97980647cb058a6e7aedb913d01d009c406b8b7d0b26ee\"\n+dependencies = [\n+ \"glob\",\n+ \"libc\",\n+ \"libloading\",\n+]\n+\n [[package]]\n name = \"clap\"\n version = \"2.33.3\"\n@@ -139,6 +227,66 @@ dependencies = [\n  \"cc\",\n ]\n \n+[[package]]\n+name = \"combine\"\n+version = \"4.6.1\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"a909e4d93292cd8e9c42e189f61681eff9d67b6541f96b8a1a737f23737bd001\"\n+dependencies = [\n+ \"bytes\",\n+ \"memchr\",\n+]\n+\n+[[package]]\n+name = \"core-foundation-sys\"\n+version = \"0.8.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"ea221b5284a47e40033bf9b66f35f984ec0ea2931eb03505246cd27a963f981b\"\n+\n+[[package]]\n+name = \"coreaudio-rs\"\n+version = \"0.10.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"11894b20ebfe1ff903cbdc52259693389eea03b94918a2def2c30c3bf227ad88\"\n+dependencies = [\n+ \"bitflags\",\n+ \"coreaudio-sys\",\n+]\n+\n+[[package]]\n+name = \"coreaudio-sys\"\n+version = \"0.2.8\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"2b7e3347be6a09b46aba228d6608386739fb70beff4f61e07422da87b0bb31fa\"\n+dependencies = [\n+ \"bindgen\",\n+]\n+\n+[[package]]\n+name = \"cpal\"\n+version = \"0.13.4\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"98f45f0a21f617cd2c788889ef710b63f075c949259593ea09c826f1e47a2418\"\n+dependencies = [\n+ \"alsa\",\n+ \"core-foundation-sys\",\n+ \"coreaudio-rs\",\n+ \"jni\",\n+ \"js-sys\",\n+ \"lazy_static\",\n+ \"libc\",\n+ \"mach\",\n+ \"ndk 0.3.0\",\n+ \"ndk-glue 0.3.0\",\n+ \"nix\",\n+ \"oboe\",\n+ \"parking_lot\",\n+ \"stdweb\",\n+ \"thiserror\",\n+ \"web-sys\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"cpufeatures\"\n version = \"0.1.3\"\n@@ -213,6 +361,17 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"derivative\"\n+version = \"2.2.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"fcc3dd5e9e9c0b295d6e1e4d811fb6f157d5ffd784b8d202fc62eac8035a770b\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"digest\"\n version = \"0.9.0\"\n@@ -262,9 +421,9 @@ dependencies = [\n \n [[package]]\n name = \"env_logger\"\n-version = \"0.8.3\"\n+version = \"0.9.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"17392a012ea30ef05a610aa97dfb49496e71c9f676b27879922ea5bdf60d9d3f\"\n+checksum = \"0b2cf0344971ee6c64c31be0d530793fba457d322dfec2810c453d0ef228f9c3\"\n dependencies = [\n  \"atty\",\n  \"humantime\",\n@@ -344,6 +503,23 @@ dependencies = [\n  \"version_check\",\n ]\n \n+[[package]]\n+name = \"getrandom\"\n+version = \"0.2.3\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"7fcd999463524c52659517fe2cea98493cfe485d10565e7b0fb07dbba7ad2753\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"libc\",\n+ \"wasi\",\n+]\n+\n+[[package]]\n+name = \"glob\"\n+version = \"0.3.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574\"\n+\n [[package]]\n name = \"heck\"\n version = \"0.3.2\"\n@@ -374,6 +550,53 @@ version = \"1.0.1\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39\"\n \n+[[package]]\n+name = \"instant\"\n+version = \"0.1.11\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"716d3d89f35ac6a34fd0eed635395f4c3b76fa889338a4632e5231a8684216bd\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+]\n+\n+[[package]]\n+name = \"jni\"\n+version = \"0.19.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"c6df18c2e3db7e453d3c6ac5b3e9d5182664d28788126d39b91f2d1e22b017ec\"\n+dependencies = [\n+ \"cesu8\",\n+ \"combine\",\n+ \"jni-sys\",\n+ \"log\",\n+ \"thiserror\",\n+ \"walkdir\",\n+]\n+\n+[[package]]\n+name = \"jni-sys\"\n+version = \"0.3.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"8eaf4bc02d17cbdd7ff4c7438cafcdf7fb9a4613313ad11b4f8fefe7d3fa0130\"\n+\n+[[package]]\n+name = \"jobserver\"\n+version = \"0.1.24\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"af25a77299a7f711a01975c35a6a424eb6862092cc2d6c72c4ed6cbc56dfc1fa\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"js-sys\"\n+version = \"0.3.55\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"7cc9ffccd38c451a86bf13657df244e9c3f37493cce8e5e21e940963777acc84\"\n+dependencies = [\n+ \"wasm-bindgen\",\n+]\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\"\n@@ -383,11 +606,27 @@ dependencies = [\n  \"spin\",\n ]\n \n+[[package]]\n+name = \"lazycell\"\n+version = \"1.3.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n+\n [[package]]\n name = \"libc\"\n-version = \"0.2.93\"\n+version = \"0.2.103\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"9385f66bf6105b241aa65a61cb923ef20efc665cb9f9bb50ac2f0c4b7f378d41\"\n+checksum = \"dd8f7255a17a627354f321ef0055d63b898c6fb27eff628af4d1b66b7331edf6\"\n+\n+[[package]]\n+name = \"libloading\"\n+version = \"0.7.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"6f84d96438c15fcd6c3f244c8fce01d1e2b9c6b5623e9c711dc9286d8fc92d6a\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"winapi\",\n+]\n \n [[package]]\n name = \"libm\"\n@@ -395,6 +634,15 @@ version = \"0.2.1\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"c7d73b3f436185384286bd8098d17ec07c9a7d2388a6599f824d8502b529702a\"\n \n+[[package]]\n+name = \"lock_api\"\n+version = \"0.4.5\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"712a4d093c9976e24e7dbca41db895dabcbac38eb5f4045393d17a95bdfb1109\"\n+dependencies = [\n+ \"scopeguard\",\n+]\n+\n [[package]]\n name = \"log\"\n version = \"0.4.14\"\n@@ -404,6 +652,15 @@ dependencies = [\n  \"cfg-if 1.0.0\",\n ]\n \n+[[package]]\n+name = \"mach\"\n+version = \"0.3.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"b823e83b2affd8f40a9ee8c29dbc56404c1e34cd2710921f2801e2cf29527afa\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"memchr\"\n version = \"2.3.4\"\n@@ -429,6 +686,109 @@ dependencies = [\n  \"autocfg\",\n ]\n \n+[[package]]\n+name = \"nanoid\"\n+version = \"0.4.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"3ffa00dec017b5b1a8b7cf5e2c008bfda1aa7e0697ac1508b491fdf2622fb4d8\"\n+dependencies = [\n+ \"rand\",\n+]\n+\n+[[package]]\n+name = \"ndk\"\n+version = \"0.3.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"8794322172319b972f528bf90c6b467be0079f1fa82780ffb431088e741a73ab\"\n+dependencies = [\n+ \"jni-sys\",\n+ \"ndk-sys\",\n+ \"num_enum\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"ndk\"\n+version = \"0.4.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"d64d6af06fde0e527b1ba5c7b79a6cc89cfc46325b0b2887dffe8f70197e0c3c\"\n+dependencies = [\n+ \"bitflags\",\n+ \"jni-sys\",\n+ \"ndk-sys\",\n+ \"num_enum\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"ndk-glue\"\n+version = \"0.3.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"c5caf0c24d51ac1c905c27d4eda4fa0635bbe0de596b8f79235e0b17a4d29385\"\n+dependencies = [\n+ \"lazy_static\",\n+ \"libc\",\n+ \"log\",\n+ \"ndk 0.3.0\",\n+ \"ndk-macro\",\n+ \"ndk-sys\",\n+]\n+\n+[[package]]\n+name = \"ndk-glue\"\n+version = \"0.4.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"d3e9e94628f24e7a3cb5b96a2dc5683acd9230bf11991c2a1677b87695138420\"\n+dependencies = [\n+ \"lazy_static\",\n+ \"libc\",\n+ \"log\",\n+ \"ndk 0.4.0\",\n+ \"ndk-macro\",\n+ \"ndk-sys\",\n+]\n+\n+[[package]]\n+name = \"ndk-macro\"\n+version = \"0.2.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"05d1c6307dc424d0f65b9b06e94f88248e6305726b14729fd67a5e47b2dc481d\"\n+dependencies = [\n+ \"darling\",\n+ \"proc-macro-crate 0.1.5\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"ndk-sys\"\n+version = \"0.2.1\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"c44922cb3dbb1c70b5e5f443d63b64363a898564d739ba5198e3a9138442868d\"\n+\n+[[package]]\n+name = \"nix\"\n+version = \"0.20.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"fa9b4819da1bc61c0ea48b63b7bc8604064dd43013e7cc325df098d49cd7c18a\"\n+dependencies = [\n+ \"bitflags\",\n+ \"cc\",\n+ \"cfg-if 1.0.0\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"nom\"\n+version = \"5.1.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"ffb4262d26ed83a1c0a33a38fe2bb15797329c85770da05e6b828ddb782627af\"\n+dependencies = [\n+ \"memchr\",\n+ \"version_check\",\n+]\n+\n [[package]]\n name = \"num-derive\"\n version = \"0.3.3\"\n@@ -459,11 +819,56 @@ dependencies = [\n  \"autocfg\",\n ]\n \n+[[package]]\n+name = \"num_enum\"\n+version = \"0.5.4\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"3f9bd055fb730c4f8f4f57d45d35cd6b3f0980535b056dc7ff119cee6a66ed6f\"\n+dependencies = [\n+ \"derivative\",\n+ \"num_enum_derive\",\n+]\n+\n+[[package]]\n+name = \"num_enum_derive\"\n+version = \"0.5.4\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"486ea01961c4a818096de679a8b740b26d9033146ac5291b1c98557658f8cdd9\"\n+dependencies = [\n+ \"proc-macro-crate 1.1.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"oboe\"\n+version = \"0.4.4\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"e15e22bc67e047fe342a32ecba55f555e3be6166b04dd157cd0f803dfa9f48e1\"\n+dependencies = [\n+ \"jni\",\n+ \"ndk 0.4.0\",\n+ \"ndk-glue 0.4.0\",\n+ \"num-derive\",\n+ \"num-traits\",\n+ \"oboe-sys\",\n+]\n+\n+[[package]]\n+name = \"oboe-sys\"\n+version = \"0.4.4\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"338142ae5ab0aaedc8275aa8f67f460e43ae0fca76a695a742d56da0a269eadc\"\n+dependencies = [\n+ \"cc\",\n+]\n+\n [[package]]\n name = \"once_cell\"\n-version = \"1.7.2\"\n+version = \"1.8.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"af8b08b04175473088b46763e51ee54da5f9a164bc162f615b91bc179dbf15a3\"\n+checksum = \"692fcb63b64b1758029e0a96ee63e049ce8c5948587f2f7208df04625e5f6b56\"\n \n [[package]]\n name = \"opaque-debug\"\n@@ -471,12 +876,49 @@ version = \"0.3.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"624a8340c38c1b80fd549087862da4ba43e08858af025b236e509b6649fc13d5\"\n \n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.11.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99\"\n+dependencies = [\n+ \"instant\",\n+ \"lock_api\",\n+ \"parking_lot_core\",\n+]\n+\n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.8.5\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"d76e8e1493bcac0d2766c42737f34458f1c8c50c0d23bcb24ea953affb273216\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"instant\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"smallvec\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"paste\"\n version = \"1.0.5\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"acbf547ad0c65e31259204bd90935776d1c693cec2f4ff7abb7a1bbbd40dfe58\"\n \n+[[package]]\n+name = \"peeking_take_while\"\n+version = \"0.1.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"19b17cddbe7ec3f8bc800887bab5e717348c95ea2ca0b1bf0837fb964dc67099\"\n+\n+[[package]]\n+name = \"pkg-config\"\n+version = \"0.3.20\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"7c9b1041b4387893b91ee6746cddfc28516aff326a3519fb2adf820932c5e6cb\"\n+\n [[package]]\n name = \"png\"\n version = \"0.16.8\"\n@@ -489,6 +931,31 @@ dependencies = [\n  \"miniz_oxide 0.3.7\",\n ]\n \n+[[package]]\n+name = \"ppv-lite86\"\n+version = \"0.2.10\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"ac74c624d6b2d21f425f752262f42188365d7b8ff1aff74c82e45136510a4857\"\n+\n+[[package]]\n+name = \"proc-macro-crate\"\n+version = \"0.1.5\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"1d6ea3c4595b96363c13943497db34af4460fb474a95c43f4446ad341b8c9785\"\n+dependencies = [\n+ \"toml\",\n+]\n+\n+[[package]]\n+name = \"proc-macro-crate\"\n+version = \"1.1.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"1ebace6889caf889b4d3f76becee12e90353f2b8c7d875534a71e5742f8f6f83\"\n+dependencies = [\n+ \"thiserror\",\n+ \"toml\",\n+]\n+\n [[package]]\n name = \"proc-macro-error\"\n version = \"1.0.4\"\n@@ -531,11 +998,51 @@ dependencies = [\n  \"proc-macro2\",\n ]\n \n+[[package]]\n+name = \"rand\"\n+version = \"0.8.4\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"2e7573632e6454cf6b99d7aac4ccca54be06da05aca2ef7423d22d27d4d4bcd8\"\n+dependencies = [\n+ \"libc\",\n+ \"rand_chacha\",\n+ \"rand_core\",\n+ \"rand_hc\",\n+]\n+\n+[[package]]\n+name = \"rand_chacha\"\n+version = \"0.3.1\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88\"\n+dependencies = [\n+ \"ppv-lite86\",\n+ \"rand_core\",\n+]\n+\n+[[package]]\n+name = \"rand_core\"\n+version = \"0.6.3\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"d34f1408f55294453790c48b2f1ebbb1c5b4b7563eb1f418bcfcfdbb06ebb4e7\"\n+dependencies = [\n+ \"getrandom\",\n+]\n+\n+[[package]]\n+name = \"rand_hc\"\n+version = \"0.3.1\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"d51e9f596de227fda2ea6c84607f5558e196eeaf43c986b724ba4fb8fdf497e7\"\n+dependencies = [\n+ \"rand_core\",\n+]\n+\n [[package]]\n name = \"redox_syscall\"\n-version = \"0.2.6\"\n+version = \"0.2.10\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"8270314b5ccceb518e7e578952f0b72b88222d02e8f77f5ecf7abbb673539041\"\n+checksum = \"8383f39639269cde97d255a32bdb68c047337295414940c68bdd30c2e13203ff\"\n dependencies = [\n  \"bitflags\",\n ]\n@@ -563,22 +1070,30 @@ version = \"1.0.1\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"b9b1a3d5f46d53f4a3478e2be4a5a5ce5108ea58b100dcd139830eae7f79a3a1\"\n \n+[[package]]\n+name = \"rustc-hash\"\n+version = \"1.1.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n+\n [[package]]\n name = \"rustzx\"\n-version = \"0.14.0\"\n+version = \"0.15.0\"\n dependencies = [\n  \"anyhow\",\n+ \"cpal\",\n  \"env_logger\",\n  \"log\",\n  \"rustzx-core\",\n  \"rustzx-utils\",\n  \"sdl2\",\n  \"structopt\",\n+ \"strum\",\n ]\n \n [[package]]\n name = \"rustzx-core\"\n-version = \"0.14.0\"\n+version = \"0.15.0\"\n dependencies = [\n  \"aym\",\n  \"bitflags\",\n@@ -586,25 +1101,56 @@ dependencies = [\n  \"enum_dispatch\",\n  \"from_variants\",\n  \"lazy_static\",\n+ \"rustzx-z80\",\n+ \"strum\",\n+]\n+\n+[[package]]\n+name = \"rustzx-test\"\n+version = \"0.15.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"base64\",\n+ \"expect-test\",\n+ \"nanoid\",\n  \"png\",\n+ \"rustzx-core\",\n  \"rustzx-utils\",\n- \"rustzx-z80\",\n+ \"sha2\",\n+ \"wav\",\n ]\n \n [[package]]\n name = \"rustzx-utils\"\n-version = \"0.14.0\"\n+version = \"0.15.0\"\n dependencies = [\n+ \"flate2\",\n+ \"log\",\n  \"rustzx-core\",\n ]\n \n [[package]]\n name = \"rustzx-z80\"\n-version = \"0.14.0\"\n+version = \"0.15.0\"\n dependencies = [\n  \"paste\",\n ]\n \n+[[package]]\n+name = \"same-file\"\n+version = \"1.0.6\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502\"\n+dependencies = [\n+ \"winapi-util\",\n+]\n+\n+[[package]]\n+name = \"scopeguard\"\n+version = \"1.1.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n+\n [[package]]\n name = \"sdl2\"\n version = \"0.34.5\"\n@@ -632,6 +1178,12 @@ dependencies = [\n  \"version-compare\",\n ]\n \n+[[package]]\n+name = \"serde\"\n+version = \"1.0.130\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"f12d06de37cf59146fbdecab66aa99f9fe4f78722e3607577a5375d66bd0c913\"\n+\n [[package]]\n name = \"sha2\"\n version = \"0.9.5\"\n@@ -645,12 +1197,30 @@ dependencies = [\n  \"opaque-debug\",\n ]\n \n+[[package]]\n+name = \"shlex\"\n+version = \"0.1.1\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"7fdf1b9db47230893d76faad238fd6097fd6d6a9245cd7a4d90dbd639536bbd2\"\n+\n+[[package]]\n+name = \"smallvec\"\n+version = \"1.7.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"1ecab6c735a6bb4139c0caafd0cc3635748bbb3acf4550e8138122099251f309\"\n+\n [[package]]\n name = \"spin\"\n version = \"0.5.2\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"6e63cff320ae2c57904679ba7cb63280a3dc4613885beafb148ee7bf9aa9042d\"\n \n+[[package]]\n+name = \"stdweb\"\n+version = \"0.1.3\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"ef5430c8e36b713e13b48a9f709cc21e046723fe44ce34587b73a830203b533e\"\n+\n [[package]]\n name = \"strsim\"\n version = \"0.8.0\"\n@@ -687,6 +1257,27 @@ dependencies = [\n  \"syn\",\n ]\n \n+[[package]]\n+name = \"strum\"\n+version = \"0.22.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"f7ac893c7d471c8a21f31cfe213ec4f6d9afeed25537c772e08ef3f005f8729e\"\n+dependencies = [\n+ \"strum_macros\",\n+]\n+\n+[[package]]\n+name = \"strum_macros\"\n+version = \"0.22.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"339f799d8b549e3744c7ac7feb216383e4005d94bdb22561b3ab8f3b808ae9fb\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"syn\"\n version = \"1.0.70\"\n@@ -758,6 +1349,15 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"toml\"\n+version = \"0.5.8\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"a31142970826733df8241ef35dc040ef98c679ab14d7c3e54d827099b3acecaa\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"typenum\"\n version = \"1.13.0\"\n@@ -813,7 +1413,7 @@ checksum = \"5fecdca9a5291cc2b8dcf7dc02453fee791a280f3743cb0905f8822ae463b3fe\"\n \n [[package]]\n name = \"vtx\"\n-version = \"0.1.2\"\n+version = \"0.15.0\"\n dependencies = [\n  \"aym\",\n  \"byteorder\",\n@@ -827,7 +1427,7 @@ dependencies = [\n \n [[package]]\n name = \"vtx-bin\"\n-version = \"0.1.2\"\n+version = \"0.15.0\"\n dependencies = [\n  \"anyhow\",\n  \"structopt\",\n@@ -835,12 +1435,77 @@ dependencies = [\n  \"wav\",\n ]\n \n+[[package]]\n+name = \"walkdir\"\n+version = \"2.3.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"808cf2735cd4b6866113f648b791c6adc5714537bc222d9347bb203386ffda56\"\n+dependencies = [\n+ \"same-file\",\n+ \"winapi\",\n+ \"winapi-util\",\n+]\n+\n [[package]]\n name = \"wasi\"\n version = \"0.10.0+wasi-snapshot-preview1\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"1a143597ca7c7793eff794def352d41792a93c481eb1042423ff7ff72ba2c31f\"\n \n+[[package]]\n+name = \"wasm-bindgen\"\n+version = \"0.2.78\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"632f73e236b219150ea279196e54e610f5dbafa5d61786303d4da54f84e47fce\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"wasm-bindgen-macro\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-backend\"\n+version = \"0.2.78\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"a317bf8f9fba2476b4b2c85ef4c4af8ff39c3c7f0cdfeed4f82c34a880aa837b\"\n+dependencies = [\n+ \"bumpalo\",\n+ \"lazy_static\",\n+ \"log\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"wasm-bindgen-shared\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-macro\"\n+version = \"0.2.78\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"d56146e7c495528bf6587663bea13a8eb588d39b36b679d83972e1a2dbbdacf9\"\n+dependencies = [\n+ \"quote\",\n+ \"wasm-bindgen-macro-support\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-macro-support\"\n+version = \"0.2.78\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"7803e0eea25835f8abdc585cd3021b3deb11543c6fe226dcd30b228857c5c5ab\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"wasm-bindgen-backend\",\n+ \"wasm-bindgen-shared\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-shared\"\n+version = \"0.2.78\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"0237232789cf037d5480773fe568aac745bfe2afbc11a863e97901780a6b47cc\"\n+\n [[package]]\n name = \"wav\"\n version = \"1.0.0\"\n@@ -850,11 +1515,21 @@ dependencies = [\n  \"riff\",\n ]\n \n+[[package]]\n+name = \"web-sys\"\n+version = \"0.3.55\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"38eb105f1c59d9eaa6b5cdc92b859d85b926e82cb2e0945cd0c9259faa6fe9fb\"\n+dependencies = [\n+ \"js-sys\",\n+ \"wasm-bindgen\",\n+]\n+\n [[package]]\n name = \"winapi\"\n-version = \"0.3.7\"\n+version = \"0.3.9\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"f10e386af2b13e47c89e7236a7a14a086791a2b88ebad6df9bf42040195cf770\"\n+checksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\n dependencies = [\n  \"winapi-i686-pc-windows-gnu\",\n  \"winapi-x86_64-pc-windows-gnu\",\ndiff --git a\/Cargo.toml b\/Cargo.toml\nindex 8b9c004..42589d1 100644\n--- a\/Cargo.toml\n+++ b\/Cargo.toml\n@@ -1,10 +1,11 @@\n [workspace]\n members = [\n-    \"rustzx-z80\",\n+    \"aym\",\n     \"rustzx-core\",\n+    \"rustzx-test\",\n     \"rustzx-utils\",\n+    \"rustzx-z80\",\n     \"rustzx\",\n     \"vtx\",\n     \"vtx\/vtx-bin\",\n-    \"aym\"\n ]\ndiff --git a\/README.md b\/README.md\nindex 0aedff0..e921cf6 100644\n--- a\/README.md\n+++ b\/README.md\n@@ -30,18 +30,20 @@ ZX Spectrum emulator written in Rust\n - Kempston mouse emulation\n - Extended 128K keys emulation (arrows, backspace, caps lock)\n - Quick save\/load\n+- Compressed assets support (only `.gz` for now)\n - Separate `no_std` core library which can be used to port emulator\n   almost anywhere.\n     - Global allocator is still needed, but all dynamic\n        allocations were minimized\n     - All resource-heavy features are configurable via cargo `features`\n \n-## Compiling from the latest master\n+## Install\n 1. Sure that you have C compiller and CMake to\n build bundled `sdl2`\n-2. Install it with cargo\n+2. (Linux-specific) Install required development packages: [`libasound2-dev`]\n+3. Install it with cargo\n ```bash\n-cargo install --path .\/rustzx\n+cargo install rustzx\n ```\n \n ## How to use\ndiff --git a\/aym\/Cargo.toml b\/aym\/Cargo.toml\nindex 2dcdb10..4fd2b49 100644\n--- a\/aym\/Cargo.toml\n+++ b\/aym\/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"aym\"\n-version = \"0.1.1\"\n+version = \"0.15.0\"\n description = \"AY\/YM sound chip emulation library\"\n authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n license = \"MIT\"\ndiff --git a\/monorepo.toml b\/monorepo.toml\nnew file mode 100644\nindex 0000000..6062189\n--- \/dev\/null\n+++ b\/monorepo.toml\n@@ -0,0 +1,29 @@\n+[workspace]\n+root_crate = \"rustzx\"\n+\n+[github]\n+repo = \"pacmancoder\/rustzx\"\n+\n+[release]\n+check_version_raised = true\n+allow_non_path_dev_dependencies = false\n+publish_interval_seconds = 60\n+\n+[release.github]\n+create_tag = true\n+create_release_page = true\n+check_commit_pushed = true\n+print_to_stdout = true\n+tag_name_template = \"v{{version}}\"\n+release_page_title_template = \"RustZX v{{version}}\"\n+release_page_body_template = \"{{changelog}}\"\n+release_page_upload_artifacts = true\n+\n+[artifacts]\n+directory = \"artifacts\"\n+\n+[changelog]\n+file = \"CHANGELOG.md\"\n+start_marker_template = \"<!-- START_CHANGELOG|v{{version}} -->\"\n+end_marker_template = \"<!-- END_CHANGELOG|v{{version}} -->\"\n+print_to_stdout = true\ndiff --git a\/rustzx-core\/Cargo.toml b\/rustzx-core\/Cargo.toml\nindex a54dc15..870d3d8 100644\n--- a\/rustzx-core\/Cargo.toml\n+++ b\/rustzx-core\/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"rustzx-core\"\n-version = \"0.14.0\"\n+version = \"0.15.0\"\n authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n description = \"ZX Spectum emulator core library\"\n repository = \"https:\/\/github.com\/pacmancoder\/rustzx\"\n@@ -10,7 +10,7 @@ edition = \"2018\"\n \n [features]\n default = []\n-full = [\"ay\", \"precise-border\", \"embedded-roms\", \"autoload\"]\n+full = [\"ay\", \"precise-border\", \"embedded-roms\", \"autoload\", \"strum\"]\n precise-border = []\n embedded-roms = []\n sound = []\n@@ -18,14 +18,11 @@ ay = [\"aym\", \"sound\"]\n autoload = []\n \n [dependencies]\n-bitflags = \"1\"\n-lazy_static = { version = \"1\", features = [\"spin_no_std\"] }\n+bitflags = \"1.3\"\n+lazy_static = { version = \"1.1\", features = [\"spin_no_std\"] }\n displaydoc = { version = \"0.2\", default-features = false }\n from_variants = \"0.6\"\n enum_dispatch = \"0.3\"\n-aym = { version = \"0.1.1\", path = \"..\/aym\", optional = true }\n-rustzx-z80 = { version = \"0.14\", path = \"..\/rustzx-z80\" }\n-\n-[dev-dependencies]\n-png = \"0.16\"\n-rustzx-utils = { version = \"0.14\", path =  \"..\/rustzx-utils\", features = [\"std\"] }\n+aym = { version = \"0.15\", path = \"..\/aym\", optional = true }\n+rustzx-z80 = { version = \"0.15\", path = \"..\/rustzx-z80\" }\n+strum = { version = \"0.22\", default-features = false, features = [\"derive\"], optional = true }\ndiff --git a\/rustzx-core\/src\/emulator\/fastload\/tap.rs b\/rustzx-core\/src\/emulator\/fastload\/tap.rs\nindex 2768741..72a39aa 100644\n--- a\/rustzx-core\/src\/emulator\/fastload\/tap.rs\n+++ b\/rustzx-core\/src\/emulator\/fastload\/tap.rs\n@@ -65,7 +65,7 @@ pub fn fast_load_tap<H: Host>(emulator: &mut Emulator<H>) -> Result<()> {\n                 }\n             }\n             \/\/ move destination pointer and decrease count of remaining bytes\n-            dest += 1;\n+            dest = dest.wrapping_add(1);\n             length -= 1;\n         } else {\n             \/\/ this happens if requested length and provided are not matched\ndiff --git a\/rustzx-core\/src\/emulator\/mod.rs b\/rustzx-core\/src\/emulator\/mod.rs\nindex 14d18bd..54efe48 100644\n--- a\/rustzx-core\/src\/emulator\/mod.rs\n+++ b\/rustzx-core\/src\/emulator\/mod.rs\n@@ -166,6 +166,12 @@ impl<H: Host> Emulator<H> {\n         self.controller.tape.stop();\n     }\n \n+    \/\/\/ Rewinds tape. May return error if underlying tape asset failed to\n+    \/\/\/ perform seek operaion to go back to the the beginning of the tape\n+    pub fn rewind_tape(&mut self) -> Result<()> {\n+        self.controller.tape.rewind()\n+    }\n+\n     pub fn screen_buffer(&self) -> &H::FrameBuffer {\n         self.controller.screen.frame_buffer()\n     }\n@@ -175,6 +181,14 @@ impl<H: Host> Emulator<H> {\n         self.controller.border.frame_buffer()\n     }\n \n+    pub fn set_io_extender(&mut self, extender: H::IoExtender) {\n+        self.controller.io_extender = Some(extender);\n+    }\n+\n+    pub fn io_extender(&mut self) -> Option<&mut H::IoExtender> {\n+        self.controller.io_extender.as_mut()\n+    }\n+\n     pub fn border_color(&self) -> ZXColor {\n         self.controller.border_color\n     }\n@@ -205,7 +219,7 @@ impl<H: Host> Emulator<H> {\n         self.controller.send_mouse_wheel(dir);\n     }\n \n-    pub fn send_mouse_pos(&mut self, x: i8, y: i8) {\n+    pub fn send_mouse_pos_diff(&mut self, x: i8, y: i8) {\n         self.controller.send_mouse_pos_diff(x, y);\n     }\n \ndiff --git a\/rustzx-core\/src\/host\/io.rs b\/rustzx-core\/src\/host\/io.rs\nindex 9cc0f51..ce33612 100644\n--- a\/rustzx-core\/src\/host\/io.rs\n+++ b\/rustzx-core\/src\/host\/io.rs\n@@ -16,6 +16,12 @@ pub struct BufferCursor<T: AsRef<[u8]>> {\n     pos: usize,\n }\n \n+impl<T: AsRef<[u8]>> BufferCursor<T> {\n+    pub fn into_inner(self) -> T {\n+        self.data\n+    }\n+}\n+\n impl<T: AsRef<[u8]>> BufferCursor<T> {\n     pub fn new(data: T) -> Self {\n         Self { data, pos: 0 }\ndiff --git a\/rustzx-core\/src\/host\/mod.rs b\/rustzx-core\/src\/host\/mod.rs\nindex 12cadda..4768904 100644\n--- a\/rustzx-core\/src\/host\/mod.rs\n+++ b\/rustzx-core\/src\/host\/mod.rs\n@@ -49,6 +49,34 @@ impl<T> ScreenAsset for T where T: LoadableAsset + SeekableAsset {}\n pub trait SnapshotAsset: LoadableAsset + SeekableAsset {}\n impl<T> SnapshotAsset for T where T: LoadableAsset + SeekableAsset {}\n \n+\/\/\/ Allows to extend base rustzx-core functionality by providing\n+\/\/\/ interface for user-defined IO ports handling\n+pub trait IoExtender {\n+    \/\/\/ Write byte value to io extender\n+    fn write(&mut self, port: u16, data: u8);\n+    \/\/\/ Read byte value from io extender\n+    fn read(&mut self, port: u16) -> u8;\n+    \/\/\/ Return true if io externder can process\n+    \/\/\/ incomming read\/write operation for a\n+    \/\/\/ given port\n+    fn extends_port(&self, port: u16) -> bool;\n+}\n+\n+\/\/\/ Does not extend any IO\n+pub struct StubIoExtender {}\n+\n+impl IoExtender for StubIoExtender {\n+    fn write(&mut self, _: u16, _: u8) {}\n+\n+    fn read(&mut self, _: u16) -> u8 {\n+        0\n+    }\n+\n+    fn extends_port(&self, _: u16) -> bool {\n+        false\n+    }\n+}\n+\n \/\/\/ Represents set of required types for emulator implementation\n \/\/\/ based on `rustzx-core`.\n pub trait Host {\n@@ -59,5 +87,8 @@ pub trait Host {\n     type TapeAsset: LoadableAsset + SeekableAsset;\n     \/\/\/ Frame buffer implementation\n     type FrameBuffer: FrameBuffer;\n+    \/\/\/ Type which should provide methods to measure time intervals\n     type EmulationStopwatch: Stopwatch;\n+    \/\/\/ RustZX debug port implementation\n+    type IoExtender: IoExtender;\n }\ndiff --git a\/rustzx-core\/src\/lib.rs b\/rustzx-core\/src\/lib.rs\nindex 20774ce..5a571ee 100644\n--- a\/rustzx-core\/src\/lib.rs\n+++ b\/rustzx-core\/src\/lib.rs\n@@ -1,5 +1,4 @@\n #![no_std]\n-#![allow(dead_code)]\n \n pub(crate) mod emulator;\n pub(crate) mod settings;\n@@ -13,6 +12,9 @@ pub use emulator::Emulator;\n pub use settings::RustzxSettings;\n pub use utils::EmulationMode;\n \n+#[cfg(feature = \"strum\")]\n+pub use strum::IntoEnumIterator as IterableEnum;\n+\n extern crate alloc;\n \n pub type Result<T> = core::result::Result<T, error::Error>;\ndiff --git a\/rustzx-core\/src\/zx\/constants.rs b\/rustzx-core\/src\/zx\/constants.rs\nindex 1c3c510..32abbd1 100644\n--- a\/rustzx-core\/src\/zx\/constants.rs\n+++ b\/rustzx-core\/src\/zx\/constants.rs\n@@ -11,16 +11,13 @@ pub const SCREEN_HEIGHT: usize = CANVAS_HEIGHT + BORDER_ROWS * 8 * 2;\n \/\/\/ Frames per second\n pub const FPS: usize = 50;\n \n-\/\/\/ addresses\n-pub(crate) const BITMAP_BASE_ADDR: u16 = 0x4000;\n-pub(crate) const ATTR_BASE_ADDR: u16 = 0x5800;\n-pub(crate) const ATTR_MAX_ADDR: u16 = 0x5AFF;\n \/\/\/ relative addresses\n pub(crate) const BITMAP_MAX_REL: u16 = 0x17FF;\n pub(crate) const ATTR_BASE_REL: u16 = 0x1800;\n pub(crate) const ATTR_MAX_REL: u16 = 0x1AFF;\n \/\/\/ on all spectrums theese values are fixed\n pub(crate) const CLOCKS_PER_COL: usize = 4;\n+#[cfg(feature = \"precise-border\")]\n pub(crate) const PIXELS_PER_CLOCK: usize = 2;\n \/\/\/ size of screen in rows, cols\n pub(crate) const ATTR_COLS: usize = CANVAS_WIDTH \/ 8;\ndiff --git a\/rustzx-core\/src\/zx\/controller.rs b\/rustzx-core\/src\/zx\/controller.rs\nindex 56390df..2245083 100644\n--- a\/rustzx-core\/src\/zx\/controller.rs\n+++ b\/rustzx-core\/src\/zx\/controller.rs\n@@ -1,7 +1,7 @@\n \/\/! Contains ZX Spectrum System contrller (like ula or so) of emulator\n use crate::{\n     error::Error,\n-    host::{Host, HostContext},\n+    host::{Host, HostContext, IoExtender},\n     settings::RustzxSettings,\n     utils::screen::bitmap_line_addr,\n     zx::{\n@@ -39,6 +39,7 @@ pub(crate) struct ZXController<H: Host> {\n     pub border: ZXBorder<H::FrameBuffer>,\n     pub kempston: Option<KempstonJoy>,\n     pub mouse: Option<KempstonMouse>,\n+    pub io_extender: Option<H::IoExtender>,\n     #[cfg(feature = \"sound\")]\n     pub mixer: ZXMixer,\n     pub keyboard: [u8; 8],\n@@ -63,6 +64,7 @@ pub(crate) struct ZXController<H: Host> {\n \n impl<H: Host> ZXController<H> {\n     \/\/\/ Returns new ZXController from settings\n+    #[allow(clippy::let_and_return)]\n     pub fn new(settings: &RustzxSettings, host_context: H::Context) -> Self {\n         let (memory, paging, screen_bank);\n         match settings.machine {\n@@ -105,6 +107,7 @@ impl<H: Host> ZXController<H> {\n             border,\n             kempston,\n             mouse,\n+            io_extender: None,\n             #[cfg(feature = \"sound\")]\n             mixer,\n             keyboard: [0xFF; 8],\n@@ -147,6 +150,7 @@ impl<H: Host> ZXController<H> {\n     }\n \n     \/\/\/ returns current frame emulation pos in percents\n+    #[cfg(feature = \"sound\")]\n     fn frame_pos(&self) -> f64 {\n         let val = self.frame_clocks as f64 \/ self.machine.specs().clocks_frame as f64;\n         if val > 1.0 {\n@@ -327,11 +331,6 @@ impl<H: Host> ZXController<H> {\n         self.passed_frames = 0;\n     }\n \n-    \/\/\/ Returns current clocks from frame start\n-    pub fn clocks(&self) -> usize {\n-        self.frame_clocks\n-    }\n-\n     pub fn write_7ffd(&mut self, val: u8) {\n         if !self.paging_enabled {\n             return;\n@@ -384,7 +383,8 @@ impl<H: Host> ZXController<H> {\n \n     pub(crate) fn set_border_color(\n         &mut self,\n-        #[allow(unused_variables)] clocks: usize,\n+        #[cfg(feature = \"precise-border\")] clocks: usize,\n+        #[cfg(not(feature = \"precise-border\"))] _clocks: usize,\n         color: ZXColor,\n     ) {\n         self.border_color = color;\n@@ -492,9 +492,17 @@ impl<H: Host> Z80Bus for ZXController<H> {\n         \/\/ all contentions check\n         self.io_contention_first(port);\n         self.io_contention_last(port);\n+\n+        let io_extender_value = self\n+            .io_extender\n+            .as_mut()\n+            .and_then(|e| e.extends_port(port).then(|| e.read(port)));\n+\n         \/\/ find out what we need to do\n         let [_, h] = port.to_le_bytes();\n-        let output = if port & 0x0001 == 0 {\n+        let output = if let Some(value) = io_extender_value {\n+            value\n+        } else if port & 0x0001 == 0 {\n             \/\/ ULA port\n             let mut tmp: u8 = 0xFF;\n             for n in 0..8 {\n@@ -536,8 +544,15 @@ impl<H: Host> Z80Bus for ZXController<H> {\n     fn write_io(&mut self, port: u16, data: u8) {\n         \/\/ first contention\n         self.io_contention_first(port);\n+\n         \/\/ find active port\n-        if port & 0xC002 == 0xC000 {\n+        if self\n+            .io_extender\n+            .as_ref()\n+            .map_or(false, |e| e.extends_port(port))\n+        {\n+            self.io_extender.as_mut().unwrap().write(port, data);\n+        } else if port & 0xC002 == 0xC000 {\n             self.select_ay_reg(data);\n         } else if port & 0xC002 == 0x8000 {\n             self.write_ay_port(data);\ndiff --git a\/rustzx-core\/src\/zx\/joy\/kempston.rs b\/rustzx-core\/src\/zx\/joy\/kempston.rs\nindex 585bb50..5726849 100644\n--- a\/rustzx-core\/src\/zx\/joy\/kempston.rs\n+++ b\/rustzx-core\/src\/zx\/joy\/kempston.rs\n@@ -1,10 +1,18 @@\n \/\/\/ Kempston key type. Port bit encoded in enum values\n+#[cfg_attr(feature = \"strum\", derive(strum::EnumIter))]\n+#[derive(Clone, Copy)]\n pub enum KempstonKey {\n     Right = 0x01,\n     Left = 0x02,\n     Down = 0x04,\n     Up = 0x08,\n     Fire = 0x10,\n+    \/\/\/ Undocumented extra button 1\n+    Ext1 = 0x20,\n+    \/\/\/ Undocumented extra button 2\n+    Ext2 = 0x40,\n+    \/\/\/ Undocumented extra button 3\n+    Ext3 = 0x80,\n }\n \n \/\/\/ Kempston Joystick\ndiff --git a\/rustzx-core\/src\/zx\/joy\/sinclair.rs b\/rustzx-core\/src\/zx\/joy\/sinclair.rs\nindex 2b0851a..9a34029 100644\n--- a\/rustzx-core\/src\/zx\/joy\/sinclair.rs\n+++ b\/rustzx-core\/src\/zx\/joy\/sinclair.rs\n@@ -1,5 +1,7 @@\n use crate::zx::keys::ZXKey;\n \n+#[cfg_attr(feature = \"strum\", derive(strum::EnumIter))]\n+#[derive(Debug, Clone, Copy)]\n pub enum SinclairKey {\n     Left,\n     Right,\n@@ -8,6 +10,8 @@ pub enum SinclairKey {\n     Fire,\n }\n \n+#[cfg_attr(feature = \"strum\", derive(strum::EnumIter))]\n+#[derive(Debug, Clone, Copy)]\n pub enum SinclairJoyNum {\n     Fist,\n     Second,\ndiff --git a\/rustzx-core\/src\/zx\/keys.rs b\/rustzx-core\/src\/zx\/keys.rs\nindex 9fbbeec..e421964 100644\n--- a\/rustzx-core\/src\/zx\/keys.rs\n+++ b\/rustzx-core\/src\/zx\/keys.rs\n@@ -2,7 +2,8 @@\n \n \/\/\/ Struct, which contains mast and port of key\n #[rustfmt::skip]\n-#[derive(Clone, Copy)]\n+#[cfg_attr(feature = \"strum\", derive(strum::EnumIter))]\n+#[derive(Debug, Clone, Copy)]\n pub enum ZXKey {\n     \/\/ Port 0xFEFE\n     Shift, Z, X, C, V,\n@@ -22,7 +23,8 @@ pub enum ZXKey {\n     Space, SymShift, M, N, B,\n }\n \n-#[derive(Clone, Copy)]\n+#[cfg_attr(feature = \"strum\", derive(strum::EnumIter))]\n+#[derive(Debug, Clone, Copy)]\n pub enum CompoundKey {\n     ArrowLeft,\n     ArrowRight,\ndiff --git a\/rustzx-core\/src\/zx\/memory.rs b\/rustzx-core\/src\/zx\/memory.rs\nindex a01cc09..a8604a1 100644\n--- a\/rustzx-core\/src\/zx\/memory.rs\n+++ b\/rustzx-core\/src\/zx\/memory.rs\n@@ -6,7 +6,6 @@ pub const PAGE_SIZE: usize = 16 * 1024;\n pub const SIZE_16K: usize = PAGE_SIZE;\n pub const SIZE_32K: usize = PAGE_SIZE * 2;\n pub const SIZE_48K: usize = PAGE_SIZE * 3;\n-pub const SIZE_64K: usize = PAGE_SIZE * 4;\n pub const SIZE_128K: usize = PAGE_SIZE * 8;\n \/\/ count of all memory blocks\n pub const MEM_BLOCKS: usize = 4;\n@@ -14,11 +13,9 @@ pub const MEM_BLOCKS: usize = 4;\n \/\/\/ Rom can be:\n \/\/\/ - 16K (Sinclair48K)\n \/\/\/ - 32K (Sinclair128K, 2+)\n-\/\/\/ - 64k (Amstrad 3+)\n pub enum RomType {\n     K16,\n     K32,\n-    K64,\n }\n \n \/\/\/ Ram can be:\n@@ -63,7 +60,6 @@ impl ZXMemory {\n         let rom_size = match rom_type {\n             RomType::K16 => SIZE_16K,\n             RomType::K32 => SIZE_32K,\n-            RomType::K64 => SIZE_64K,\n         };\n         ZXMemory {\n             rom: vec![0; rom_size],\n@@ -82,15 +78,6 @@ impl ZXMemory {\n         }\n     }\n \n-    \/\/\/ Returns value of data with relative `addr` at `bank`\n-    pub fn paged_read(&self, page: Page, addr: u16) -> u8 {\n-        assert!((addr as usize) < PAGE_SIZE);\n-        match page {\n-            Page::Rom(page) => self.rom[(page as usize) * PAGE_SIZE + addr as usize],\n-            Page::Ram(page) => self.ram[(page as usize) * PAGE_SIZE + addr as usize],\n-        }\n-    }\n-\n     \/\/\/ Writes value to memory\n     pub fn write(&mut self, addr: u16, value: u8) {\n         let page = self.map[(addr as usize) \/ PAGE_SIZE];\n@@ -155,13 +142,4 @@ impl ZXMemory {\n         let shift = page as usize * PAGE_SIZE;\n         &self.ram[shift..shift + PAGE_SIZE]\n     }\n-\n-    \/\/\/ Dumps current address space\n-    pub fn dump(&self) -> Vec<u8> {\n-        let mut out = Vec::new();\n-        for n in 0..SIZE_64K {\n-            out.push(self.read(n as u16));\n-        }\n-        out\n-    }\n }\ndiff --git a\/rustzx-core\/src\/zx\/mouse\/kempston.rs b\/rustzx-core\/src\/zx\/mouse\/kempston.rs\nindex 44dad98..4f1eda1 100644\n--- a\/rustzx-core\/src\/zx\/mouse\/kempston.rs\n+++ b\/rustzx-core\/src\/zx\/mouse\/kempston.rs\n@@ -19,6 +19,7 @@ impl Default for KempstonMouse {\n     }\n }\n \n+#[cfg_attr(feature = \"strum\", derive(strum::EnumIter))]\n #[derive(Clone, Copy, Debug)]\n pub enum KempstonMouseButton {\n     Left = 0x01,\n@@ -27,6 +28,7 @@ pub enum KempstonMouseButton {\n     Additional = 0x08,\n }\n \n+#[cfg_attr(feature = \"strum\", derive(strum::EnumIter))]\n #[derive(Clone, Copy, Debug)]\n #[repr(i8)]\n pub enum KempstonMouseWheelDirection {\ndiff --git a\/rustzx-core\/src\/zx\/sound\/ay.rs b\/rustzx-core\/src\/zx\/sound\/ay.rs\nindex 0584b69..d0c77df 100644\n--- a\/rustzx-core\/src\/zx\/sound\/ay.rs\n+++ b\/rustzx-core\/src\/zx\/sound\/ay.rs\n@@ -27,8 +27,11 @@ impl ZXAyChip {\n             ZXAYMode::ACB => AyMode::ACB,\n         };\n \n+        let mut ay = AymPrecise::new(SoundChip::AY, mode, AY_FREQ, sample_rate);\n+        ay.enable_dc_filter();\n+\n         Self {\n-            ay: AymBackend::new(SoundChip::AY, mode, AY_FREQ, sample_rate),\n+            ay,\n             current_reg: 0,\n             regs: [0; 16],\n         }\n@@ -53,11 +56,6 @@ impl ZXAyChip {\n impl SampleGenerator<f64> for ZXAyChip {\n     fn gen_sample(&mut self) -> SoundSample<f64> {\n         let sample = self.ay.next_sample();\n-\n-        \/\/ Place -1..1 sample in 0..1 range\n-        let left = (sample.left + 1f64) \/ (2f64);\n-        let right = (sample.right + 1f64) \/ (2f64);\n-\n-        SoundSample::new(left, right)\n+        SoundSample::new(sample.left, sample.right)\n     }\n }\ndiff --git a\/rustzx-core\/src\/zx\/sound\/beeper.rs b\/rustzx-core\/src\/zx\/sound\/beeper.rs\nindex c92e2f7..d4679fd 100644\n--- a\/rustzx-core\/src\/zx\/sound\/beeper.rs\n+++ b\/rustzx-core\/src\/zx\/sound\/beeper.rs\n@@ -17,6 +17,13 @@ impl ZXBeeper {\n \n impl SampleGenerator<f64> for ZXBeeper {\n     fn gen_sample(&mut self) -> SoundSample<f64> {\n+        \/\/ - Beeper intentionally made produce only positive half-wave 0..0.5\n+        \/\/ range instead of -0.25..0.25) because of current emulator lack of\n+        \/\/ dc filtering.\n+        \/\/ - Beeper only produces a quater of available sample\n+        \/\/ range because relatively to AY chip, square wave of a beeper is\n+        \/\/ too loud\n+\n         const EAR_SAMPLE_FACTOR: f64 = 0.5;\n         const MIC_SAMPLE_FACTOR: f64 = EAR_SAMPLE_FACTOR \/ 5.0;\n \ndiff --git a\/rustzx-core\/src\/zx\/sound\/mixer.rs b\/rustzx-core\/src\/zx\/sound\/mixer.rs\nindex 41a706a..fce6a40 100644\n--- a\/rustzx-core\/src\/zx\/sound\/mixer.rs\n+++ b\/rustzx-core\/src\/zx\/sound\/mixer.rs\n@@ -7,6 +7,8 @@ use crate::zx::{\n     },\n };\n \n+\/\/ TODO(#117): Implement DC filtering for sound mixing\n+\n #[cfg(feature = \"ay\")]\n use crate::zx::sound::ay::{ZXAYMode, ZXAyChip};\n \n@@ -23,9 +25,6 @@ pub(crate) struct ZXMixer {\n     last_pos: usize,\n     last_sample: SoundSample<f32>,\n     master_volume: f64,\n-    beeper_volume: f64,\n-    #[cfg(feature = \"ay\")]\n-    ay_volume: f64,\n     #[cfg(feature = \"ay\")]\n     use_ay: bool,\n     use_beeper: bool,\n@@ -51,9 +50,6 @@ impl ZXMixer {\n             last_pos: 0,\n             last_sample: SoundSample::new(0.0, 0.0),\n             master_volume: 0.5,\n-            beeper_volume: 1.0,\n-            #[cfg(feature = \"ay\")]\n-            ay_volume: 1.0,\n             #[cfg(feature = \"ay\")]\n             use_ay,\n             use_beeper,\ndiff --git a\/rustzx-core\/src\/zx\/sound\/sample.rs b\/rustzx-core\/src\/zx\/sound\/sample.rs\nindex 71517f9..fb2a9d1 100644\n--- a\/rustzx-core\/src\/zx\/sound\/sample.rs\n+++ b\/rustzx-core\/src\/zx\/sound\/sample.rs\n@@ -3,13 +3,11 @@ use core::{\n     ops::{Add, Mul, MulAssign, Sub},\n };\n \n-\/\/\/ Raw Sample can be only f64 or i16\n pub trait RawSample: Clone + Copy + MulAssign + Mul + Add + Sub {}\n impl RawSample for f64 {}\n impl RawSample for f32 {}\n impl RawSample for i16 {}\n \n-const ERROR_SIZE: u16 = 100;\n \/\/ Sound sample type\n \/\/ Have it's have two special cases: `SoundSample<f64>`\n \/\/ And `SoundSample<i16>`\ndiff --git a\/rustzx-core\/src\/zx\/tape\/tap.rs b\/rustzx-core\/src\/zx\/tape\/tap.rs\nindex 4dafdc6..65a3e7e 100644\n--- a\/rustzx-core\/src\/zx\/tape\/tap.rs\n+++ b\/rustzx-core\/src\/zx\/tape\/tap.rs\n@@ -261,7 +261,6 @@ impl<A: LoadableAsset + SeekableAsset> TapeImpl for Tap<A> {\n     }\n \n     fn rewind(&mut self) -> Result<()> {\n-        self.state = TapeState::Stop;\n         self.curr_bit = false;\n         self.curr_byte = 0x00;\n         self.block_bytes_read = 0;\ndiff --git a\/rustzx-core\/src\/zx\/video\/border.rs b\/rustzx-core\/src\/zx\/video\/border.rs\nindex 9d7031e..192c893 100644\n--- a\/rustzx-core\/src\/zx\/video\/border.rs\n+++ b\/rustzx-core\/src\/zx\/video\/border.rs\n@@ -29,11 +29,6 @@ impl BeamInfo {\n         BeamInfo { line, pixel, color }\n     }\n \n-    \/\/\/ checks if beam is on first pixel\n-    fn is_first_pixel(&self) -> bool {\n-        (self.line == 0) && (self.pixel == 0)\n-    }\n-\n     \/\/\/ resets position\n     fn reset(&mut self) {\n         self.line = 0;\ndiff --git a\/rustzx-core\/src\/zx\/video\/screen.rs b\/rustzx-core\/src\/zx\/video\/screen.rs\nindex 98e7a35..80c74a0 100644\n--- a\/rustzx-core\/src\/zx\/video\/screen.rs\n+++ b\/rustzx-core\/src\/zx\/video\/screen.rs\n@@ -90,7 +90,6 @@ pub struct ZXScreen<FB: FrameBuffer> {\n     back_buffer: FB,\n     banks: [ScreenBank; 2],\n     active_bank: usize,\n-    next_bank: usize,\n }\n \n impl<FB: FrameBuffer> ZXScreen<FB> {\n@@ -124,7 +123,6 @@ impl<FB: FrameBuffer> ZXScreen<FB> {\n                 },\n             ],\n             active_bank: 0,\n-            next_bank: 0,\n         }\n     }\n \ndiff --git a\/rustzx-utils\/Cargo.toml b\/rustzx-utils\/Cargo.toml\nindex 442fb72..0299a9d 100644\n--- a\/rustzx-utils\/Cargo.toml\n+++ b\/rustzx-utils\/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"rustzx-utils\"\n-version = \"0.14.0\"\n+version = \"0.15.0\"\n authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n description = \"Additional helpers for rustzx-core based emulators\"\n repository = \"https:\/\/github.com\/pacmancoder\/rustzx\"\n@@ -9,8 +9,10 @@ license = \"MIT\"\n edition = \"2018\"\n \n [dependencies]\n-rustzx-core = { version = \"0.14\", path = \"..\/rustzx-core\" }\n+rustzx-core = { version = \"0.15\", path = \"..\/rustzx-core\" }\n+log = { version = \"0.4\", optional = true }\n+flate2 = { version = \"1.0\", optional = true }\n \n [features]\n default = []\n-std = []\n+std = [ \"log\", \"flate2\" ]\ndiff --git a\/rustzx\/src\/host\/io.rs b\/rustzx-utils\/src\/io\/file.rs\nsimilarity index 79%\nrename from rustzx\/src\/host\/io.rs\nrename to rustzx-utils\/src\/io\/file.rs\nindex 66b94c0..6c65869 100644\n--- a\/rustzx\/src\/host\/io.rs\n+++ b\/rustzx-utils\/src\/io\/file.rs\n@@ -1,3 +1,5 @@\n+use super::{into_std_seek_pos, DynamicAssetImpl, DynamicDataRecorderImpl};\n+\n use rustzx_core::{\n     error::IoError,\n     host::{DataRecorder, LoadableAsset, SeekFrom, SeekableAsset},\n@@ -48,10 +50,5 @@ impl DataRecorder for FileAsset {\n     }\n }\n \n-fn into_std_seek_pos(pos: SeekFrom) -> std::io::SeekFrom {\n-    match pos {\n-        SeekFrom::Start(offset) => std::io::SeekFrom::Start(offset as u64),\n-        SeekFrom::End(offset) => std::io::SeekFrom::End(offset as i64),\n-        SeekFrom::Current(offset) => std::io::SeekFrom::Current(offset as i64),\n-    }\n-}\n+impl DynamicAssetImpl for FileAsset {}\n+impl DynamicDataRecorderImpl for FileAsset {}\ndiff --git a\/rustzx-utils\/src\/io\/gzip.rs b\/rustzx-utils\/src\/io\/gzip.rs\nnew file mode 100644\nindex 0000000..7e17a36\n--- \/dev\/null\n+++ b\/rustzx-utils\/src\/io\/gzip.rs\n@@ -0,0 +1,47 @@\n+use super::DynamicAssetImpl;\n+\n+use rustzx_core::{\n+    error::IoError,\n+    host::{BufferCursor, LoadableAsset, SeekFrom, SeekableAsset},\n+};\n+\n+use std::{\n+    io::{self, Read},\n+    vec,\n+    vec::Vec,\n+};\n+\n+use flate2::read::GzDecoder;\n+\n+pub struct GzipAsset {\n+    buffer: BufferCursor<Vec<u8>>,\n+}\n+\n+impl GzipAsset {\n+    pub fn new(file: impl Read) -> Result<Self, io::Error> {\n+        \/\/ ZX Spectrum assets are small enough to use RAM for unpacked data\n+        let mut buffer = vec![];\n+        let _ = GzDecoder::new(file).read_to_end(&mut buffer)?;\n+        Ok(Self {\n+            buffer: BufferCursor::new(buffer),\n+        })\n+    }\n+\n+    pub fn into_vec(self) -> Vec<u8> {\n+        self.buffer.into_inner()\n+    }\n+}\n+\n+impl SeekableAsset for GzipAsset {\n+    fn seek(&mut self, pos: SeekFrom) -> Result<usize, IoError> {\n+        self.buffer.seek(pos)\n+    }\n+}\n+\n+impl LoadableAsset for GzipAsset {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize, IoError> {\n+        self.buffer.read(buf)\n+    }\n+}\n+\n+impl DynamicAssetImpl for GzipAsset {}\ndiff --git a\/rustzx-utils\/src\/io\/mod.rs b\/rustzx-utils\/src\/io\/mod.rs\nnew file mode 100644\nindex 0000000..ab39876\n--- \/dev\/null\n+++ b\/rustzx-utils\/src\/io\/mod.rs\n@@ -0,0 +1,60 @@\n+mod file;\n+mod gzip;\n+\n+use rustzx_core::{\n+    error::IoError,\n+    host::{BufferCursor, DataRecorder, LoadableAsset, SeekFrom, SeekableAsset},\n+};\n+\n+use std::boxed::Box;\n+\n+pub use file::FileAsset;\n+pub use gzip::GzipAsset;\n+\n+pub trait DynamicAssetImpl: LoadableAsset + SeekableAsset {}\n+\n+impl<T: AsRef<[u8]>> DynamicAssetImpl for BufferCursor<T> {}\n+\n+pub struct DynamicAsset {\n+    inner: Box<dyn DynamicAssetImpl>,\n+}\n+\n+impl<T: DynamicAssetImpl + 'static> From<T> for DynamicAsset {\n+    fn from(inner: T) -> Self {\n+        Self {\n+            inner: Box::new(inner),\n+        }\n+    }\n+}\n+\n+impl LoadableAsset for DynamicAsset {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize, IoError> {\n+        self.inner.read(buf)\n+    }\n+}\n+\n+impl SeekableAsset for DynamicAsset {\n+    fn seek(&mut self, pos: SeekFrom) -> Result<usize, IoError> {\n+        self.inner.seek(pos)\n+    }\n+}\n+\n+pub trait DynamicDataRecorderImpl: DataRecorder {}\n+\n+pub struct DynamicDataRecorder {\n+    inner: Box<dyn DynamicDataRecorderImpl>,\n+}\n+\n+impl DataRecorder for DynamicDataRecorder {\n+    fn write(&mut self, buf: &[u8]) -> Result<usize, IoError> {\n+        self.inner.write(buf)\n+    }\n+}\n+\n+pub(crate) fn into_std_seek_pos(pos: SeekFrom) -> std::io::SeekFrom {\n+    match pos {\n+        SeekFrom::Start(offset) => std::io::SeekFrom::Start(offset as u64),\n+        SeekFrom::End(offset) => std::io::SeekFrom::End(offset as i64),\n+        SeekFrom::Current(offset) => std::io::SeekFrom::Current(offset as i64),\n+    }\n+}\ndiff --git a\/rustzx-utils\/src\/lib.rs b\/rustzx-utils\/src\/lib.rs\nindex 82b4197..7ea3918 100644\n--- a\/rustzx-utils\/src\/lib.rs\n+++ b\/rustzx-utils\/src\/lib.rs\n@@ -6,3 +6,6 @@ extern crate std;\n pub mod palette;\n #[cfg(feature = \"std\")]\n pub mod stopwatch;\n+\n+#[cfg(all(feature = \"std\"))]\n+pub mod io;\ndiff --git a\/rustzx-z80\/Cargo.toml b\/rustzx-z80\/Cargo.toml\nindex cc461eb..64551fb 100644\n--- a\/rustzx-z80\/Cargo.toml\n+++ b\/rustzx-z80\/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"rustzx-z80\"\n-version = \"0.14.0\"\n+version = \"0.15.0\"\n authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n description = \"Z80 CPU emulator library\"\n repository = \"https:\/\/github.com\/pacmancoder\/rustzx\"\n@@ -9,4 +9,4 @@ license = \"MIT\"\n edition = \"2018\"\n \n [dev-dependencies]\n-paste = \"1\"\n+paste = \"1.0\"\ndiff --git a\/rustzx\/Cargo.toml b\/rustzx\/Cargo.toml\nindex c48b070..fdc12e3 100644\n--- a\/rustzx\/Cargo.toml\n+++ b\/rustzx\/Cargo.toml\n@@ -1,8 +1,8 @@\n [package]\n name = \"rustzx\"\n-version = \"0.14.0\"\n+version = \"0.15.0\"\n authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n-description = \"ZX Spectum emulator\"\n+description = \"ZX Spectrum emulator\"\n repository = \"https:\/\/github.com\/pacmancoder\/rustzx\"\n readme = \"..\/README.md\"\n keywords = [\"emulator\", \"game\", \"z80\"]\n@@ -13,9 +13,17 @@ edition = \"2018\"\n \n [dependencies]\n sdl2 = { version = \"0.34\", features = [\"unsafe_textures\", \"bundled\", \"static-link\"] }\n-rustzx-core = { version = \"0.14\", path =  \"..\/rustzx-core\", features = [\"full\"] }\n-rustzx-utils = { version = \"0.14\", path =  \"..\/rustzx-utils\", features = [\"std\"] }\n+rustzx-core = { version = \"0.15\", path =  \"..\/rustzx-core\", features = [\"full\"] }\n+rustzx-utils = { version = \"0.15\", path =  \"..\/rustzx-utils\", features = [\"std\"] }\n log = \"0.4\"\n-anyhow = \"1\"\n+anyhow = \"1.0\"\n structopt = \"0.3\"\n-env_logger = \"0.8\"\n+strum = { version = \"0.22\", default-features = false, features = [\"derive\", \"std\"] }\n+env_logger = \"0.9\"\n+cpal = { version = \"0.13\", default-features = false, optional = true }\n+\n+[features]\n+default = [\"sound-cpal\"]\n+# cpal requries ALSA development headers on Linux, if this feature\n+# is disabled, RustZX will be built only with SDL audio backend support\n+sound-cpal = [\"cpal\"]\ndiff --git a\/rustzx\/src\/app\/events\/events_sdl.rs b\/rustzx\/src\/app\/events\/events_sdl.rs\nindex ba1a75c..4848074 100644\n--- a\/rustzx\/src\/app\/events\/events_sdl.rs\n+++ b\/rustzx\/src\/app\/events\/events_sdl.rs\n@@ -26,7 +26,6 @@ pub struct EventsSdl {\n     kempston_enabled: bool,\n     mouse_enabled: bool,\n     mouse_locked: bool,\n-    screen_scale: usize,\n     mouse_sensitivity: usize,\n     enable_joy_keyaboard_layer: bool,\n     mouse_x_counter: i32,\n@@ -55,7 +54,6 @@ impl EventsSdl {\n             mouse_enabled: settings.enable_mouse,\n             mouse_locked: false,\n             kempston_enabled: !settings.disable_kempston,\n-            screen_scale: settings.scale,\n             enable_joy_keyaboard_layer: false,\n             mouse_sensitivity: settings.mouse_sensitivity,\n             mouse_x_counter: 0,\ndiff --git a\/rustzx\/src\/app\/rustzx.rs b\/rustzx\/src\/app\/rustzx.rs\nindex 37ca7f6..0a9b064 100644\n--- a\/rustzx\/src\/app\/rustzx.rs\n+++ b\/rustzx\/src\/app\/rustzx.rs\n@@ -5,13 +5,13 @@\n use crate::{\n     app::{\n         events::{Event, EventDevice, EventsSdl},\n-        settings::Settings,\n-        sound::{SoundDevice, SoundSdl},\n+        settings::{Settings, SoundBackend},\n+        sound::{SoundDevice, DEFAULT_SAMPLE_RATE},\n         video::{Rect, TextureInfo, VideoDevice, VideoSdl},\n     },\n-    host::{self, AppHost, AppHostContext, DetectedFileKind, FileAsset},\n+    host::{self, AppHost, AppHostContext, DetectedFileKind},\n };\n-use anyhow::anyhow;\n+use anyhow::{anyhow, Context};\n use rustzx_core::{\n     host::SnapshotRecorder,\n     zx::constants::{\n@@ -19,6 +19,7 @@ use rustzx_core::{\n     },\n     Emulator,\n };\n+use rustzx_utils::io::FileAsset;\n use std::{\n     fs::{self, File},\n     path::{Path, PathBuf},\n@@ -54,8 +55,12 @@ pub struct RustzxApp {\n impl RustzxApp {\n     \/\/\/ Starts application itself\n     pub fn from_config(settings: Settings) -> anyhow::Result<RustzxApp> {\n-        let snd: Option<Box<dyn SoundDevice>> = if !settings.disable_sound {\n-            Some(Box::new(SoundSdl::new(&settings)))\n+        let snd = if !settings.disable_sound {\n+            let backend = create_sound_backend(&settings).context(\n+                \"Failed to initialize sound subsystem, try other sound backend or --nosound option\",\n+            )?;\n+\n+            Some(backend)\n         } else {\n             None\n         };\n@@ -64,8 +69,12 @@ impl RustzxApp {\n         let tex_canvas = video.gen_texture(CANVAS_WIDTH as u32, CANVAS_HEIGHT as u32);\n         let scale = settings.scale as u32;\n         let events = Box::new(EventsSdl::new(&settings));\n+        let sample_rate = snd\n+            .as_ref()\n+            .map(|s| s.sample_rate())\n+            .unwrap_or(DEFAULT_SAMPLE_RATE);\n \n-        let mut emulator = Emulator::new(settings.to_rustzx_settings(), AppHostContext)\n+        let mut emulator = Emulator::new(settings.to_rustzx_settings(sample_rate), AppHostContext)\n             .map_err(|e| anyhow!(\"Failed to construct emulator: {}\", e))?;\n \n         if let Some(rom) = settings.rom.as_ref() {\n@@ -137,7 +146,7 @@ impl RustzxApp {\n             let emulator_dt = self\n                 .emulator\n                 .emulate_frames(MAX_FRAME_TIME)\n-                .map_err(|e| anyhow!(\"Emulation step failed: {}\", e))?;\n+                .map_err(|e| anyhow!(\"Emulation step failed: {:#?}\", e))?;\n             \/\/ if sound enabled sound ganeration allowed then move samples to sound thread\n             if let Some(ref mut snd) = self.snd {\n                 \/\/ if can be turned off even on speed change, so check it everytime\n@@ -203,7 +212,7 @@ impl RustzxApp {\n                         self.emulator.send_compound_key(key, state);\n                     }\n                     Event::MouseMove { x, y } => {\n-                        self.emulator.send_mouse_pos(x, y);\n+                        self.emulator.send_mouse_pos_diff(x, y);\n                     }\n                     Event::MouseButton(buton, pressed) => {\n                         self.emulator.send_mouse_button(buton, pressed);\n@@ -305,3 +314,14 @@ impl RustzxApp {\n         Path::new(\"default.rustzx.prev.sna\").to_owned()\n     }\n }\n+\n+fn create_sound_backend(settings: &Settings) -> anyhow::Result<Box<dyn SoundDevice>> {\n+    use crate::app::sound;\n+\n+    let backend: Box<dyn SoundDevice> = match settings.sound_backend {\n+        SoundBackend::Sdl => Box::new(sound::SoundSdl::new(settings)?),\n+        #[cfg(feature = \"sound-cpal\")]\n+        SoundBackend::Cpal => Box::new(sound::SoundCpal::new(settings)?),\n+    };\n+    Ok(backend)\n+}\ndiff --git a\/rustzx\/src\/app\/settings.rs b\/rustzx\/src\/app\/settings.rs\nindex e23a79a..9f9fe9b 100644\n--- a\/rustzx\/src\/app\/settings.rs\n+++ b\/rustzx\/src\/app\/settings.rs\n@@ -2,13 +2,28 @@ use rustzx_core::{\n     zx::{machine::ZXMachine, sound::ay::ZXAYMode},\n     EmulationMode, RustzxSettings,\n };\n-\n use std::path::PathBuf;\n-\n use structopt::StructOpt;\n+use strum::{EnumString, EnumVariantNames, VariantNames};\n+\n+#[cfg(feature = \"sound-cpal\")]\n+const DEFAULT_SOUND_BACKEND_VALUE: &str = \"cpal\";\n+\n+#[cfg(not(feature = \"sound-cpal\"))]\n+const DEFAULT_SOUND_BACKEND_VALUE: &str = \"sdl\";\n+\n+#[derive(Clone, Copy, Debug, EnumString, EnumVariantNames)]\n+#[strum(serialize_all = \"snake_case\")]\n+pub enum SoundBackend {\n+    Sdl,\n+    #[cfg(feature = \"sound-cpal\")]\n+    Cpal,\n+}\n \n \/\/\/ Structure to handle all emulator runtime settings\n #[derive(StructOpt)]\n+#[structopt(about = env!(\"CARGO_PKG_DESCRIPTION\"))]\n+#[structopt(name = \"RustZX\")]\n pub struct Settings {\n     \/\/\/ Specify machine type for launch. Possible values:\n     \/\/\/   [`48k`, `48`] - Sinclair ZX Spectrum 48K\n@@ -56,13 +71,19 @@ pub struct Settings {\n     \/\/\/ Disable sound\n     #[structopt(long = \"nosound\")]\n     pub disable_sound: bool,\n-    \/\/\/ Set custom sound latency. Defaults to 1024 samples\n-    #[structopt(long, default_value = \"1024\", parse(try_from_str = sound_latency_from_str))]\n-    pub sound_latency: usize,\n-    \/\/\/ Set custom sound sample rate. Defaults to 44100 samples per second\n-    #[structopt(long, default_value = \"44100\", parse(try_from_str = sound_sample_rate_from_str))]\n-    pub sound_sample_rate: usize,\n-\n+    \/\/\/ Set custom sound latency\n+    #[structopt(long, parse(try_from_str = sound_latency_from_str))]\n+    pub sound_latency: Option<usize>,\n+    \/\/\/ Set custom sound sample rate\n+    #[structopt(long, parse(try_from_str = sound_sample_rate_from_str))]\n+    pub sound_sample_rate: Option<usize>,\n+    \/\/\/ Sound backend to use\n+    #[structopt(\n+        long,\n+        default_value = DEFAULT_SOUND_BACKEND_VALUE,\n+        possible_values = &SoundBackend::VARIANTS\n+    )]\n+    pub sound_backend: SoundBackend,\n     \/\/\/ Set path to custom rom file. in case of multipart ROMs for 128k, the first part file,\n     \/\/\/ extension of which should end with `.0`\n     #[structopt(long, conflicts_with = \"file-autodetect\")]\n@@ -151,7 +172,7 @@ fn sound_sample_rate_from_str(s: &str) -> Result<usize, anyhow::Error> {\n }\n \n impl Settings {\n-    pub fn to_rustzx_settings(&self) -> RustzxSettings {\n+    pub fn to_rustzx_settings(&self, sound_sample_rate: usize) -> RustzxSettings {\n         let ay_enabled = (matches!(self.machine, ZXMachine::Sinclair128K) || self.force_enable_ay)\n             && (!self.force_disable_ay);\n \n@@ -167,7 +188,7 @@ impl Settings {\n             sound_enabled: !self.disable_sound,\n             sound_volume: 100,\n             load_default_rom: self.rom.is_none(),\n-            sound_sample_rate: self.sound_sample_rate,\n+            sound_sample_rate,\n             autoload_enabled: !self.disable_autoload,\n         }\n     }\ndiff --git a\/rustzx\/src\/app\/sound\/mod.rs b\/rustzx\/src\/app\/sound\/mod.rs\nindex ad051dc..5ae6898 100644\n--- a\/rustzx\/src\/app\/sound\/mod.rs\n+++ b\/rustzx\/src\/app\/sound\/mod.rs\n@@ -1,13 +1,21 @@\n-\/\/! platform-independent traits. Submodules with backends will be selectable\n-\/\/! via cargo features in future\n+#[cfg(feature = \"sound-cpal\")]\n+mod sound_cpal;\n mod sound_sdl;\n use rustzx_core::zx::sound::sample::SoundSample;\n \n+#[cfg(feature = \"sound-cpal\")]\n+pub use sound_cpal::SoundCpal;\n pub use sound_sdl::SoundSdl;\n \n-\/\/ default sample type\n+pub const CHANNEL_COUNT: usize = 2;\n+pub const DEFAULT_SAMPLE_RATE: usize = 44100;\n+pub const DEFAULT_LATENCY: usize = 512;\n+\n pub type ZXSample = SoundSample<f32>;\n+\n pub trait SoundDevice {\n-    \/\/ blocking function to send new sample\n+    \/\/\/ Send new sample to the sound device\n     fn send_sample(&mut self, sample: ZXSample);\n+    \/\/\/ Return selected device sample rate\n+    fn sample_rate(&self) -> usize;\n }\ndiff --git a\/rustzx\/src\/app\/sound\/sound_cpal.rs b\/rustzx\/src\/app\/sound\/sound_cpal.rs\nnew file mode 100644\nindex 0000000..a8eb87e\n--- \/dev\/null\n+++ b\/rustzx\/src\/app\/sound\/sound_cpal.rs\n@@ -0,0 +1,107 @@\n+\/\/! Real Audio SDL backend\n+use crate::app::{\n+    settings::Settings,\n+    sound::{SoundDevice, ZXSample, CHANNEL_COUNT},\n+};\n+use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};\n+use std::sync::mpsc;\n+\n+pub struct SoundCpal {\n+    tx: mpsc::Sender<ZXSample>,\n+    sample_rate: usize,\n+    \/\/ Keep stream alive until Drop\n+    _stream: cpal::Stream,\n+}\n+\n+impl SoundCpal {\n+    \/\/\/ Constructs sound backend from settings\n+    pub fn new(settings: &Settings) -> anyhow::Result<SoundCpal> {\n+        let host = cpal::default_host();\n+        let device = host\n+            .default_output_device()\n+            .ok_or_else(|| anyhow::anyhow!(\"Failed to acquire cpal sound host\"))?;\n+\n+        let config = device\n+            .supported_output_configs()?\n+            .find(|c| {\n+                if let Some(sample_rate) = settings.sound_sample_rate {\n+                    if sample_rate < c.min_sample_rate().0 as usize\n+                        || sample_rate > c.max_sample_rate().0 as usize\n+                    {\n+                        return false;\n+                    }\n+                }\n+\n+                c.channels() == CHANNEL_COUNT as u16\n+            })\n+            .ok_or_else(|| {\n+                anyhow::anyhow!(\"Sound device does not support required configuration\")\n+            })?;\n+\n+        let config = if let Some(sample_rate) = settings.sound_sample_rate {\n+            config.with_sample_rate(cpal::SampleRate(sample_rate as u32))\n+        } else {\n+            config.with_max_sample_rate()\n+        };\n+\n+        let sample_rate = config.sample_rate().0 as usize;\n+\n+        let (tx, rx) = mpsc::channel();\n+\n+        let stream = match config.sample_format() {\n+            cpal::SampleFormat::I16 => create_stream::<i16>(&device, &config.into(), rx)?,\n+            cpal::SampleFormat::U16 => create_stream::<u16>(&device, &config.into(), rx)?,\n+            cpal::SampleFormat::F32 => create_stream::<f32>(&device, &config.into(), rx)?,\n+        };\n+\n+        Ok(SoundCpal {\n+            tx,\n+            sample_rate,\n+            _stream: stream,\n+        })\n+    }\n+}\n+\n+impl SoundDevice for SoundCpal {\n+    fn send_sample(&mut self, sample: ZXSample) {\n+        self.tx.send(sample).unwrap();\n+    }\n+\n+    fn sample_rate(&self) -> usize {\n+        self.sample_rate\n+    }\n+}\n+\n+fn create_stream<T>(\n+    device: &cpal::Device,\n+    config: &cpal::StreamConfig,\n+    samples_rx: mpsc::Receiver<ZXSample>,\n+) -> anyhow::Result<cpal::Stream>\n+where\n+    T: cpal::Sample,\n+{\n+    let channels = config.channels as usize;\n+\n+    let stream = device.build_output_stream(\n+        config,\n+        move |out: &mut [T], _: &cpal::OutputCallbackInfo| {\n+            for frame in out.chunks_mut(channels) {\n+                match samples_rx.try_recv().ok() {\n+                    Some(zx_sample) => {\n+                        let left: T = cpal::Sample::from(&zx_sample.left);\n+                        let right: T = cpal::Sample::from(&zx_sample.right);\n+                        frame[0] = left;\n+                        frame[1] = right;\n+                    }\n+                    None => {\n+                        frame[0] = cpal::Sample::from(&0f32);\n+                        frame[1] = cpal::Sample::from(&0f32);\n+                    }\n+                }\n+            }\n+        },\n+        |_| {},\n+    )?;\n+    stream.play()?;\n+    Ok(stream)\n+}\ndiff --git a\/rustzx\/src\/app\/sound\/sound_sdl.rs b\/rustzx\/src\/app\/sound\/sound_sdl.rs\nindex a7a6117..be26e57 100644\n--- a\/rustzx\/src\/app\/sound\/sound_sdl.rs\n+++ b\/rustzx\/src\/app\/sound\/sound_sdl.rs\n@@ -1,14 +1,16 @@\n-\/\/! Real Audio SDL backend\n-use super::{SoundDevice, ZXSample};\n-use crate::{app::settings::Settings, backends::SDL_CONTEXT};\n+use crate::{\n+    app::{\n+        settings::Settings,\n+        sound::{SoundDevice, ZXSample, CHANNEL_COUNT, DEFAULT_LATENCY, DEFAULT_SAMPLE_RATE},\n+    },\n+    backends::SDL_CONTEXT,\n+};\n use sdl2::audio::{AudioCallback, AudioDevice, AudioSpecDesired};\n-use std::sync::mpsc::{sync_channel, Receiver, SyncSender};\n-\n-const CHANNEL_COUNT: usize = 2;\n+use std::sync::mpsc;\n \n \/\/\/ Struct which used in SDL audio callback\n struct SdlCallback {\n-    samples: Receiver<ZXSample>,\n+    samples: mpsc::Receiver<ZXSample>,\n }\n \n impl AudioCallback for SdlCallback {\n@@ -18,9 +20,12 @@ impl AudioCallback for SdlCallback {\n     fn callback(&mut self, out: &mut [f32]) {\n         for chunk in out.chunks_mut(CHANNEL_COUNT) {\n             \/\/ recieve samples from channel\n-            if let Ok(sample) = self.samples.recv() {\n+            if let Ok(sample) = self.samples.try_recv() {\n                 chunk[0] = sample.left;\n                 chunk[1] = sample.right;\n+            } else {\n+                chunk[0] = 0f32;\n+                chunk[1] = 0f32;\n             }\n         }\n     }\n@@ -28,39 +33,43 @@ impl AudioCallback for SdlCallback {\n \n \/\/\/ Represents SDL audio backend\n pub struct SoundSdl {\n-    sender: SyncSender<ZXSample>,\n-    device: AudioDevice<SdlCallback>,\n+    sender: mpsc::Sender<ZXSample>,\n+    sample_rate: usize,\n+    _device: AudioDevice<SdlCallback>, \/\/ Should be alive until Drop invocation\n }\n \n impl SoundSdl {\n     \/\/\/ constructs sound backend from settings\n-    pub fn new(settings: &Settings) -> SoundSdl {\n-        \/\/ init backend\n+    pub fn new(settings: &Settings) -> anyhow::Result<SoundSdl> {\n         let mut audio_subsystem = None;\n         SDL_CONTEXT.with(|sdl| {\n             audio_subsystem = sdl.borrow_mut().audio().ok();\n         });\n-        if let Some(audio) = audio_subsystem {\n-            \/\/ prepare specs\n-            let desired_spec = AudioSpecDesired {\n-                freq: Some(settings.sound_sample_rate as i32),\n-                channels: Some(CHANNEL_COUNT as u8),\n-                samples: Some(settings.sound_latency as u16),\n-            };\n-            let (tx, rx) = sync_channel(settings.sound_latency as usize);\n-            let device_handle = audio\n-                .open_playback(None, &desired_spec, |_| SdlCallback { samples: rx })\n-                .expect(\"[ERROR Sdl audio device error, try --nosound]\");\n-            \/\/ run\n-            device_handle.resume();\n-            \/\/ save device and cahnnel handles\n-            SoundSdl {\n-                sender: tx,\n-                device: device_handle,\n-            }\n-        } else {\n-            panic!(\"[ERROR] Sdl audio error, try --nosound\");\n-        }\n+        let audio = audio_subsystem\n+            .ok_or_else(|| anyhow::anyhow!(\"Failed to initialize SDL audio backend\"))?;\n+\n+        \/\/ Basically, SDL shits its pants if desired sound sample rate is not specified\n+        let sample_rate = settings.sound_sample_rate.unwrap_or(DEFAULT_SAMPLE_RATE);\n+\n+        \/\/ SDL sets awfully big latency by default\n+        let latency = settings.sound_latency.unwrap_or(DEFAULT_LATENCY);\n+\n+        let desired_spec = AudioSpecDesired {\n+            freq: Some(sample_rate as i32),\n+            channels: Some(CHANNEL_COUNT as u8),\n+            samples: Some(latency as u16),\n+        };\n+        let (tx, rx) = mpsc::channel();\n+        let device_handle = audio\n+            .open_playback(None, &desired_spec, |_| SdlCallback { samples: rx })\n+            .map_err(|e| anyhow::anyhow!(\"Failed to start SDL sound stream: {}\", e))?;\n+        device_handle.resume();\n+\n+        Ok(SoundSdl {\n+            sender: tx,\n+            sample_rate,\n+            _device: device_handle,\n+        })\n     }\n }\n \n@@ -68,4 +77,8 @@ impl SoundDevice for SoundSdl {\n     fn send_sample(&mut self, sample: ZXSample) {\n         self.sender.send(sample).unwrap();\n     }\n+\n+    fn sample_rate(&self) -> usize {\n+        self.sample_rate\n+    }\n }\ndiff --git a\/rustzx\/src\/backends\/mod.rs b\/rustzx\/src\/backends\/mod.rs\nindex 9615a40..188ac36 100644\n--- a\/rustzx\/src\/backends\/mod.rs\n+++ b\/rustzx\/src\/backends\/mod.rs\n@@ -3,4 +3,4 @@ use sdl2::{self, Sdl};\n use std::cell::RefCell;\n \n thread_local! (pub static SDL_CONTEXT: RefCell<Sdl> = RefCell::new(\n-        sdl2::init().expect(\"[ERROR] Sdl init error, try --nosound\")));\n+        sdl2::init().expect(\"SDL init failed\")));\ndiff --git a\/rustzx\/src\/host\/mod.rs b\/rustzx\/src\/host\/mod.rs\nindex fdaa87d..3bd936a 100644\n--- a\/rustzx\/src\/host\/mod.rs\n+++ b\/rustzx\/src\/host\/mod.rs\n@@ -1,14 +1,17 @@\n mod frame_buffer;\n-mod io;\n \n use anyhow::{anyhow, bail, Context};\n use frame_buffer::{FrameBufferContext, RgbaFrameBuffer};\n-pub use io::FileAsset;\n use rustzx_core::{\n-    host::{FrameBuffer, Host, HostContext, RomFormat, RomSet, Screen, Snapshot, Tape},\n+    host::{\n+        FrameBuffer, Host, HostContext, RomFormat, RomSet, Screen, Snapshot, StubIoExtender, Tape,\n+    },\n     zx::machine::ZXMachine,\n };\n-use rustzx_utils::stopwatch::InstantStopwatch;\n+use rustzx_utils::{\n+    io::{DynamicAsset, FileAsset, GzipAsset},\n+    stopwatch::InstantStopwatch,\n+};\n use std::{collections::VecDeque, fs::File, path::Path};\n \n const SUPPORTED_SNAPSHOT_FORMATS: [&str; 1] = [\"sna\"];\n@@ -21,7 +24,8 @@ impl Host for AppHost {\n     type Context = AppHostContext;\n     type EmulationStopwatch = InstantStopwatch;\n     type FrameBuffer = RgbaFrameBuffer;\n-    type TapeAsset = FileAsset;\n+    type IoExtender = StubIoExtender;\n+    type TapeAsset = DynamicAsset;\n }\n \n pub struct AppHostContext;\n@@ -33,11 +37,11 @@ impl HostContext<AppHost> for AppHostContext {\n }\n \n pub struct FileRomSet {\n-    pages: VecDeque<FileAsset>,\n+    pages: VecDeque<DynamicAsset>,\n }\n \n impl RomSet for FileRomSet {\n-    type Asset = FileAsset;\n+    type Asset = DynamicAsset;\n \n     fn format(&self) -> RomFormat {\n         RomFormat::Binary16KPages\n@@ -54,7 +58,26 @@ pub enum DetectedFileKind {\n     Screen,\n }\n \n-pub fn load_tape(path: &Path) -> anyhow::Result<Tape<FileAsset>> {\n+pub enum DetectedContainerKind {\n+    None,\n+    Gzip,\n+}\n+\n+pub fn load_asset(path: &Path) -> anyhow::Result<DynamicAsset> {\n+    let container_kind = detect_container(path);\n+\n+    let file = File::open(path).with_context(|| \"Failed to open tape file\")?;\n+\n+    match container_kind {\n+        DetectedContainerKind::None => Ok(FileAsset::from(file).into()),\n+        DetectedContainerKind::Gzip => {\n+            let gzip = GzipAsset::new(file)?;\n+            Ok(gzip.into())\n+        }\n+    }\n+}\n+\n+pub fn load_tape(path: &Path) -> anyhow::Result<Tape<DynamicAsset>> {\n     if !file_extension_matches_one_of(path, &SUPPORTED_TAPE_FORMATS) {\n         bail!(\"Invalid tape format\");\n     }\n@@ -63,12 +86,12 @@ pub fn load_tape(path: &Path) -> anyhow::Result<Tape<FileAsset>> {\n         bail!(\"Provided tape file does not exist\");\n     }\n \n-    File::open(path)\n-        .with_context(|| \"Failed to open tape file\")\n-        .map(|file| Tape::Tap(file.into()))\n+    load_asset(path)\n+        .map(Tape::Tap)\n+        .with_context(|| \"Failed to load tape file\")\n }\n \n-pub fn load_snapshot(path: &Path) -> anyhow::Result<Snapshot<FileAsset>> {\n+pub fn load_snapshot(path: &Path) -> anyhow::Result<Snapshot<DynamicAsset>> {\n     if !file_extension_matches_one_of(path, &SUPPORTED_SNAPSHOT_FORMATS) {\n         bail!(\"Invalid snapshot format\");\n     }\n@@ -77,12 +100,12 @@ pub fn load_snapshot(path: &Path) -> anyhow::Result<Snapshot<FileAsset>> {\n         bail!(\"Provided snapshot file does not exist\");\n     }\n \n-    File::open(path)\n-        .with_context(|| \"Failed to open snapshot file\")\n-        .map(|file| Snapshot::Sna(file.into()))\n+    load_asset(path)\n+        .map(Snapshot::Sna)\n+        .with_context(|| \"Failed to load snapshot file\")\n }\n \n-pub fn load_screen(path: &Path) -> anyhow::Result<Screen<FileAsset>> {\n+pub fn load_screen(path: &Path) -> anyhow::Result<Screen<DynamicAsset>> {\n     if !file_extension_matches_one_of(path, &SUPPORTED_SCREEN_FORMATS) {\n         bail!(\"Invalid screen format\");\n     }\n@@ -91,15 +114,13 @@ pub fn load_screen(path: &Path) -> anyhow::Result<Screen<FileAsset>> {\n         bail!(\"Provided screen file does not exist\");\n     }\n \n-    File::open(path)\n-        .with_context(|| \"Failed to open screen file\")\n-        .map(|file| Screen::Scr(file.into()))\n+    load_asset(path)\n+        .map(Screen::Scr)\n+        .with_context(|| \"Failed to load screen file\")\n }\n \n-fn load_rom_asset(path: &Path) -> anyhow::Result<FileAsset> {\n-    File::open(path)\n-        .with_context(|| \"Failed to load rom asset\")\n-        .map(|file| file.into())\n+fn load_rom_asset(path: &Path) -> anyhow::Result<DynamicAsset> {\n+    load_asset(path).with_context(|| \"Failed to load rom asset\")\n }\n \n pub fn load_rom(path: &Path, machine: ZXMachine) -> anyhow::Result<FileRomSet> {\n@@ -123,7 +144,15 @@ pub fn load_rom(path: &Path, machine: ZXMachine) -> anyhow::Result<FileRomSet> {\n             if !rom0_path.exists() {\n                 bail!(\"Provided 128K ROM0 file does not exist\");\n             }\n-            let rom1_path = rom0_path.to_owned().with_extension(\"1\");\n+            let rom1_path = if is_container(rom0_path) {\n+                let container_ext = rom0_path.extension().unwrap().to_string_lossy();\n+                let mut new_path = rom0_path.to_owned();\n+                new_path.set_extension(\"\"); \/\/ removes just container extension\n+                new_path.with_extension(format!(\"1.{}\", container_ext))\n+            } else {\n+                rom0_path.to_owned().with_extension(\"1\")\n+            };\n+\n             if !rom1_path.exists() {\n                 bail!(\"Provided 128K ROM1 file does not exist\");\n             }\n@@ -152,7 +181,31 @@ pub fn detect_file_type(path: &Path) -> anyhow::Result<DetectedFileKind> {\n     }\n }\n \n+fn is_container(path: &Path) -> bool {\n+    !matches!(detect_container(path), DetectedContainerKind::None)\n+}\n+\n+fn detect_container(path: &Path) -> DetectedContainerKind {\n+    let ext = path\n+        .extension()\n+        .unwrap_or_default()\n+        .to_str()\n+        .unwrap_or_default()\n+        .to_lowercase();\n+\n+    match ext.as_str() {\n+        \"gz\" => DetectedContainerKind::Gzip,\n+        _ => DetectedContainerKind::None,\n+    }\n+}\n+\n fn file_extension_matches(path: &Path, expected: &str) -> bool {\n+    let mut path = path.to_owned();\n+    \/\/ Ignore outer container extension during comparison\n+    if is_container(&path) {\n+        path.set_extension(\"\");\n+    }\n+\n     let actual = path\n         .extension()\n         .unwrap_or_default()\n@@ -180,6 +233,8 @@ mod tests {\n         assert!(file_extension_matches(&Path::new(\"test.tap\"), \"tap\"));\n         assert!(file_extension_matches(&Path::new(\"test.TAP\"), \"tap\"));\n         assert!(file_extension_matches(&Path::new(\"test.tAp\"), \"tap\"));\n+        assert!(file_extension_matches(&Path::new(\"test.tap.gz\"), \"tap\"));\n+        assert!(file_extension_matches(&Path::new(\"test.tap.gZ\"), \"tap\"));\n     }\n \n     #[test]\ndiff --git a\/rustzx\/src\/main.rs b\/rustzx\/src\/main.rs\nindex 45d98da..b1b7f94 100644\n--- a\/rustzx\/src\/main.rs\n+++ b\/rustzx\/src\/main.rs\n@@ -1,5 +1,3 @@\n-#![allow(dead_code)]\n-\n mod app;\n mod backends;\n mod host;\n@@ -13,7 +11,9 @@ fn main() {\n     let settings = Settings::from_args();\n     let result = RustzxApp::from_config(settings)\n         .and_then(|mut emulator| emulator.start())\n-        .map_err(|e| log::error!(\"ERROR: {}\", e));\n+        .map_err(|e| {\n+            log::error!(\"ERROR: {:#}\", e);\n+        });\n \n     if result.is_err() {\n         std::process::exit(1);\ndiff --git a\/vtx\/Cargo.toml b\/vtx\/Cargo.toml\nindex 1387132..8f3d099 100644\n--- a\/vtx\/Cargo.toml\n+++ b\/vtx\/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"vtx\"\n-version = \"0.1.2\"\n+version = \"0.15.0\"\n description = \"VTX sound format parsing and playback library\"\n authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n edition = \"2018\"\n@@ -10,12 +10,12 @@ repository = \"https:\/\/github.com\/pacmancoder\/rustzx\"\n \n [dependencies]\n delharc = { version = \"0.3\", default-features = false }\n-thiserror = \"1\"\n-byteorder = \"1\"\n+thiserror = \"1.0\"\n+byteorder = \"1.4\"\n num-traits = { version = \"0.2\", default-features = false }\n num-derive = \"0.3\"\n-aym = { version = \"0.1.1\", path = \"..\/aym\" }\n+aym = { version = \"0.15\", path = \"..\/aym\" }\n \n [dev-dependencies]\n-expect-test = \"1\"\n+expect-test = \"1.1\"\n sha2 = \"0.9\"\ndiff --git a\/vtx\/vtx-bin\/Cargo.toml b\/vtx\/vtx-bin\/Cargo.toml\nindex 4326207..fc0e236 100644\n--- a\/vtx\/vtx-bin\/Cargo.toml\n+++ b\/vtx\/vtx-bin\/Cargo.toml\n@@ -1,7 +1,7 @@\n [package]\n name = \"vtx-bin\"\n description = \"VTX sound format toolbox\"\n-version = \"0.1.2\"\n+version = \"0.15.0\"\n authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n edition = \"2018\"\n license = \"MIT\"\n@@ -13,7 +13,7 @@ name = \"vtx\"\n path = \"src\/main.rs\"\n \n [dependencies]\n-vtx = { version = \"0.1\", path = \"..\" }\n+vtx = { version = \"0.15\", path = \"..\" }\n structopt = \"0.3\"\n-wav = \"1\"\n-anyhow = \"1\"\n+wav = \"1.0\"\n+anyhow = \"1.0\"\n","test_patch":"diff --git a\/.github\/workflows\/zexall.yml b\/.github\/workflows\/test-rustzx-z80.yml\nsimilarity index 70%\nrename from .github\/workflows\/zexall.yml\nrename to .github\/workflows\/test-rustzx-z80.yml\nindex 0afb40e..a691683 100644\n--- a\/.github\/workflows\/zexall.yml\n+++ b\/.github\/workflows\/test-rustzx-z80.yml\n@@ -1,4 +1,4 @@\n-name: Zexall Z80 test suite\n+name: rustzx-z80 tests\n \n on:\n   push:\n@@ -18,8 +18,23 @@ env:\n # free tier, overall zexall test suite execution time will\n # be only as long as alu8r test duration (longest test)\n jobs:\n-  batch1:\n-    name: \"Batch 1\"\n+  unit_tests:\n+    name: \"Unit tests\"\n+    runs-on: ubuntu-20.04\n+    steps:\n+      - uses: actions\/checkout@v2\n+      - uses: actions-rs\/toolchain@v1\n+        with:\n+          profile: minimal\n+          toolchain: stable\n+          override: true\n+      - name: Test\n+        uses: actions-rs\/cargo@v1\n+        with:\n+          command: test\n+          args: -p rustzx-z80\n+  zexall_batch_1:\n+    name: \"Zexall tests batch 1\"\n     runs-on: ubuntu-20.04\n     steps:\n       - uses: actions\/checkout@v2\n@@ -33,8 +48,8 @@ jobs:\n         with:\n           command: test\n           args: -p rustzx-z80 -- --ignored zexall_alu8r\n-  batch2:\n-    name: \"Batch 2\"\n+  zexall_batch_2:\n+    name: \"Zexall tests batch 2\"\n     runs-on: ubuntu-20.04\n     steps:\n       - uses: actions\/checkout@v2\ndiff --git a\/rustzx-core\/test_data\/.gitignore b\/rustzx-core\/test_data\/.gitignore\ndeleted file mode 100644\nindex 01eef47..0000000\n--- a\/rustzx-core\/test_data\/.gitignore\n+++ \/dev\/null\n@@ -1,2 +0,0 @@\n-# Do not include temporary tests output in the repo\n-actual\/**\ndiff --git a\/rustzx-core\/test_data\/asset\/make_in_docker.cmd b\/rustzx-core\/test_data\/asset\/make_in_docker.cmd\ndeleted file mode 100644\nindex b787e67..0000000\n--- a\/rustzx-core\/test_data\/asset\/make_in_docker.cmd\n+++ \/dev\/null\n@@ -1,1 +0,0 @@\n-docker run -v \"%cd%:\/src\/\" -it z88dk\/z88dk sh \/src\/make.sh\ndiff --git a\/rustzx-core\/test_data\/asset\/make_in_docker.sh b\/rustzx-core\/test_data\/asset\/make_in_docker.sh\ndeleted file mode 100644\nindex 5cd7265..0000000\n--- a\/rustzx-core\/test_data\/asset\/make_in_docker.sh\n+++ \/dev\/null\n@@ -1,1 +0,0 @@\n-docker run -v \"${PWD}:\/src\/\" -it z88dk\/z88dk sh \/src\/make.sh\ndiff --git a\/rustzx-core\/test_data\/asset\/simple_tape.tap b\/rustzx-core\/test_data\/asset\/simple_tape.tap\ndeleted file mode 100644\nindex 7e7ff65..0000000\nBinary files a\/rustzx-core\/test_data\/asset\/simple_tape.tap and \/dev\/null differ\ndiff --git a\/rustzx-core\/test_data\/expected\/fastload_test\/border_1.png b\/rustzx-core\/test_data\/expected\/fastload_test\/border_1.png\ndeleted file mode 100644\nindex 1bacd7e..0000000\nBinary files a\/rustzx-core\/test_data\/expected\/fastload_test\/border_1.png and \/dev\/null differ\ndiff --git a\/rustzx-core\/test_data\/expected\/fastload_test\/screen_1.png b\/rustzx-core\/test_data\/expected\/fastload_test\/screen_1.png\ndeleted file mode 100644\nindex a9318a2..0000000\nBinary files a\/rustzx-core\/test_data\/expected\/fastload_test\/screen_1.png and \/dev\/null differ\ndiff --git a\/rustzx-core\/test_data\/expected\/fastload_test\/screen_2.png b\/rustzx-core\/test_data\/expected\/fastload_test\/screen_2.png\ndeleted file mode 100644\nindex 4f62802..0000000\nBinary files a\/rustzx-core\/test_data\/expected\/fastload_test\/screen_2.png and \/dev\/null differ\ndiff --git a\/rustzx-core\/tests\/integration\/framework.rs b\/rustzx-core\/tests\/integration\/framework.rs\ndeleted file mode 100644\nindex ffbce97..0000000\n--- a\/rustzx-core\/tests\/integration\/framework.rs\n+++ \/dev\/null\n@@ -1,218 +0,0 @@\n-use std::{\n-    path::{Path, PathBuf},\n-    time::Duration,\n-};\n-\n-use rustzx_core::{\n-    host::{BufferCursor, FrameBuffer, FrameBufferSource, Host, HostContext, Tape},\n-    zx::{\n-        machine::ZXMachine,\n-        sound::ay::ZXAYMode,\n-        video::colors::{ZXBrightness, ZXColor},\n-    },\n-    EmulationMode, Emulator, RustzxSettings,\n-};\n-use rustzx_utils::{palette::rgba::ORIGINAL as DEFAULT_PALETTE, stopwatch::InstantStopwatch};\n-\n-fn make_png_palette() -> Vec<u8> {\n-    DEFAULT_PALETTE\n-        .iter()\n-        .fold(Vec::with_capacity(4 * 16), |mut buffer, color| {\n-            buffer.extend_from_slice(&color[0..3]);\n-            buffer\n-        })\n-}\n-\n-\/\/ TODO(#83): Add tests for gigascreen\n-\n-struct FrameContent {\n-    buffer: Vec<u8>,\n-    width: usize,\n-    height: usize,\n-}\n-\n-impl FrameBuffer for FrameContent {\n-    type Context = TesterFrameBufferContext;\n-\n-    fn new(\n-        width: usize,\n-        height: usize,\n-        _source: FrameBufferSource,\n-        context: Self::Context,\n-    ) -> Self {\n-        if context.use_gigascreen {\n-            unimplemented!(\"Gigascreen tests are not yet implemented\");\n-        } else {\n-            let buffer_size = (width * height) \/ 2;\n-            Self {\n-                buffer: vec![0u8; buffer_size],\n-                width,\n-                height,\n-            }\n-        }\n-    }\n-\n-    fn set_color(&mut self, x: usize, y: usize, color: ZXColor, brightness: ZXBrightness) {\n-        let pixel_index = x + y * self.width;\n-        let buffer_index = pixel_index \/ 2;\n-        \/\/ 0xF0 mask for even pixels, 0x0F mask for odd pixels\n-        let mask = 0xF0 >> (pixel_index % 2) * 4;\n-        let indexed_color = (color as u8) + (brightness as u8) * 8;\n-        \/\/ 0x0A => 0xAA, 0x03  => 0x33, etc.\n-        let color_overlay_byte = indexed_color | (indexed_color << 4);\n-        \/\/ clear previous color nibble and set to new value\n-        self.buffer[buffer_index] =\n-            (self.buffer[buffer_index] & (!mask)) | (color_overlay_byte & mask)\n-    }\n-}\n-\n-impl FrameContent {\n-    pub fn to_png(&self) -> Vec<u8> {\n-        let mut out = vec![];\n-\n-        {\n-            let mut encoder = png::Encoder::new(&mut out, self.width as u32, self.height as u32);\n-            encoder.set_depth(png::BitDepth::Four);\n-            encoder.set_color(png::ColorType::Indexed);\n-            encoder.set_palette(make_png_palette());\n-            let mut writer = encoder.write_header().expect(\"Failed to write PNG header\");\n-            writer\n-                .write_image_data(&self.buffer)\n-                .expect(\"Failed to write PNG data\");\n-        }\n-\n-        out\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct TesterFrameBufferContext {\n-    use_gigascreen: bool,\n-}\n-\n-#[derive(Default)]\n-struct TesterContext;\n-\n-impl HostContext<TesterHost> for TesterContext {\n-    fn frame_buffer_context(&self) -> <FrameContent as FrameBuffer>::Context {\n-        TesterFrameBufferContext {\n-            use_gigascreen: false,\n-        }\n-    }\n-}\n-\n-struct TesterHost;\n-\n-impl Host for TesterHost {\n-    type Context = TesterContext;\n-    type EmulationStopwatch = InstantStopwatch;\n-    type FrameBuffer = FrameContent;\n-    type TapeAsset = BufferCursor<Vec<u8>>;\n-}\n-\n-pub struct RustZXTester {\n-    emulator: Emulator<TesterHost>,\n-    test_name: String,\n-}\n-\n-pub mod presets {\n-    use super::*;\n-\n-    pub fn settings_48k_nosound() -> RustzxSettings {\n-        RustzxSettings {\n-            machine: ZXMachine::Sinclair48K,\n-            emulation_mode: EmulationMode::FrameCount(1),\n-            tape_fastload_enabled: true,\n-            kempston_enabled: true,\n-            mouse_enabled: true,\n-            ay_mode: ZXAYMode::ABC,\n-            ay_enabled: false,\n-            beeper_enabled: false,\n-            sound_enabled: false,\n-            sound_volume: 100,\n-            sound_sample_rate: 44100,\n-            load_default_rom: true,\n-            autoload_enabled: true,\n-        }\n-    }\n-}\n-\n-impl RustZXTester {\n-    pub fn new(test_name: &str, settings: RustzxSettings) -> Self {\n-        let emulator = Emulator::new(settings, TesterContext::default())\n-            .expect(\"Failed to initialize emulator\");\n-\n-        Self {\n-            emulator,\n-            test_name: test_name.to_owned(),\n-        }\n-    }\n-\n-    fn assets_folder(&self) -> PathBuf {\n-        Path::new(\"test_data\/asset\").to_owned()\n-    }\n-\n-    fn expected_data_folder(&self) -> PathBuf {\n-        Path::new(\"test_data\/expected\").join(&self.test_name)\n-    }\n-\n-    fn actual_data_folder(&self) -> PathBuf {\n-        Path::new(\"test_data\/actual\").join(&self.test_name)\n-    }\n-\n-    pub fn load_tape(&mut self, name: impl AsRef<Path>) {\n-        let path = self.assets_folder().join(name);\n-        let content = std::fs::read(path).expect(\"Failed to read test tape file\");\n-        self.emulator\n-            .load_tape(Tape::Tap(BufferCursor::new(content)))\n-            .expect(\"Failed to load test tape\");\n-    }\n-\n-    fn get_screen(&self) -> Vec<u8> {\n-        self.emulator.screen_buffer().to_png()\n-    }\n-\n-    fn get_border(&self) -> Vec<u8> {\n-        self.emulator.border_buffer().to_png()\n-    }\n-\n-    pub fn emulate_for(&mut self, duration: Duration) {\n-        const FRAME_HOST_DURATION_LIMIT: Duration = Duration::from_millis(100);\n-        const FRAME_EMULATED_DURATION: Duration = Duration::from_millis(20);\n-\n-        let mut emulated_duration = Duration::from_secs(0);\n-        while emulated_duration < duration {\n-            self.emulator\n-                .emulate_frames(FRAME_HOST_DURATION_LIMIT)\n-                .expect(\"Emulation failed\");\n-            emulated_duration += FRAME_EMULATED_DURATION;\n-        }\n-    }\n-\n-    pub fn compare_buffer_with_file(&self, actual: Vec<u8>, name: impl AsRef<Path>) {\n-        let path = name.as_ref();\n-        let expected = std::fs::read(self.expected_data_folder().join(&path)).unwrap_or_default();\n-\n-        if actual != expected {\n-            eprintln!(\"Integration test failed, writing actual data...\");\n-            \/\/ Wirte actual output for further investigation\n-            std::fs::create_dir_all(self.actual_data_folder())\n-                .expect(\"Failed to create expected data dir\");\n-            std::fs::write(self.actual_data_folder().join(path), actual)\n-                .expect(\"Failed to write actual data\");\n-\n-            panic!(\n-                \"Comparison with {} failed; Actual data has been saved for further investigation\",\n-                path.display()\n-            );\n-        }\n-    }\n-\n-    pub fn expect_screen(&self, name: impl AsRef<Path>) {\n-        self.compare_buffer_with_file(self.get_screen(), name);\n-    }\n-\n-    pub fn expect_border(&self, name: impl AsRef<Path>) {\n-        self.compare_buffer_with_file(self.get_border(), name);\n-    }\n-}\ndiff --git a\/rustzx-core\/tests\/integration\/main.rs b\/rustzx-core\/tests\/integration\/main.rs\ndeleted file mode 100644\nindex 7e10a4d..0000000\n--- a\/rustzx-core\/tests\/integration\/main.rs\n+++ \/dev\/null\n@@ -1,5 +0,0 @@\n-mod framework;\n-\n-mod tape;\n-\n-extern crate std;\ndiff --git a\/rustzx-core\/tests\/integration\/tape.rs b\/rustzx-core\/tests\/integration\/tape.rs\ndeleted file mode 100644\nindex 3f21dfd..0000000\n--- a\/rustzx-core\/tests\/integration\/tape.rs\n+++ \/dev\/null\n@@ -1,13 +0,0 @@\n-use crate::framework::{presets, RustZXTester};\n-use std::time::Duration;\n-\n-#[test]\n-fn fastload_test() {\n-    let mut tester = RustZXTester::new(\"fastload_test\", presets::settings_48k_nosound());\n-    tester.load_tape(\"simple_tape.tap\");\n-    tester.emulate_for(Duration::from_millis(45));\n-    tester.expect_screen(\"screen_1.png\");\n-    tester.emulate_for(Duration::from_millis(10));\n-    tester.expect_screen(\"screen_2.png\");\n-    tester.expect_border(\"border_1.png\");\n-}\ndiff --git a\/rustzx-test\/Cargo.toml b\/rustzx-test\/Cargo.toml\nnew file mode 100644\nindex 0000000..17a81e8\n--- \/dev\/null\n+++ b\/rustzx-test\/Cargo.toml\n@@ -0,0 +1,17 @@\n+[package]\n+name = \"rustzx-test\"\n+version = \"0.15.0\"\n+edition = \"2018\"\n+publish = false\n+description = \"RustZX emulator integration tests\"\n+\n+[dependencies]\n+anyhow = \"1.0\"\n+base64 = \"0.13\"\n+expect-test = \"1.1\"\n+nanoid = \"0.4\"\n+png = \"0.16\"\n+rustzx-core = { version = \"0.15\", path = \"..\/rustzx-core\", features = [\"full\"] }\n+rustzx-utils = { version = \"0.15\", path =  \"..\/rustzx-utils\", features = [\"std\"] }\n+sha2 = \"0.9\"\n+wav = \"1.0\"\ndiff --git a\/rustzx-test\/src\/bin\/build-assets.rs b\/rustzx-test\/src\/bin\/build-assets.rs\nnew file mode 100644\nindex 0000000..9afbec5\n--- \/dev\/null\n+++ b\/rustzx-test\/src\/bin\/build-assets.rs\n@@ -0,0 +1,216 @@\n+use anyhow::Context;\n+use std::{\n+    path::{Path, PathBuf},\n+    process::Command,\n+};\n+\n+const DOCKER_IMAGE_REPO: &str = \"https:\/\/github.com\/z88dk\/z88dk.git\";\n+const DOCKER_IMAGE_COMMIT: &str = \"d61f6bb46ec15775cccf543f5941b6a2d6864ecf\";\n+const DOCKER_IMAGE_NAME: &str = \"rustzx\/z88dk\";\n+const DOCKER_IMAGE_FILE: &str = \"z88dk.Dockerfile\";\n+\n+const HEX_ALPHABET: [char; 16] = [\n+    '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', 'c', 'd', 'e', 'f',\n+];\n+const SHORTENED_COMMIT_LENGTH: usize = 7;\n+\n+fn image_tagged_name(name: impl AsRef<str>, tag: impl Into<String>) -> String {\n+    let mut tag = tag.into();\n+    tag.truncate(SHORTENED_COMMIT_LENGTH);\n+\n+    format!(\"{}:{}\", name.as_ref(), tag)\n+}\n+\n+\/\/ Running docker container OS may differ from the host, therefore\n+\/\/ we can't use Path\/PathBuf\n+struct ForeignOsPath(String);\n+\n+impl ForeignOsPath {\n+    fn new(path: impl Into<String>) -> Self {\n+        Self(path.into())\n+    }\n+}\n+\n+struct DockerMountPoint {\n+    dir: PathBuf,\n+    mount: ForeignOsPath,\n+}\n+\n+enum DockerAction {\n+    ShellScript { path: ForeignOsPath },\n+}\n+\n+struct DockerContainer {\n+    image: String,\n+    name: Option<String>,\n+    mount_points: Vec<DockerMountPoint>,\n+    remove_after_run: bool,\n+    action: Option<DockerAction>,\n+}\n+\n+impl DockerContainer {\n+    pub fn from_image(image: impl Into<String>) -> Self {\n+        Self {\n+            image: image.into(),\n+            remove_after_run: false,\n+            mount_points: vec![],\n+            name: None,\n+            action: None,\n+        }\n+    }\n+\n+    pub fn name(mut self, name: impl Into<String>) -> Self {\n+        self.name.replace(name.into());\n+        self\n+    }\n+\n+    pub fn mount(mut self, mount_point: DockerMountPoint) -> Self {\n+        self.mount_points.push(mount_point);\n+        self\n+    }\n+\n+    pub fn remove_after_run(mut self) -> Self {\n+        self.remove_after_run = true;\n+        self\n+    }\n+\n+    pub fn startup_script(mut self, path: ForeignOsPath) -> Self {\n+        self.action.replace(DockerAction::ShellScript { path });\n+        self\n+    }\n+\n+    pub fn run(self) -> Result<(), anyhow::Error> {\n+        let mut cmd = Command::new(\"docker\");\n+        cmd.arg(\"run\");\n+        if let Some(name) = self.name {\n+            cmd.args(&[\"--name\", &name]);\n+        }\n+        for mount_point in self.mount_points {\n+            cmd.args(&[\n+                \"-v\",\n+                &format!(\"{}:{}\", mount_point.dir.display(), mount_point.mount.0),\n+            ]);\n+        }\n+        if self.remove_after_run {\n+            cmd.arg(\"--rm\");\n+        }\n+        if matches!(&self.action, Some(DockerAction::ShellScript { .. })) {\n+            cmd.arg(\"-it\");\n+        }\n+        cmd.arg(self.image);\n+        if let Some(action) = self.action {\n+            match action {\n+                DockerAction::ShellScript { path } => {\n+                    cmd.args(&[\"sh\", &path.0]);\n+                }\n+            }\n+        }\n+\n+        execute_command_transparent(cmd)?;\n+        Ok(())\n+    }\n+}\n+\n+struct DockerImage {\n+    url: String,\n+    name: Option<String>,\n+    dockerfile: Option<String>,\n+}\n+\n+impl DockerImage {\n+    pub fn present_on_machine(image_name: &str) -> Result<bool, anyhow::Error> {\n+        let mut cmd = Command::new(\"docker\");\n+        cmd.args([\"images\", \"-q\", image_name]);\n+\n+        let output = cmd\n+            .output()\n+            .with_context(|| \"Failed to query docker images\")\n+            .and_then(|out| {\n+                String::from_utf8(out.stdout).with_context(|| \"Failed to parse docker stdout\")\n+            })?;\n+\n+        Ok(!output.is_empty())\n+    }\n+\n+    pub fn from_git(repo: impl AsRef<str>, commit: impl AsRef<str>) -> Self {\n+        let url = format!(\"{}#{}\", repo.as_ref(), commit.as_ref());\n+\n+        Self {\n+            url,\n+            name: None,\n+            dockerfile: None,\n+        }\n+    }\n+\n+    pub fn with_name(mut self, name: impl Into<String>) -> Self {\n+        self.name.replace(name.into());\n+        self\n+    }\n+\n+    pub fn with_dockerfile(mut self, dockerfile: impl Into<String>) -> Self {\n+        self.dockerfile.replace(dockerfile.into());\n+        self\n+    }\n+\n+    pub fn build(self) -> anyhow::Result<()> {\n+        let mut cmd = Command::new(\"docker\");\n+        cmd.arg(\"build\");\n+        if let Some(dockerfile) = self.dockerfile {\n+            cmd.args([\"-f\", &dockerfile]);\n+        }\n+        if let Some(name) = self.name {\n+            cmd.args([\"-t\", &name]);\n+        }\n+        cmd.arg(self.url);\n+        cmd.spawn()?.wait()?;\n+        execute_command_transparent(cmd)?;\n+        Ok(())\n+    }\n+}\n+\n+fn to_container_name(prefix: &str) -> String {\n+    format!(\"{}-{}\", prefix, nanoid::nanoid!(8, &HEX_ALPHABET))\n+}\n+\n+fn execute_command_transparent(mut cmd: Command) -> anyhow::Result<()> {\n+    println!(\"Running command with args: {:#?}\", cmd);\n+\n+    let status = cmd.spawn()?.wait()?;\n+\n+    if !status.success() {\n+        anyhow::anyhow!(\n+            \"Command execution failed with code {}\",\n+            status.code().unwrap_or(1)\n+        );\n+    }\n+\n+    Ok(())\n+}\n+\n+fn main() -> anyhow::Result<()> {\n+    if !DockerImage::present_on_machine(DOCKER_IMAGE_NAME)\n+        .with_context(|| \"Failed to check for docker image presence\")?\n+    {\n+        DockerImage::from_git(DOCKER_IMAGE_REPO, DOCKER_IMAGE_COMMIT)\n+            .with_name(image_tagged_name(DOCKER_IMAGE_NAME, DOCKER_IMAGE_COMMIT))\n+            .with_dockerfile(DOCKER_IMAGE_FILE)\n+            .build()\n+            .with_context(|| \"Failed to build docker image\")?;\n+    }\n+\n+    let mut assets_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n+    assets_dir.push(Path::new(\"test_data\"));\n+\n+    DockerContainer::from_image(image_tagged_name(DOCKER_IMAGE_NAME, DOCKER_IMAGE_COMMIT))\n+        .name(to_container_name(\"rustzx-assets\"))\n+        .mount(DockerMountPoint {\n+            dir: assets_dir,\n+            mount: ForeignOsPath::new(\"\/src\/\"),\n+        })\n+        .remove_after_run()\n+        .startup_script(ForeignOsPath::new(\"\/src\/make.sh\"))\n+        .run()\n+        .expect(\"Failed to build assets\");\n+\n+    Ok(())\n+}\ndiff --git a\/rustzx-test\/src\/framework.rs b\/rustzx-test\/src\/framework.rs\nnew file mode 100644\nindex 0000000..4e9114c\n--- \/dev\/null\n+++ b\/rustzx-test\/src\/framework.rs\n@@ -0,0 +1,510 @@\n+use expect_test::Expect;\n+use rustzx_core::{\n+    host::{\n+        BufferCursor, FrameBuffer, FrameBufferSource, Host, HostContext, IoExtender, RomFormat,\n+        RomSet, Snapshot, Tape,\n+    },\n+    zx::{\n+        keys::ZXKey,\n+        machine::ZXMachine,\n+        sound::ay::ZXAYMode,\n+        video::colors::{ZXBrightness, ZXColor},\n+    },\n+    EmulationMode, Emulator, RustzxSettings,\n+};\n+use rustzx_utils::{\n+    io::{DynamicAsset, GzipAsset},\n+    palette::rgba::ORIGINAL as DEFAULT_PALETTE,\n+    stopwatch::InstantStopwatch,\n+};\n+use std::{\n+    collections::VecDeque,\n+    env,\n+    io::Cursor,\n+    path::{Path, PathBuf},\n+    time::Duration,\n+};\n+\n+const DEFAULT_SOUND_BITRATE: usize = 44100;\n+const FRAME_HOST_DURATION_LIMIT: Duration = Duration::from_millis(100);\n+const FRAME_EMULATED_DURATION: Duration = Duration::from_millis(20);\n+const DEFAULT_SYNC_TIMEOUT: Duration = Duration::from_secs(3);\n+\n+\/\/ TODO(#83): Add tests for gigascreen\n+\n+struct FrameContent {\n+    buffer: Vec<u8>,\n+    width: usize,\n+    height: usize,\n+}\n+\n+impl FrameBuffer for FrameContent {\n+    type Context = TesterFrameBufferContext;\n+\n+    fn new(\n+        width: usize,\n+        height: usize,\n+        _source: FrameBufferSource,\n+        context: Self::Context,\n+    ) -> Self {\n+        if context.use_gigascreen {\n+            unimplemented!(\"Gigascreen tests are not yet implemented\");\n+        } else {\n+            let buffer_size = (width * height) \/ 2;\n+            Self {\n+                buffer: vec![0u8; buffer_size],\n+                width,\n+                height,\n+            }\n+        }\n+    }\n+\n+    fn set_color(&mut self, x: usize, y: usize, color: ZXColor, brightness: ZXBrightness) {\n+        let pixel_index = x + y * self.width;\n+        let buffer_index = pixel_index \/ 2;\n+        \/\/ 0xF0 mask for even pixels, 0x0F mask for odd pixels\n+        let mask = 0xF0 >> ((pixel_index % 2) * 4);\n+        let indexed_color = (color as u8) + (brightness as u8) * 8;\n+        \/\/ 0x0A => 0xAA, 0x03  => 0x33, etc.\n+        let color_overlay_byte = indexed_color | (indexed_color << 4);\n+        \/\/ clear previous color nibble and set to new value\n+        self.buffer[buffer_index] =\n+            (self.buffer[buffer_index] & (!mask)) | (color_overlay_byte & mask)\n+    }\n+}\n+\n+impl FrameContent {\n+    pub fn to_png(&self) -> Vec<u8> {\n+        let mut out = vec![];\n+\n+        {\n+            let mut encoder = png::Encoder::new(&mut out, self.width as u32, self.height as u32);\n+            encoder.set_depth(png::BitDepth::Four);\n+            encoder.set_color(png::ColorType::Indexed);\n+            encoder.set_palette(make_png_palette());\n+            let mut writer = encoder.write_header().expect(\"Failed to write PNG header\");\n+            writer\n+                .write_image_data(&self.buffer)\n+                .expect(\"Failed to write PNG data\");\n+        }\n+\n+        out\n+    }\n+}\n+\n+#[derive(Clone)]\n+struct TesterFrameBufferContext {\n+    use_gigascreen: bool,\n+}\n+\n+#[derive(Default)]\n+struct TesterContext;\n+\n+impl HostContext<TesterHost> for TesterContext {\n+    fn frame_buffer_context(&self) -> <FrameContent as FrameBuffer>::Context {\n+        TesterFrameBufferContext {\n+            use_gigascreen: false,\n+        }\n+    }\n+}\n+\n+#[derive(Default)]\n+pub struct DebugPort {\n+    stdin: VecDeque<u8>,\n+    stdout: VecDeque<u8>,\n+}\n+\n+impl IoExtender for DebugPort {\n+    fn write(&mut self, _: u16, data: u8) {\n+        self.stdout.push_back(data);\n+    }\n+\n+    fn read(&mut self, _: u16) -> u8 {\n+        self.stdin.pop_front().unwrap_or(0)\n+    }\n+\n+    fn extends_port(&self, port: u16) -> bool {\n+        port == 0xCCCC\n+    }\n+}\n+\n+impl DebugPort {\n+    pub fn put_byte(&mut self, b: u8) {\n+        self.stdin.push_back(b);\n+    }\n+\n+    pub fn take_byte(&mut self) -> Option<u8> {\n+        self.stdout.pop_front()\n+    }\n+\n+    pub fn put_text(&mut self, s: &str) {\n+        self.stdin.extend(s.as_bytes())\n+    }\n+\n+    pub fn take_text(&mut self) -> String {\n+        let s = Vec::from(std::mem::take(&mut self.stdout));\n+        String::from_utf8(s).expect(\"Invalid debug port stdout\")\n+    }\n+\n+    pub fn take_bufer(&mut self) -> Vec<u8> {\n+        Vec::from(std::mem::take(&mut self.stdout))\n+    }\n+\n+    pub fn reset(&mut self) {\n+        self.stdin.clear();\n+        self.stdout.clear();\n+    }\n+}\n+\n+struct TesterHost;\n+\n+impl Host for TesterHost {\n+    type Context = TesterContext;\n+    type EmulationStopwatch = InstantStopwatch;\n+    type FrameBuffer = FrameContent;\n+    type IoExtender = DebugPort;\n+    type TapeAsset = DynamicAsset;\n+}\n+\n+pub struct RustZXTester {\n+    emulator: Emulator<TesterHost>,\n+    sound_buffer: Option<Vec<i16>>,\n+    test_name: String,\n+    sync_timeout: Duration,\n+}\n+\n+pub mod presets {\n+    use super::*;\n+\n+    pub fn settings_48k_nosound() -> RustzxSettings {\n+        RustzxSettings {\n+            machine: ZXMachine::Sinclair48K,\n+            emulation_mode: EmulationMode::FrameCount(1),\n+            tape_fastload_enabled: true,\n+            kempston_enabled: false,\n+            mouse_enabled: false,\n+            ay_mode: ZXAYMode::ABC,\n+            ay_enabled: false,\n+            beeper_enabled: false,\n+            sound_enabled: false,\n+            sound_volume: 100,\n+            sound_sample_rate: DEFAULT_SOUND_BITRATE,\n+            load_default_rom: true,\n+            autoload_enabled: true,\n+        }\n+    }\n+\n+    pub fn settings_128k_nosound() -> RustzxSettings {\n+        RustzxSettings {\n+            machine: ZXMachine::Sinclair128K,\n+            ..settings_48k_nosound()\n+        }\n+    }\n+\n+    pub fn settings_48k() -> RustzxSettings {\n+        RustzxSettings {\n+            sound_enabled: true,\n+            ay_enabled: true,\n+            beeper_enabled: true,\n+            ..settings_48k_nosound()\n+        }\n+    }\n+\n+    pub fn settings_128k() -> RustzxSettings {\n+        RustzxSettings {\n+            machine: ZXMachine::Sinclair128K,\n+            ..settings_48k()\n+        }\n+    }\n+}\n+\n+impl RustZXTester {\n+    pub fn new(test_name: &str, settings: RustzxSettings) -> Self {\n+        let emulator = Emulator::new(settings, TesterContext::default())\n+            .expect(\"Failed to initialize emulator\");\n+\n+        Self {\n+            emulator,\n+            test_name: test_name.to_owned(),\n+            sound_buffer: None,\n+            sync_timeout: DEFAULT_SYNC_TIMEOUT,\n+        }\n+    }\n+\n+    fn assets_folder(&self) -> PathBuf {\n+        Path::new(\"test_data\").to_owned()\n+    }\n+\n+    fn actual_data_folder(&self) -> PathBuf {\n+        Path::new(\"test_data\/actual\").join(&self.test_name)\n+    }\n+\n+    fn load_asset_data(&mut self, name: impl AsRef<Path>) -> Vec<u8> {\n+        let path = self.assets_folder().join(name);\n+        let content = std::fs::read(&path).expect(\"Failed to load asset\");\n+\n+        if path\n+            .extension()\n+            .map(|e| e.to_str().unwrap() == \"gz\")\n+            .unwrap_or_default()\n+        {\n+            GzipAsset::new(Cursor::new(content))\n+                .expect(\"Failed to decompress gz\")\n+                .into_vec()\n+        } else {\n+            content\n+        }\n+    }\n+\n+    fn load_asset(&mut self, name: impl AsRef<Path>) -> DynamicAsset {\n+        BufferCursor::new(self.load_asset_data(name)).into()\n+    }\n+\n+    pub fn load_tap(&mut self, name: impl AsRef<Path>) {\n+        let asset = self.load_asset(name);\n+        self.emulator\n+            .load_tape(Tape::Tap(asset))\n+            .expect(\"Failed to load test TAP\");\n+    }\n+\n+    pub fn load_sna(&mut self, name: impl AsRef<Path>) {\n+        let asset = self.load_asset(name);\n+        self.emulator\n+            .load_snapshot(Snapshot::Sna(asset))\n+            .expect(\"Failed to load test SNA\")\n+    }\n+\n+    pub fn load_single_page_rom(&mut self, name: impl AsRef<Path>) {\n+        let rom_data = self.load_asset_data(name);\n+        struct DiagRomSet {\n+            pages: VecDeque<Vec<u8>>,\n+        }\n+\n+        impl RomSet for DiagRomSet {\n+            type Asset = BufferCursor<Vec<u8>>;\n+\n+            fn format(&self) -> RomFormat {\n+                RomFormat::Binary16KPages\n+            }\n+\n+            fn next_asset(&mut self) -> Option<Self::Asset> {\n+                Some(BufferCursor::new(self.pages.pop_front().unwrap()))\n+            }\n+        }\n+\n+        let rom_set = DiagRomSet {\n+            pages: VecDeque::from(vec![rom_data, vec![0u8; 16 * 1024]]),\n+        };\n+\n+        self.emulator.load_rom(rom_set).unwrap();\n+    }\n+\n+    fn get_screen(&self) -> Vec<u8> {\n+        self.emulator.screen_buffer().to_png()\n+    }\n+\n+    fn get_border(&self) -> Vec<u8> {\n+        self.emulator.border_buffer().to_png()\n+    }\n+\n+    fn update_sound(&mut self) {\n+        if let Some(sound_buffer) = &mut self.sound_buffer {\n+            while let Some(sample) = self.emulator.next_audio_sample() {\n+                let normalize = |s| (s * i16::MAX as f32) as i16;\n+                sound_buffer.push(normalize(sample.left));\n+                sound_buffer.push(normalize(sample.right));\n+            }\n+        }\n+    }\n+\n+    pub fn emulate_for(&mut self, duration: Duration) {\n+        let mut emulated_duration = Duration::from_secs(0);\n+        while emulated_duration < duration {\n+            self.emulator\n+                .emulate_frames(FRAME_HOST_DURATION_LIMIT)\n+                .expect(\"Emulation failed\");\n+            self.update_sound();\n+            emulated_duration += FRAME_EMULATED_DURATION;\n+        }\n+    }\n+\n+    pub fn emulate_frame(&mut self) {\n+        self.emulate_for(FRAME_EMULATED_DURATION);\n+    }\n+\n+    pub fn compare_buffer_with_file(\n+        &self,\n+        actual: Vec<u8>,\n+        name: impl AsRef<Path>,\n+        expect: Expect,\n+    ) {\n+        if TestEnv::save_test_data_enabled() {\n+            self.save_actual_data(&actual, name.as_ref());\n+        }\n+\n+        expect.assert_eq(&actual.fingerprint());\n+    }\n+\n+    fn save_actual_data(&self, actual: &[u8], filename: &Path) {\n+        let filename = self.actual_data_folder().join(filename);\n+        eprintln!(\"Saving actual test data file {}\", filename.display());\n+\n+        std::fs::create_dir_all(self.actual_data_folder())\n+            .expect(\"Failed to create actual data dir\");\n+        std::fs::write(filename, actual).expect(\"Failed to write actual data\");\n+    }\n+\n+    pub fn expect_screen(&self, name: impl AsRef<Path>, expect: Expect) {\n+        self.compare_buffer_with_file(self.get_screen(), make_screen_filename(name), expect);\n+    }\n+\n+    pub fn expect_border(&self, name: impl AsRef<Path>, expect: Expect) {\n+        self.compare_buffer_with_file(self.get_border(), make_border_filename(name), expect);\n+    }\n+\n+    pub fn expect_text(&self, name: impl AsRef<Path>, text: String, expect: Expect) {\n+        self.compare_buffer_with_file(text.into_bytes(), make_text_filename(name), expect);\n+    }\n+\n+    pub fn emulator(&mut self) -> &mut Emulator<impl Host> {\n+        &mut self.emulator\n+    }\n+\n+    pub fn send_keystrokes(&mut self, keystrokes: &[&[ZXKey]], keystroke_delay: Duration) {\n+        let mut first = true;\n+        for keys in keystrokes {\n+            if !first {\n+                self.emulate_for(keystroke_delay);\n+            }\n+            first = false;\n+\n+            for key in *keys {\n+                self.emulator.send_key(*key, true);\n+            }\n+\n+            self.emulate_for(keystroke_delay);\n+\n+            for key in *keys {\n+                self.emulator.send_key(*key, false);\n+            }\n+        }\n+    }\n+\n+    pub fn start_sound_capture(&mut self) {\n+        \/\/ Pre-allocate 1Mb of memory\n+        self.sound_buffer.replace(Vec::with_capacity(1024 * 1024));\n+    }\n+\n+    pub fn expect_sound(&mut self, name: impl AsRef<Path>, expect: Expect) {\n+        let data = self\n+            .sound_buffer\n+            .take()\n+            .expect(\"Sound is not being recorded\");\n+\n+        let mut wav_data = std::io::Cursor::new(vec![]);\n+        let wav_header = wav::Header::new(\n+            wav::header::WAV_FORMAT_PCM,\n+            2,\n+            DEFAULT_SOUND_BITRATE as u32,\n+            16,\n+        );\n+        wav::write(wav_header, &wav::BitDepth::Sixteen(data), &mut wav_data)\n+            .expect(\"Failed to generate wav\");\n+\n+        self.compare_buffer_with_file(wav_data.into_inner(), make_sound_filename(name), expect);\n+    }\n+\n+    pub fn enable_debug_port(&mut self) {\n+        self.emulator.set_io_extender(DebugPort::default());\n+    }\n+\n+    pub fn debug_port(&mut self) -> &mut DebugPort {\n+        self.emulator\n+            .io_extender()\n+            .expect(\"Debug port is not enabled for the current test\")\n+    }\n+\n+    pub fn sync_target(&mut self) {\n+        if !self.debug_port().stdout.is_empty() || !self.debug_port().stdin.is_empty() {\n+            panic!(\n+                \"ERROR: Test may be incorrect, there were some unprocessed data in the target's \\\n+                 port before sync\"\n+            );\n+        }\n+\n+        \/\/ Host (this test executable) writes and then reads port,\n+        \/\/ while target (emulated snapshot) reads and then writes,\n+        \/\/ this allows to sync both sides and doesn not produce any\n+        \/\/ deadlocks\n+        self.debug_port().put_byte(1);\n+\n+        let mut sync_duration = Duration::default();\n+        loop {\n+            self.emulate_for(FRAME_EMULATED_DURATION);\n+            sync_duration += FRAME_EMULATED_DURATION;\n+\n+            if sync_duration > self.sync_timeout {\n+                panic!(\"Timeout reached when trying to sync host with target\");\n+            }\n+\n+            \/\/ Try to consume incomming signal and finish sync\n+            if self.debug_port().take_byte().is_some() {\n+                break;\n+            }\n+        }\n+    }\n+\n+    pub fn set_sync_timeout(&mut self, timeout: Duration) {\n+        self.sync_timeout = timeout;\n+    }\n+}\n+\n+struct TestEnv;\n+\n+impl TestEnv {\n+    fn save_test_data_enabled() -> bool {\n+        env::var(\"RUSTZX_SAVE_TEST_DATA\")\n+            .map(|v| matches!(v.as_str(), \"1\" | \"true\" | \"yes\"))\n+            .unwrap_or(false)\n+    }\n+}\n+\n+fn make_png_palette() -> Vec<u8> {\n+    DEFAULT_PALETTE\n+        .iter()\n+        .fold(Vec::with_capacity(4 * 16), |mut buffer, color| {\n+            buffer.extend_from_slice(&color[0..3]);\n+            buffer\n+        })\n+}\n+\n+fn make_screen_filename(name: impl AsRef<Path>) -> PathBuf {\n+    name.as_ref().with_extension(\"screen.png\")\n+}\n+\n+fn make_border_filename(name: impl AsRef<Path>) -> PathBuf {\n+    name.as_ref().with_extension(\"border.png\")\n+}\n+\n+fn make_sound_filename(name: impl AsRef<Path>) -> PathBuf {\n+    name.as_ref().with_extension(\"wav\")\n+}\n+\n+fn make_text_filename(name: impl AsRef<Path>) -> PathBuf {\n+    name.as_ref().with_extension(\"txt\")\n+}\n+\n+trait Fingerprintable {\n+    fn fingerprint(&self) -> String;\n+}\n+\n+impl Fingerprintable for Vec<u8> {\n+    fn fingerprint(&self) -> String {\n+        use sha2::{Digest, Sha256};\n+\n+        let mut hasher = Sha256::default();\n+        hasher.update(&self);\n+        let hash = hasher.finalize();\n+        base64::encode(hash)\n+    }\n+}\ndiff --git a\/rustzx-test\/src\/lib.rs b\/rustzx-test\/src\/lib.rs\nnew file mode 100644\nindex 0000000..0c71749\n--- \/dev\/null\n+++ b\/rustzx-test\/src\/lib.rs\n@@ -0,0 +1,1 @@\n+pub mod framework;\ndiff --git a\/rustzx-core\/test_data\/asset\/.gitignore b\/rustzx-test\/test_data\/.gitignore\nsimilarity index 61%\nrename from rustzx-core\/test_data\/asset\/.gitignore\nrename to rustzx-test\/test_data\/.gitignore\nindex 0aa9b3b..67522b8 100644\n--- a\/rustzx-core\/test_data\/asset\/.gitignore\n+++ b\/rustzx-test\/test_data\/.gitignore\n@@ -1,2 +1,3 @@\n+actual\/**\n build\/**\n out\/**\ndiff --git a\/rustzx-test\/test_data\/diag_rom_v56.gz b\/rustzx-test\/test_data\/diag_rom_v56.gz\nnew file mode 100644\nindex 0000000..9443630\nBinary files \/dev\/null and b\/rustzx-test\/test_data\/diag_rom_v56.gz differ\ndiff --git a\/rustzx-test\/test_data\/diag_rom_v56_started.128k.sna.gz b\/rustzx-test\/test_data\/diag_rom_v56_started.128k.sna.gz\nnew file mode 100644\nindex 0000000..18ca571\nBinary files \/dev\/null and b\/rustzx-test\/test_data\/diag_rom_v56_started.128k.sna.gz differ\ndiff --git a\/rustzx-test\/test_data\/kempston_joy.48k.sna.gz b\/rustzx-test\/test_data\/kempston_joy.48k.sna.gz\nnew file mode 100644\nindex 0000000..6868ede\nBinary files \/dev\/null and b\/rustzx-test\/test_data\/kempston_joy.48k.sna.gz differ\ndiff --git a\/rustzx-test\/test_data\/keyboard.48k.sna.gz b\/rustzx-test\/test_data\/keyboard.48k.sna.gz\nnew file mode 100644\nindex 0000000..dd04b12\nBinary files \/dev\/null and b\/rustzx-test\/test_data\/keyboard.48k.sna.gz differ\ndiff --git a\/rustzx-core\/test_data\/asset\/make.sh b\/rustzx-test\/test_data\/make.sh\nsimilarity index 63%\nrename from rustzx-core\/test_data\/asset\/make.sh\nrename to rustzx-test\/test_data\/make.sh\nindex 08fc3a7..762c524 100644\n--- a\/rustzx-core\/test_data\/asset\/make.sh\n+++ b\/rustzx-test\/test_data\/make.sh\n@@ -80,8 +80,8 @@ ${ZMAKEBAS_BIN} \\\n     -l \\\n     -a 10 \\\n     -n screen \\\n-    -o \"${BUILD_DIR}\/loaders\/screen.tap\" \\\n-    \"${SRC_DIR}\/loaders\/screen.bas\"\n+    -o \"${BUILD_DIR}\/loader_screen.tap\" \\\n+    \"${SRC_DIR}\/loader_screen.bas\"\n if [ $? -ne 0 ]; then\n     log_error \"Failed to build screen loader\"\n     exit 1\n@@ -92,13 +92,49 @@ log_unindent\n log_info \"Building simple_tape...\"\n log_indent\n z88dk-appmake +zx \\\n-    -b \"${SRC_DIR}\/simple_tape\/loading.scr\" \\\n+    -b \"${SRC_DIR}\/rustzx.scr\" \\\n     -o \"${BUILD_DIR}\/simple_tape_loaderless.tap\" \\\n     --blockname screen \\\n     --org 16384 \\\n     --noloader\n-cat \"${BUILD_DIR}\/loaders\/screen.tap\" \\\n+cat \"${BUILD_DIR}\/loader_screen.tap\" \\\n     \"${BUILD_DIR}\/simple_tape_loaderless.tap\" \\\n-    > \"${OUT_DIR}\/simple_tape.tap\"\n+    > \"${BUILD_DIR}\/simple_tape.tap\"\n+gzip --stdout \"${BUILD_DIR}\/simple_tape.tap\" > \"${OUT_DIR}\/simple_tape.tap.gz\"\n log_success \"Done\"\n log_unindent\n+\n+function build_sna {\n+    local APP_NAME=\"$1\"\n+    local ADDITIONAL_ARGS=\"\"\n+    local EXT_PREFIX=\"48k\"\n+\n+    if [ \"$2\" = \"128k\" ]; then\n+        ADDITIONAL_ARGS=\"-Cz --128\"\n+        local EXT_PREFIX=\"128k\"\n+    fi\n+\n+    log_info \"Building ${APP_NAME} SNA (${EXT_PREFIX})...\"\n+    log_indent\n+    zcc +zx \\\n+        -lm \\\n+        -o \"${BUILD_DIR}\/${APP_NAME}.${EXT_PREFIX}.o\" \\\n+        -create-app \\\n+        -Cz --sna \\\n+        -Cz -o \\\n+        -Cz \"${BUILD_DIR}\/${APP_NAME}.${EXT_PREFIX}.sna\" \\\n+        \"${ADDITIONAL_ARGS}\" \\\n+        \"${SRC_DIR}\/${APP_NAME}.c\" \\\n+        \"${SRC_DIR}\/librustzx.c\" \\\n+        && gzip \\\n+            --stdout \"${BUILD_DIR}\/${APP_NAME}.${EXT_PREFIX}.sna\" \\\n+            > \"${OUT_DIR}\/${APP_NAME}.${EXT_PREFIX}.sna.gz\"\n+    log_success \"Done\"\n+    log_unindent\n+}\n+\n+build_sna sound 48k\n+build_sna sound 128k\n+build_sna mouse 48k\n+build_sna kempston_joy 48k\n+build_sna keyboard 48k\ndiff --git a\/rustzx-test\/test_data\/mouse.48k.sna.gz b\/rustzx-test\/test_data\/mouse.48k.sna.gz\nnew file mode 100644\nindex 0000000..7d50f6c\nBinary files \/dev\/null and b\/rustzx-test\/test_data\/mouse.48k.sna.gz differ\ndiff --git a\/rustzx-test\/test_data\/simple_tape.tap.gz b\/rustzx-test\/test_data\/simple_tape.tap.gz\nnew file mode 100644\nindex 0000000..6cf098c\nBinary files \/dev\/null and b\/rustzx-test\/test_data\/simple_tape.tap.gz differ\ndiff --git a\/rustzx-test\/test_data\/sound.128k.sna.gz b\/rustzx-test\/test_data\/sound.128k.sna.gz\nnew file mode 100644\nindex 0000000..e77a57e\nBinary files \/dev\/null and b\/rustzx-test\/test_data\/sound.128k.sna.gz differ\ndiff --git a\/rustzx-test\/test_data\/sound.48k.sna.gz b\/rustzx-test\/test_data\/sound.48k.sna.gz\nnew file mode 100644\nindex 0000000..d6c793b\nBinary files \/dev\/null and b\/rustzx-test\/test_data\/sound.48k.sna.gz differ\ndiff --git a\/rustzx-test\/test_data\/src\/kempston_joy.c b\/rustzx-test\/test_data\/src\/kempston_joy.c\nnew file mode 100644\nindex 0000000..1fdbf0e\n--- \/dev\/null\n+++ b\/rustzx-test\/test_data\/src\/kempston_joy.c\n@@ -0,0 +1,16 @@\n+#include \"librustzx.h\"\n+\n+static unsigned char get_kempston_joy_state(void) __z88dk_callee {\n+    __asm__(\"in a, ($1f)\");\n+    __asm__(\"mov l, a\");\n+    __asm__(\"ret\");\n+}\n+\n+void main() {\n+    \/\/ Respond to each sync request from the rust test\n+    for (;;) {\n+        rustzx_sync_with_host();\n+        rustzx_port_write_byte_hex(get_kempston_joy_state());\n+        rustzx_port_write_char(',');\n+    }\n+}\ndiff --git a\/rustzx-test\/test_data\/src\/keyboard.c b\/rustzx-test\/test_data\/src\/keyboard.c\nnew file mode 100644\nindex 0000000..b658f4d\n--- \/dev\/null\n+++ b\/rustzx-test\/test_data\/src\/keyboard.c\n@@ -0,0 +1,58 @@\n+#include \"librustzx.h\"\n+\n+#define KEYS_COUNT 8\n+\n+\n+static unsigned char keyboard_state[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n+\n+static unsigned char query_keyboard_state(void) __z88dk_callee {\n+    __asm__(\"ld c, $FE\");\n+\n+    __asm__(\"ld b, $FE\");\n+    __asm__(\"in a, (c)\");\n+    __asm__(\"ld (_keyboard_state + 0), a\");\n+    __asm__(\"ld b, $FD\");\n+    __asm__(\"in a, (c)\");\n+    __asm__(\"ld (_keyboard_state + 1), a\");\n+    __asm__(\"ld b, $FB\");\n+    __asm__(\"in a, (c)\");\n+    __asm__(\"ld (_keyboard_state + 2), a\");\n+    __asm__(\"ld b, $F7\");\n+    __asm__(\"in a, (c)\");\n+    __asm__(\"ld (_keyboard_state + 3), a\");\n+    __asm__(\"ld b, $EF\");\n+    __asm__(\"in a, (c)\");\n+    __asm__(\"ld (_keyboard_state + 4), a\");\n+    __asm__(\"ld b, $DF\");\n+    __asm__(\"in a, (c)\");\n+    __asm__(\"ld (_keyboard_state + 5), a\");\n+    __asm__(\"ld b, $BF\");\n+    __asm__(\"in a, (c)\");\n+    __asm__(\"ld (_keyboard_state + 6), a\");\n+    __asm__(\"ld b, $7F\");\n+    __asm__(\"in a, (c)\");\n+    __asm__(\"ld (_keyboard_state + 7), a\");\n+    __asm__(\"ret\");\n+}\n+\n+void send_keyboard_state() {\n+    query_keyboard_state();\n+\n+    for (int i = 0; i < 8; ++i) {\n+        \/\/ bitwise OR operation with each read byte is\n+        \/\/ required to ignore other ULA port content\n+        \/\/ (3 most significant bits). This is reuiqred\n+        \/\/ to make keyboard test independent from\n+        \/\/ other ULA functionality tests\n+        rustzx_port_write_byte_hex(keyboard_state[i] | 0xE0);\n+    }\n+}\n+\n+void main() {\n+    \/\/ Respond to each sync request from the rust test\n+    for (;;) {\n+        rustzx_sync_with_host();\n+        send_keyboard_state();\n+        rustzx_port_write_char('\\n');\n+    }\n+}\ndiff --git a\/rustzx-test\/test_data\/src\/librustzx.c b\/rustzx-test\/test_data\/src\/librustzx.c\nnew file mode 100644\nindex 0000000..50976fa\n--- \/dev\/null\n+++ b\/rustzx-test\/test_data\/src\/librustzx.c\n@@ -0,0 +1,51 @@\n+#include \"librustzx.h\"\n+\n+static const char HEX_ALPHABET[16] = {\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n+};\n+\n+static unsigned char read_debug_port(void) __z88dk_callee {\n+    __asm__(\"ld a, $CC\");\n+    __asm__(\"in a, ($CC)\");\n+    __asm__(\"mov l, a\");\n+    __asm__(\"ret\");\n+}\n+\n+static volatile unsigned char _rustzx_debug_port_tmp = 0;\n+\n+static unsigned char write_debug_port(void) __z88dk_callee {\n+    __asm__(\"ld a, (__rustzx_debug_port_tmp)\");\n+    __asm__(\"ld b, $CC\");\n+    __asm__(\"ld c, $CC\");\n+    __asm__(\"out (c), a\");\n+    __asm__(\"ret\");\n+}\n+\n+void rustzx_port_write_str(char* s) {\n+    while (*s) {\n+        _rustzx_debug_port_tmp = *(s++);\n+        write_debug_port();\n+    }\n+}\n+\n+void rustzx_port_write_char(char x) {\n+    _rustzx_debug_port_tmp = x;\n+    write_debug_port();\n+}\n+\n+void rustzx_port_write_byte_hex(unsigned char x) {\n+    _rustzx_debug_port_tmp = HEX_ALPHABET[(x & 0xF0) >> 4];\n+    write_debug_port();\n+    _rustzx_debug_port_tmp = HEX_ALPHABET[x & 0x0F];\n+    write_debug_port();\n+}\n+\n+unsigned char rustzx_port_read_byte() {\n+    return read_debug_port();\n+}\n+\n+void rustzx_sync_with_host() {\n+    while (!read_debug_port()) {}\n+    _rustzx_debug_port_tmp = 1;\n+    write_debug_port();\n+}\ndiff --git a\/rustzx-test\/test_data\/src\/librustzx.h b\/rustzx-test\/test_data\/src\/librustzx.h\nnew file mode 100644\nindex 0000000..156a4a7\n--- \/dev\/null\n+++ b\/rustzx-test\/test_data\/src\/librustzx.h\n@@ -0,0 +1,6 @@\n+void rustzx_port_write_str(char* s);\n+void rustzx_port_write_char(char x);\n+void rustzx_port_write_byte_hex(unsigned char x);\n+unsigned char rustzx_port_read_byte();\n+\n+void rustzx_sync_with_host();\ndiff --git a\/rustzx-core\/test_data\/asset\/src\/loaders\/screen.bas b\/rustzx-test\/test_data\/src\/loader_screen.bas\nsimilarity index 100%\nrename from rustzx-core\/test_data\/asset\/src\/loaders\/screen.bas\nrename to rustzx-test\/test_data\/src\/loader_screen.bas\ndiff --git a\/rustzx-test\/test_data\/src\/mouse.c b\/rustzx-test\/test_data\/src\/mouse.c\nnew file mode 100644\nindex 0000000..91d9cfa\n--- \/dev\/null\n+++ b\/rustzx-test\/test_data\/src\/mouse.c\n@@ -0,0 +1,176 @@\n+#include <graphics.h>\n+#include <conio.h>\n+\n+\/\/ We can't use here z88dk implementation is does not allow to\n+\/\/ do not well things like additional mouse buttons\n+static unsigned char io_kempston_state(void) __z88dk_callee {\n+    __asm__(\"ld a, $FA\");\n+    __asm__(\"in a, ($DF)\");\n+    __asm__(\"mov l, a\");\n+    __asm__(\"ret\");\n+}\n+\n+static unsigned char io_kempston_mouse_x(void) __z88dk_callee {\n+    __asm__(\"ld a, $FB\");\n+    __asm__(\"in a, ($DF)\");\n+    __asm__(\"mov l, a\");\n+    __asm__(\"ret\");\n+}\n+\n+static unsigned char io_kempston_mouse_y(void) __z88dk_callee {\n+    __asm__(\"ld a, $FF\");\n+    __asm__(\"in a, ($DF)\");\n+    __asm__(\"mov l, a\");\n+    __asm__(\"ret\");\n+}\n+\n+static struct {\n+    unsigned char prev_x;\n+    unsigned char prev_y;\n+    unsigned char prev_state;\n+    unsigned char x;\n+    unsigned char y;\n+    unsigned char state;\n+} g_kemp_mouse;\n+\n+static void kemp_poll(void) {\n+    g_kemp_mouse.prev_x = g_kemp_mouse.x;\n+    g_kemp_mouse.prev_y = g_kemp_mouse.y;\n+    g_kemp_mouse.prev_state = g_kemp_mouse.state;\n+\n+    g_kemp_mouse.x = io_kempston_mouse_x();\n+    g_kemp_mouse.y = 255 - io_kempston_mouse_y();\n+    g_kemp_mouse.state = io_kempston_state();\n+}\n+\n+static void kemp_init(void) {\n+    g_kemp_mouse.prev_x = g_kemp_mouse.x = io_kempston_mouse_x();\n+    g_kemp_mouse.prev_y = g_kemp_mouse.y = 255 - io_kempston_mouse_y();\n+    g_kemp_mouse.prev_state = g_kemp_mouse.state = io_kempston_state();\n+}\n+\n+static unsigned char kemp_left_button_pressed(void) { return g_kemp_mouse.state & 0x01; }\n+\n+static unsigned char kemp_right_button_pressed(void) { return g_kemp_mouse.state & 0x02; }\n+\n+static unsigned char kemp_middle_button_pressed(void) { return g_kemp_mouse.state & 0x04; }\n+\n+static unsigned char kemp_ext_button_pressed(void) { return g_kemp_mouse.state & 0x08; }\n+\n+static char kemp_wheel_diff(void) {\n+    unsigned char prev_wheel = (g_kemp_mouse.prev_state & 0xF0);\n+    unsigned char wheel = (g_kemp_mouse.state & 0xF0);\n+    return (char)(wheel - prev_wheel) \/ 16;\n+}\n+\n+static char kemp_x_diff(void) { return (char)(g_kemp_mouse.x - g_kemp_mouse.prev_x); }\n+\n+static char kemp_y_diff(void) { return (char)(g_kemp_mouse.y - g_kemp_mouse.prev_y); }\n+\n+static const char CURSOR_SPRITE[8] = { 0xE0, 0xF8, 0xFE, 0x7F, 0x7C, 0x3E, 0x37, 0x13 };\n+\n+static int is_cursor_pixel_set(int cursor_x, int cursor_y, int screen_x, int screen_y) {\n+    if ((screen_x < cursor_x)\n+        || (screen_x >= cursor_x + 8)\n+        || (screen_y < cursor_y)\n+        || (screen_y >= cursor_y + 8))\n+    {\n+        return 0;\n+    }\n+\n+    int rel_x = screen_x - cursor_x;\n+    int rel_y = screen_y - cursor_y;\n+\n+    return CURSOR_SPRITE[rel_y] & (0x80 >> rel_x);\n+}\n+\n+static void paint_cursor(int xpos, int ypos, int prev_xpos, int prev_ypos) {\n+    textcolor(BLACK);\n+    for (int y = 0; y < 8; y++) {\n+        for (int x = 0; x < 8; x++) {\n+            int screen_x = xpos + x;\n+            int screen_y = ypos + y;\n+\n+            int prev_screen_x = prev_xpos + x;\n+            int prev_screen_y = prev_ypos + y;\n+\n+            int is_prev_set = is_cursor_pixel_set(xpos, ypos, prev_screen_x, prev_screen_y);\n+            int is_now_set = is_cursor_pixel_set(xpos, ypos, screen_x, screen_y);\n+\n+            \/\/ clear pixels in the previous cursor area\n+            if (!is_prev_set) {\n+                unplot(prev_screen_x, prev_screen_y);\n+            }\n+\n+            \/\/ set pixels in the new pixels area\n+            if (is_now_set) {\n+                plot(screen_x, screen_y);\n+            }\n+        }\n+    }\n+}\n+\n+static void draw_button_box(unsigned char index, unsigned char pressed) {\n+    if (pressed) {\n+        textcolor(RED); drawb(32 * index, 0, 3, 3);\n+    } else {\n+        textcolor(WHITE); drawb(32 * index, 0, 3, 3);\n+    }\n+}\n+\n+static void draw_scroll_box(unsigned char prev_ypos, unsigned char ypos) {\n+    textcolor(WHITE);\n+    drawb(0, prev_ypos, 3, 3);\n+    textcolor(RED);\n+    drawb(0, ypos, 3, 3);\n+}\n+\n+void main() {\n+    cclg();\n+    kemp_init();\n+    unsigned char xpos = 0;\n+    unsigned char ypos = 0;\n+    unsigned char prev_xpos = 0;\n+    unsigned char prev_ypos = 0;\n+\n+    unsigned char wheel = 0;\n+\n+    while(1) {\n+        kemp_poll();\n+\n+        short virtual_x = (short)xpos + kemp_x_diff();\n+        short virtual_y = (short)ypos + kemp_y_diff();\n+        if (virtual_y > 191) virtual_y = 1;\n+        if (virtual_y < 0) virtual_y = 192;\n+\n+        prev_xpos = xpos;\n+        prev_ypos = ypos;\n+        xpos = (unsigned char) virtual_x;\n+        ypos = (unsigned char) virtual_y;\n+\n+        paint_cursor(xpos, ypos, prev_xpos, prev_ypos);\n+\n+        char wheel_diff = kemp_wheel_diff();\n+        if (wheel_diff != 0) {\n+            unsigned char prev_wheel = wheel;\n+            if (wheel_diff > 0) {\n+                if ((short)wheel + wheel_diff < 192)\n+                    wheel = (short)wheel + wheel_diff;\n+                else\n+                    wheel = 191;\n+            }\n+            if (wheel_diff < 0) {\n+                if ((short)wheel + wheel_diff >= 0)\n+                    wheel = (short)wheel + wheel_diff;\n+                else\n+                    wheel = 0;\n+            }\n+            draw_scroll_box(prev_wheel, wheel);\n+        }\n+\n+        draw_button_box(1, kemp_left_button_pressed());\n+        draw_button_box(2, kemp_right_button_pressed());\n+        draw_button_box(3, kemp_middle_button_pressed());\n+        draw_button_box(4, kemp_ext_button_pressed());\n+    }\n+}\ndiff --git a\/rustzx-core\/test_data\/asset\/src\/simple_tape\/loading.scr b\/rustzx-test\/test_data\/src\/rustzx.scr\nsimilarity index 100%\nrename from rustzx-core\/test_data\/asset\/src\/simple_tape\/loading.scr\nrename to rustzx-test\/test_data\/src\/rustzx.scr\ndiff --git a\/rustzx-test\/test_data\/src\/sound.c b\/rustzx-test\/test_data\/src\/sound.c\nnew file mode 100644\nindex 0000000..8bae494\n--- \/dev\/null\n+++ b\/rustzx-test\/test_data\/src\/sound.c\n@@ -0,0 +1,13 @@\n+#include <sound.h>\n+#include <psg.h>\n+\n+void main() {\n+\tpsg_init();\n+\tpsg_channels(chanAll, chanNone); \/\/ set all channels to tone generation\n+    psg_tone(0, psgT(130.8)); \/\/ produce a C tone on the first channel\n+    psg_tone(1, psgT(164.8)); \/\/ produce a E tone on the second channel\n+    psg_tone(2, psgT(195.9)); \/\/ produce a G tone on the third channel\n+    psg_envelope(envUH, psgT(16), chanAll); \/\/ set a raising volume envelope on all channels\n+    bit_play(\"EmDCDCD\"); \/\/ play some random tune on beeper\n+    psg_envelope(envD, psgT(16), chanAll); \/\/ set a fading volume envelope on all channels\n+}\ndiff --git a\/rustzx-core\/test_data\/asset\/src\/third-party\/zmakebas-1.3.tar.gz b\/rustzx-test\/test_data\/src\/third-party\/zmakebas-1.3.tar.gz\nsimilarity index 100%\nrename from rustzx-core\/test_data\/asset\/src\/third-party\/zmakebas-1.3.tar.gz\nrename to rustzx-test\/test_data\/src\/third-party\/zmakebas-1.3.tar.gz\ndiff --git a\/rustzx-test\/tests\/diag_rom.rs b\/rustzx-test\/tests\/diag_rom.rs\nnew file mode 100644\nindex 0000000..fa0bf26\n--- \/dev\/null\n+++ b\/rustzx-test\/tests\/diag_rom.rs\n@@ -0,0 +1,117 @@\n+use expect_test::expect;\n+use rustzx_core::zx::{keys::ZXKey, machine::ZXMachine};\n+use rustzx_test::framework::{presets, RustZXTester};\n+use std::time::Duration;\n+\n+const DIAG_ROM_NAME: &str = \"diag_rom_v56.gz\";\n+const DIAG_ROM_MENU_SNAP_128K_NAME: &str = \"diag_rom_v56_started.128k.sna.gz\";\n+\n+fn load_diag_rom(t: &mut RustZXTester) {\n+    t.load_single_page_rom(DIAG_ROM_NAME);\n+}\n+\n+fn load_diag_rom_menu_sna(t: &mut RustZXTester, machine: ZXMachine) {\n+    if machine != ZXMachine::Sinclair128K {\n+        panic!(\"Non-128K DiagROM snapshots are missing\");\n+    }\n+    load_diag_rom(t);\n+    \/\/ NOTE: DiagROM is a little bit tricky about loading its state via snapshot, therefore\n+    \/\/ here we actually load SNA of emulator a few moments before showing actual DiagROM menu\n+    t.load_sna(DIAG_ROM_MENU_SNAP_128K_NAME);\n+    t.emulate_for(Duration::from_millis(1000));\n+}\n+\n+#[test]\n+fn diag_rom_mem_48k() {\n+    let mut t = RustZXTester::new(\"diag_rom_mem_48k\", presets::settings_48k_nosound());\n+    load_diag_rom(&mut t);\n+    t.emulate_for(Duration::from_secs(50));\n+    t.expect_screen(\n+        \"result\",\n+        expect![[r#\"JYQl8vwFrIjaC+tZT34FBtey\/aJHuylNvjldBTDIL0Q=\"#]],\n+    );\n+}\n+\n+#[test]\n+fn diag_rom_mem_128k() {\n+    let mut t = RustZXTester::new(\"diag_rom_mem_128k\", presets::settings_128k_nosound());\n+    load_diag_rom(&mut t);\n+    t.emulate_for(Duration::from_secs(50));\n+    t.expect_screen(\n+        \"result\",\n+        expect![[r#\"JYQl8vwFrIjaC+tZT34FBtey\/aJHuylNvjldBTDIL0Q=\"#]],\n+    );\n+}\n+\n+#[test]\n+fn diag_rom_mem_banked_128k() {\n+    let mut t = RustZXTester::new(\"diag_rom_mem_banked_128k\", presets::settings_128k_nosound());\n+    load_diag_rom_menu_sna(&mut t, ZXMachine::Sinclair128K);\n+    t.send_keystrokes(&[&[ZXKey::N7], &[ZXKey::N1]], Duration::from_millis(100));\n+    t.emulate_for(Duration::from_secs(100));\n+    t.expect_screen(\n+        \"result\",\n+        expect![[r#\"27D2yD4yM6WJAv3vO3NyofTuSVfGOQXo8V0qrbc5wVk=\"#]],\n+    );\n+}\n+\n+#[test]\n+fn diag_rom_second_screen_bank_128k() {\n+    let mut t = RustZXTester::new(\n+        \"diag_rom_second_screen_bank_128k\",\n+        presets::settings_128k_nosound(),\n+    );\n+    load_diag_rom_menu_sna(&mut t, ZXMachine::Sinclair128K);\n+    t.send_keystrokes(&[&[ZXKey::N7], &[ZXKey::N2]], Duration::from_millis(100));\n+    t.emulate_for(Duration::from_secs(3));\n+    t.expect_screen(\n+        \"screen1\",\n+        expect![[r#\"+uu521vfpyy9IUSYYiqbiOu9s0NIV7gW8Co\/ZXKRi2I=\"#]],\n+    );\n+    t.emulate_for(Duration::from_secs(4));\n+    t.expect_screen(\n+        \"screen2\",\n+        expect![[r#\"ff2AqkCUYcPdp+yLMsOg8s3DyBpwC6YEvyUMR\/RWPSs=\"#]],\n+    );\n+}\n+\n+#[test]\n+fn diag_rom_contention_128k() {\n+    let mut t = RustZXTester::new(\"diag_rom_contention_128k\", presets::settings_128k_nosound());\n+    load_diag_rom_menu_sna(&mut t, ZXMachine::Sinclair128K);\n+    t.send_keystrokes(&[&[ZXKey::N7], &[ZXKey::N5]], Duration::from_millis(100));\n+    t.emulate_for(Duration::from_secs(3));\n+    t.expect_screen(\n+        \"result\",\n+        expect![[r#\"ImqjTr7XsJrZsDPYqB\/wRgYachkgCHHPbCc+rH3Clg8=\"#]],\n+    );\n+}\n+\n+#[test]\n+fn diag_rom_ula_128k() {\n+    let mut t = RustZXTester::new(\"diag_rom_ula_128k\", presets::settings_128k_nosound());\n+    load_diag_rom_menu_sna(&mut t, ZXMachine::Sinclair128K);\n+    t.send_keystrokes(&[&[ZXKey::N6], &[ZXKey::N1]], Duration::from_millis(100));\n+    t.emulate_for(Duration::from_secs(3));\n+    t.expect_screen(\n+        \"result\",\n+        expect![[r#\"I2YQuImYmwfzNB9Y48M4ce2JVwDsQcEO2jamkLoBYxs=\"#]],\n+    );\n+}\n+\n+#[test]\n+fn diag_rom_interrupt_128k() {\n+    let mut t = RustZXTester::new(\"diag_rom_interrupt_128k\", presets::settings_128k_nosound());\n+    load_diag_rom_menu_sna(&mut t, ZXMachine::Sinclair128K);\n+    t.send_keystrokes(&[&[ZXKey::N6], &[ZXKey::N4]], Duration::from_millis(100));\n+    t.emulate_for(Duration::from_secs(2));\n+    t.expect_screen(\n+        \"frame1\",\n+        expect![[r#\"47E1ralzgtRVSmo6f1e9bMHyw1S+b4F\/zQOTVo0bfq0=\"#]],\n+    );\n+    t.emulate_for(Duration::from_secs(2));\n+    t.expect_screen(\n+        \"frame2\",\n+        expect![[r#\"ZmdepGrZWq8SvP+GeXziGeuNj0T0nR0VL6XGXPN6DAw=\"#]],\n+    );\n+}\ndiff --git a\/rustzx-test\/tests\/joy.rs b\/rustzx-test\/tests\/joy.rs\nnew file mode 100644\nindex 0000000..814be1a\n--- \/dev\/null\n+++ b\/rustzx-test\/tests\/joy.rs\n@@ -0,0 +1,118 @@\n+use expect_test::expect;\n+use rustzx_core::{\n+    zx::{\n+        joy::{\n+            kempston::KempstonKey,\n+            sinclair::{SinclairJoyNum, SinclairKey},\n+        },\n+        keys::{CompoundKey, ZXKey},\n+    },\n+    IterableEnum,\n+};\n+use rustzx_test::framework::{presets, RustZXTester};\n+\n+#[test]\n+fn kempston_joy() {\n+    let mut settings = presets::settings_48k_nosound();\n+    settings.kempston_enabled = true;\n+    let mut t = RustZXTester::new(\"kempston_joy\", settings);\n+    t.enable_debug_port();\n+    t.load_sna(\"kempston_joy.48k.sna.gz\");\n+\n+    let mut out = String::new();\n+\n+    \/\/ Check emulator initial state (all bits should set to 0)\n+    t.sync_target();\n+    t.emulate_frame();\n+    out += &t.debug_port().take_text();\n+\n+    let keys = KempstonKey::iter().collect::<Vec<_>>();\n+\n+    \/\/ Press all sequential\n+    for k in &keys {\n+        t.emulator().send_kempston_key(*k, true);\n+        t.sync_target();\n+        t.emulate_frame();\n+        out += &t.debug_port().take_text();\n+    }\n+\n+    \/\/ Release all sequential\n+    for k in &keys {\n+        t.emulator().send_kempston_key(*k, false);\n+        t.sync_target();\n+        t.emulate_frame();\n+        out += &t.debug_port().take_text();\n+    }\n+\n+    expect![[r#\"00,01,03,07,0F,1F,3F,7F,FF,FE,FC,F8,F0,E0,C0,80,00,\"#]].assert_eq(&out);\n+}\n+\n+#[test]\n+fn sinclair_joy() {\n+    let mut t = RustZXTester::new(\"sinclair_joy\", presets::settings_48k_nosound());\n+    t.enable_debug_port();\n+    \/\/ We use keyboard SNA here because technically, sinclair joystick emulates key presses\n+    t.load_sna(\"keyboard.48k.sna.gz\");\n+\n+    let mut out = String::new();\n+\n+    let joys = SinclairJoyNum::iter().collect::<Vec<_>>();\n+    let buttons = SinclairKey::iter().collect::<Vec<_>>();\n+\n+    for joy in joys {\n+        out += &format!(\"JOY_BUTTONS({:?})\\n\", joy);\n+        for button in &buttons {\n+            t.emulator().send_sinclair_key(joy, *button, true);\n+            t.sync_target();\n+            t.emulate_frame();\n+            out += &t.debug_port().take_text();\n+            t.emulator().send_sinclair_key(joy, *button, false);\n+        }\n+    }\n+\n+    out += \"SIMULTANEOUS\\n\";\n+    t.emulator()\n+        .send_sinclair_key(SinclairJoyNum::Fist, SinclairKey::Right, true);\n+    t.emulator()\n+        .send_sinclair_key(SinclairJoyNum::Second, SinclairKey::Left, true);\n+    t.sync_target();\n+    t.emulate_frame();\n+    out += &t.debug_port().take_text();\n+    t.emulator()\n+        .send_sinclair_key(SinclairJoyNum::Fist, SinclairKey::Right, false);\n+    t.emulator()\n+        .send_sinclair_key(SinclairJoyNum::Second, SinclairKey::Left, false);\n+\n+    out += \"WITH_OTHER_KEYS\\n\";\n+    t.emulator()\n+        .send_sinclair_key(SinclairJoyNum::Fist, SinclairKey::Fire, true);\n+    t.emulator()\n+        .send_sinclair_key(SinclairJoyNum::Fist, SinclairKey::Left, true);\n+    t.emulator()\n+        .send_sinclair_key(SinclairJoyNum::Second, SinclairKey::Fire, true);\n+    t.emulator().send_key(ZXKey::A, true); \/\/ unrelated key\n+    t.emulator().send_key(ZXKey::N5, true); \/\/ overlaps with joy key\n+    t.emulator().send_compound_key(CompoundKey::Delete, true); \/\/ overlaps with joy key (N0)\n+    t.emulator().send_compound_key(CompoundKey::Break, true); \/\/ unrelated compound key\n+    t.sync_target();\n+    t.emulate_frame();\n+    out += &t.debug_port().take_text();\n+    \/\/ Check that joy key release does not clear unrelated keys\/compound keys\n+    t.emulator()\n+        .send_sinclair_key(SinclairJoyNum::Fist, SinclairKey::Fire, false);\n+    t.emulator()\n+        .send_sinclair_key(SinclairJoyNum::Fist, SinclairKey::Left, false);\n+    t.emulator()\n+        .send_sinclair_key(SinclairJoyNum::Second, SinclairKey::Fire, false);\n+    t.sync_target();\n+    t.emulate_frame();\n+    out += &t.debug_port().take_text();\n+\n+    \/\/ Expect full key press\/release log. See reasoning about comparing hashes\n+    \/\/ in keyboard.rs\n+    t.expect_text(\n+        \"log\",\n+        out,\n+        expect![[r#\"F6bYEdfQ8M9gpyCivt2vuKMws83uDEmuB3Q7OQlXucU=\"#]],\n+    );\n+}\ndiff --git a\/rustzx-test\/tests\/keyboard.rs b\/rustzx-test\/tests\/keyboard.rs\nnew file mode 100644\nindex 0000000..37255b2\n--- \/dev\/null\n+++ b\/rustzx-test\/tests\/keyboard.rs\n@@ -0,0 +1,117 @@\n+use expect_test::expect;\n+use rustzx_core::{\n+    zx::keys::{CompoundKey, ZXKey},\n+    IterableEnum,\n+};\n+use rustzx_test::framework::{presets, RustZXTester};\n+\n+#[test]\n+fn standard_keys() {\n+    let mut t = RustZXTester::new(\"standard_keys\", presets::settings_48k_nosound());\n+    t.enable_debug_port();\n+    t.load_sna(\"keyboard.48k.sna.gz\");\n+\n+    let mut out = String::new();\n+\n+    \/\/ Check emulator initial state (all bits should set to 1)\n+    t.sync_target();\n+    t.emulate_frame();\n+    out += &t.debug_port().take_text();\n+\n+    let keys = ZXKey::iter().collect::<Vec<_>>();\n+\n+    \/\/ Press all sequential\n+    for k in &keys {\n+        t.emulator().send_key(*k, true);\n+        t.sync_target();\n+        t.emulate_frame();\n+        out += &t.debug_port().take_text();\n+    }\n+\n+    \/\/ Release all sequential\n+    for k in &keys {\n+        t.emulator().send_key(*k, false);\n+        t.sync_target();\n+        t.emulate_frame();\n+        out += &t.debug_port().take_text();\n+    }\n+\n+    \/\/ Expect full key press\/release log. Here we just compare hashes because\n+    \/\/ keyboard input log is too big to inline it directly into the test file\n+    t.expect_text(\n+        \"log\",\n+        out,\n+        expect![[r#\"lF44fsm0VLApiGX1LTQOYRgj40hPrX9L5SaA3nF\/i6w=\"#]],\n+    );\n+}\n+\n+#[test]\n+fn compound_keys() {\n+    let mut t = RustZXTester::new(\"compound_keys\", presets::settings_48k_nosound());\n+    t.enable_debug_port();\n+    t.load_sna(\"keyboard.48k.sna.gz\");\n+\n+    let mut out = String::from(\"SEQUENTIAL\\n\");\n+\n+    let keys = CompoundKey::iter().collect::<Vec<_>>();\n+\n+    let mut prev = None;\n+\n+    \/\/ Separate key presses\n+    for k in &keys {\n+        if let Some(prev) = prev {\n+            t.emulator().send_compound_key(prev, false);\n+        }\n+        t.emulator().send_compound_key(*k, true);\n+        t.sync_target();\n+        t.emulate_frame();\n+        out += &t.debug_port().take_text();\n+        prev = Some(*k);\n+    }\n+\n+    \/\/ Reset keyboard to its initial state by releasing last pressed key\n+    \/\/ and write this initial state to the log\n+    out += \"INITIAL\\n\";\n+    t.emulator().send_compound_key(prev.unwrap(), false);\n+    t.sync_target();\n+    t.emulate_frame();\n+    out += &t.debug_port().take_text();\n+\n+    \/\/ Check that simultaneously pressed compound keys do not cancel each other.\n+    \/\/ resulting keyboard state should be logical \"AND\" (because keys are inversed)\n+    out += \"SIMULTANEOUS\\n\";\n+    t.emulator().send_compound_key(CompoundKey::ArrowLeft, true);\n+    t.emulator()\n+        .send_compound_key(CompoundKey::ArrowRight, true);\n+    t.sync_target();\n+    t.emulate_frame();\n+    out += &t.debug_port().take_text();\n+    t.emulator()\n+        .send_compound_key(CompoundKey::ArrowLeft, false);\n+    t.emulator()\n+        .send_compound_key(CompoundKey::ArrowRight, false);\n+\n+    \/\/ Check that compound keys can be pressed simulateneously with standard keys\n+    out += \"WITH_STANDARD\\n\";\n+    t.emulator().send_compound_key(CompoundKey::ArrowLeft, true);\n+    t.emulator().send_key(ZXKey::N5, true); \/\/ overlaps with compound\n+    t.emulator().send_key(ZXKey::A, true); \/\/ unrelated key\n+    t.sync_target();\n+    t.emulate_frame();\n+    \/\/ After releasing compound key, overlapping standard key N5 should be still\n+    \/\/ notified by the emualtor as pressed\n+    t.emulator()\n+        .send_compound_key(CompoundKey::ArrowLeft, false);\n+    out += &t.debug_port().take_text();\n+    t.sync_target();\n+    t.emulate_frame();\n+    out += &t.debug_port().take_text();\n+\n+    \/\/ Expect full key press\/release log. Here we just compare hashes because\n+    \/\/ keyboard input log is too big to inline it directly into the test file\n+    t.expect_text(\n+        \"log\",\n+        out,\n+        expect![[r#\"v01HM6RHAtHfvFEnvCXae4dl1FrHEISrnDgljzvMcoE=\"#]],\n+    );\n+}\ndiff --git a\/rustzx-test\/tests\/mouse.rs b\/rustzx-test\/tests\/mouse.rs\nnew file mode 100644\nindex 0000000..da8f36e\n--- \/dev\/null\n+++ b\/rustzx-test\/tests\/mouse.rs\n@@ -0,0 +1,114 @@\n+use expect_test::expect;\n+use rustzx_core::zx::mouse::kempston::{KempstonMouseButton, KempstonMouseWheelDirection};\n+use rustzx_test::framework::{presets, RustZXTester};\n+use std::time::Duration;\n+\n+#[test]\n+fn kempston_mouse() {\n+    let mut settings = presets::settings_48k_nosound();\n+    settings.mouse_enabled = true;\n+\n+    let mut tester = RustZXTester::new(\"kempston_mouse\", settings);\n+    tester.load_sna(\"mouse.48k.sna.gz\");\n+    tester.emulate_for(Duration::from_millis(250));\n+    tester.expect_screen(\n+        \"sna_loaded\",\n+        expect![[r#\"7AVgP7YkJPt4y4x1NnlMyWSo6wntyPaRcrVHBmfSfFk=\"#]],\n+    );\n+\n+    tester.emulator().send_mouse_pos_diff(64, 32);\n+    tester.emulate_for(Duration::from_millis(250));\n+    tester.expect_screen(\n+        \"cursor_moved_1\",\n+        expect![[r#\"KXWv0nZ+P2\/PCWAWXh0eIOsncVrPISgYqggniZifLQs=\"#]],\n+    );\n+\n+    tester.emulator().send_mouse_pos_diff(-48, -16);\n+    tester.emulate_for(Duration::from_millis(250));\n+    tester.expect_screen(\n+        \"cursor_moved_2\",\n+        expect![[r#\"HUIX0sv7yUhYjAU6rNxF4ODzLhm5WYGgyHKcJ3z0EuI=\"#]],\n+    );\n+\n+    tester\n+        .emulator()\n+        .send_mouse_button(KempstonMouseButton::Left, true);\n+    tester.emulate_for(Duration::from_millis(250));\n+    tester.expect_screen(\n+        \"left_pressed\",\n+        expect![[r#\"zJJGnWCk90irqNKUEeEAMoYxutt2sI6b1oaFN9sRWmA=\"#]],\n+    );\n+    tester\n+        .emulator()\n+        .send_mouse_button(KempstonMouseButton::Left, false);\n+\n+    tester\n+        .emulator()\n+        .send_mouse_button(KempstonMouseButton::Right, true);\n+    tester.emulate_for(Duration::from_millis(250));\n+    tester.expect_screen(\n+        \"right_pressed\",\n+        expect![[r#\"WDsRHUt7EzlfGvlPMOsPvmCzdP0ob15l5FARzE390b8=\"#]],\n+    );\n+    tester\n+        .emulator()\n+        .send_mouse_button(KempstonMouseButton::Right, false);\n+\n+    tester\n+        .emulator()\n+        .send_mouse_button(KempstonMouseButton::Middle, true);\n+    tester.emulate_for(Duration::from_millis(250));\n+    tester.expect_screen(\n+        \"middle_pressed\",\n+        expect![[r#\"RaAwafxap1fFOUTBOeaNHlSgIEW+kRN41umpEc\/ccdk=\"#]],\n+    );\n+    tester\n+        .emulator()\n+        .send_mouse_button(KempstonMouseButton::Middle, false);\n+\n+    tester\n+        .emulator()\n+        .send_mouse_button(KempstonMouseButton::Additional, true);\n+    tester.emulate_for(Duration::from_millis(250));\n+    tester.expect_screen(\n+        \"ext_pressed\",\n+        expect![[r#\"ffhRpkdMjqHxAns5Wb40Sp2IzMR6gYuxJXrRiOB7ZNQ=\"#]],\n+    );\n+    tester\n+        .emulator()\n+        .send_mouse_button(KempstonMouseButton::Additional, false);\n+\n+    (0..10).for_each(|_| {\n+        tester\n+            .emulator()\n+            .send_mouse_wheel(KempstonMouseWheelDirection::Down)\n+    });\n+    tester.emulate_for(Duration::from_millis(250));\n+    (0..10).for_each(|_| {\n+        tester\n+            .emulator()\n+            .send_mouse_wheel(KempstonMouseWheelDirection::Down)\n+    });\n+    tester.emulate_for(Duration::from_millis(250));\n+    tester.expect_screen(\n+        \"wheel_2\",\n+        expect![[r#\"oeQS+og5xrGSyz3Zk+f3L4U93aB2azba0jl0mVU96xI=\"#]],\n+    );\n+\n+    (0..10).for_each(|_| {\n+        tester\n+            .emulator()\n+            .send_mouse_wheel(KempstonMouseWheelDirection::Up)\n+    });\n+    tester.emulate_for(Duration::from_millis(250));\n+    (0..10).for_each(|_| {\n+        tester\n+            .emulator()\n+            .send_mouse_wheel(KempstonMouseWheelDirection::Up)\n+    });\n+    tester.emulate_for(Duration::from_millis(250));\n+    tester.expect_screen(\n+        \"wheel_3\",\n+        expect![[r#\"I+2mija0+YU60eHjAehkN9MpfgMli2ym7pMoChVbcFo=\"#]],\n+    );\n+}\ndiff --git a\/rustzx-test\/tests\/sound.rs b\/rustzx-test\/tests\/sound.rs\nnew file mode 100644\nindex 0000000..7309e0a\n--- \/dev\/null\n+++ b\/rustzx-test\/tests\/sound.rs\n@@ -0,0 +1,27 @@\n+use expect_test::expect;\n+use rustzx_test::framework::{presets, RustZXTester};\n+use std::time::Duration;\n+\n+#[test]\n+fn sound_48k() {\n+    let mut tester = RustZXTester::new(\"sound_48k\", presets::settings_48k());\n+    tester.load_sna(\"sound.48k.sna.gz\");\n+    tester.start_sound_capture();\n+    tester.emulate_for(Duration::from_secs(2));\n+    tester.expect_sound(\n+        \"beeper_plus_ay\",\n+        expect![[r#\"bEAIV7LVE7591l6VUrCE1ySbEyBSNeVwLjWhDm9Jlpc=\"#]],\n+    );\n+}\n+\n+#[test]\n+fn sound_128k() {\n+    let mut tester = RustZXTester::new(\"sound_128k\", presets::settings_128k());\n+    tester.load_sna(\"sound.128k.sna.gz\");\n+    tester.start_sound_capture();\n+    tester.emulate_for(Duration::from_secs(2));\n+    tester.expect_sound(\n+        \"beeper_plus_ay\",\n+        expect![[r#\"u8WCHu89dFvnMInLGaDFV4ha6FatBtXLJ6szqiUg+ys=\"#]],\n+    );\n+}\ndiff --git a\/rustzx-test\/tests\/tape.rs b\/rustzx-test\/tests\/tape.rs\nnew file mode 100644\nindex 0000000..f1d615f\n--- \/dev\/null\n+++ b\/rustzx-test\/tests\/tape.rs\n@@ -0,0 +1,229 @@\n+use expect_test::expect;\n+use rustzx_core::zx::keys::ZXKey;\n+use rustzx_test::framework::{presets, RustZXTester};\n+use std::time::Duration;\n+\n+#[test]\n+fn no_fastload() {\n+    let mut settings = presets::settings_48k_nosound();\n+    settings.tape_fastload_enabled = false;\n+    settings.autoload_enabled = false;\n+\n+    let mut tester = RustZXTester::new(\"no_fastload\", settings);\n+    tester.load_tap(\"simple_tape.tap.gz\");\n+    \/\/ Wait for ROM to load\n+    tester.emulate_for(Duration::from_millis(2000));\n+    \/\/ Emulate LOAD \"\"\n+    tester.send_keystrokes(\n+        &[\n+            &[ZXKey::J],\n+            &[ZXKey::SymShift, ZXKey::P],\n+            &[ZXKey::SymShift, ZXKey::P],\n+            &[ZXKey::Enter],\n+        ],\n+        Duration::from_millis(100),\n+    );\n+\n+    \/\/ Check that tape is not loading until signaled manually\n+    tester.emulate_for(Duration::from_millis(100));\n+    tester.expect_screen(\n+        \"empty\",\n+        expect![[r#\"nI+vo8GaRwKwWTPTP2f22Wcgm9nEwMlm16+Cmzird2w=\"#]],\n+    );\n+    tester.expect_border(\n+        \"empty\",\n+        expect![[r#\"CkU7FUXUKUZneunabAn\/h+88EDIxzvO1aqCl5LadYEs=\"#]],\n+    );\n+\n+    tester.emulator().play_tape();\n+    tester.emulate_for(Duration::from_millis(2000));\n+\n+    \/\/ Check tack tape is started loading\n+    tester.expect_border(\n+        \"sync_pulses\",\n+        expect![[r#\"Oc++rVrRSea7L5+dCz066kS\/mPzhKZ8MhhvVo+8r5iY=\"#]],\n+    );\n+\n+    \/\/ Check that data block started loading\n+    tester.emulate_for(Duration::from_millis(3100));\n+    tester.expect_border(\n+        \"data_pulses\",\n+        expect![[r#\"pf8oQYn3t7yAJuLr0MjOpROdoDJ1wK1CsqQvsasuDew=\"#]],\n+    );\n+\n+    \/\/ Check that Loader has been loaded\n+    tester.emulate_for(Duration::from_millis(100));\n+    tester.expect_screen(\n+        \"block_1\",\n+        expect![[r#\"+o3MYnfBeDMtimIE\/+6+o2\/9h1OgtZ8izbO7b\/jOiMc=\"#]],\n+    );\n+\n+    \/\/ Check that second block has been loaded.\n+    tester.emulate_for(Duration::from_millis(45000));\n+    tester.expect_border(\n+        \"end\",\n+        expect![[r#\"tmGY7e4h+XA3px6BcqnCXF83NEdBqVw8PW9sQtpMAvM=\"#]],\n+    );\n+    tester.expect_screen(\n+        \"block_2\",\n+        expect![[r#\"zDQzdQr19uTYaZouk7ex+pkylk2TRFAuenooMVFjkyQ=\"#]],\n+    );\n+}\n+\n+#[test]\n+fn no_fastload_128k() {\n+    let mut settings = presets::settings_128k_nosound();\n+    settings.tape_fastload_enabled = false;\n+    settings.autoload_enabled = false;\n+\n+    let mut tester = RustZXTester::new(\"no_fastload_128k\", settings);\n+    tester.load_tap(\"simple_tape.tap.gz\");\n+    \/\/ Wait for ROM to load\n+    tester.emulate_for(Duration::from_millis(3000));\n+\n+    \/\/ Emulate Enter keypress to load tape\n+    tester.send_keystrokes(&[&[ZXKey::Enter]], Duration::from_millis(100));\n+\n+    \/\/ Check that tape is not loading until signaled manually\n+    tester.emulate_for(Duration::from_millis(100));\n+    tester.expect_screen(\n+        \"ready_to_load\",\n+        expect![[r#\"jSZUNHDpTpRwuQydjVmchehIKSlgP+bhcKE8bi+yZoc=\"#]],\n+    );\n+    tester.expect_border(\n+        \"ready_to_load\",\n+        expect![[r#\"CkU7FUXUKUZneunabAn\/h+88EDIxzvO1aqCl5LadYEs=\"#]],\n+    );\n+\n+    tester.emulator().play_tape();\n+    tester.emulate_for(Duration::from_millis(2000));\n+\n+    \/\/ Check tack tape is started loading\n+    tester.expect_border(\n+        \"sync_pulses\",\n+        expect![[r#\"lbeRI1CgCfyRmOpuVsyzKEzvnnJe\/3CZJUj+BEaypwE=\"#]],\n+    );\n+\n+    \/\/ Check that data block started loading\n+    tester.emulate_for(Duration::from_millis(3000));\n+    tester.expect_border(\n+        \"data_pulses\",\n+        expect![[r#\"TCEfW\/Ng3an2OgjmHdfYMvSdUVUt3RuEw+kYGgoEIh8=\"#]],\n+    );\n+\n+    \/\/ Check that Loader has been loaded\n+    tester.emulate_for(Duration::from_millis(100));\n+    tester.expect_screen(\n+        \"block_1\",\n+        expect![[r#\"FfpfX8Nl7RPODebDhyDPqEpNWieSSG7PYBXvg9ty7k0=\"#]],\n+    );\n+\n+    \/\/ Switching to the next block is already tested by `no_fastload` test, therefore\n+    \/\/ we can skip this for 128K test\n+}\n+\n+#[test]\n+fn tape_stop() {\n+    let mut settings = presets::settings_48k_nosound();\n+    settings.tape_fastload_enabled = false;\n+    settings.autoload_enabled = false;\n+\n+    let mut tester = RustZXTester::new(\"tape_stop\", settings);\n+    tester.load_tap(\"simple_tape.tap.gz\");\n+    \/\/ Wait for ROM to load\n+    tester.emulate_for(Duration::from_millis(2000));\n+    \/\/ Emulate LOAD \"\"\n+    tester.send_keystrokes(\n+        &[\n+            &[ZXKey::J],\n+            &[ZXKey::SymShift, ZXKey::P],\n+            &[ZXKey::SymShift, ZXKey::P],\n+            &[ZXKey::Enter],\n+        ],\n+        Duration::from_millis(100),\n+    );\n+\n+    tester.emulator().play_tape();\n+    tester.emulate_for(Duration::from_millis(2000));\n+\n+    \/\/ Check tack tape is started loading\n+    tester.expect_border(\n+        \"sync_pulses\",\n+        expect![[r#\"Oc++rVrRSea7L5+dCz066kS\/mPzhKZ8MhhvVo+8r5iY=\"#]],\n+    );\n+\n+    \/\/ Check that stop actually stopped tape loading\n+    tester.emulator().stop_tape();\n+    tester.emulate_for(Duration::from_millis(100));\n+    tester.expect_border(\n+        \"stopped\",\n+        expect![[r#\"rIAW+jIqzRy5w0Xd+cqKAa6JVIgUhU5eTCvJ\/kTmLuw=\"#]],\n+    );\n+}\n+\n+#[test]\n+fn tape_rewind() {\n+    let mut settings = presets::settings_48k_nosound();\n+    settings.tape_fastload_enabled = false;\n+    settings.autoload_enabled = false;\n+\n+    let mut tester = RustZXTester::new(\"tape_rewind\", settings);\n+    tester.load_tap(\"simple_tape.tap.gz\");\n+    \/\/ Play tape for some time while ROM loads\n+    tester.emulator().play_tape();\n+    tester.emulate_for(Duration::from_millis(4000));\n+    \/\/ Emulate LOAD \"\"\n+    tester.send_keystrokes(\n+        &[\n+            &[ZXKey::J],\n+            &[ZXKey::SymShift, ZXKey::P],\n+            &[ZXKey::SymShift, ZXKey::P],\n+            &[ZXKey::Enter],\n+        ],\n+        Duration::from_millis(100),\n+    );\n+\n+    tester.emulator().rewind_tape().unwrap();\n+    tester.emulate_for(Duration::from_millis(8000));\n+\n+    \/\/ Check tack tape is started loading after rewind\n+    tester.expect_screen(\n+        \"loaded\",\n+        expect![[r#\"+o3MYnfBeDMtimIE\/+6+o2\/9h1OgtZ8izbO7b\/jOiMc=\"#]],\n+    );\n+}\n+\n+#[test]\n+fn fastload() {\n+    let mut tester = RustZXTester::new(\"fastload\", presets::settings_48k_nosound());\n+    tester.load_tap(\"simple_tape.tap.gz\");\n+    tester.emulate_for(Duration::from_millis(45));\n+    tester.expect_screen(\n+        \"running\",\n+        expect![[r#\"zoRX\/GvcS0zqOJj3V0cmoZe56CNK2nXiJeH8pF8u1eg=\"#]],\n+    );\n+    tester.emulate_for(Duration::from_millis(10));\n+    tester.expect_screen(\n+        \"finished\",\n+        expect![[r#\"zDQzdQr19uTYaZouk7ex+pkylk2TRFAuenooMVFjkyQ=\"#]],\n+    );\n+    tester.expect_border(\n+        \"finished\",\n+        expect![[r#\"tmGY7e4h+XA3px6BcqnCXF83NEdBqVw8PW9sQtpMAvM=\"#]],\n+    );\n+}\n+\n+#[test]\n+fn fastload_128k() {\n+    let mut tester = RustZXTester::new(\"fastload_128k\", presets::settings_128k_nosound());\n+    tester.load_tap(\"simple_tape.tap.gz\");\n+    tester.emulate_for(Duration::from_millis(100));\n+    tester.expect_screen(\n+        \"loaded\",\n+        expect![[r#\"zDQzdQr19uTYaZouk7ex+pkylk2TRFAuenooMVFjkyQ=\"#]],\n+    );\n+    tester.expect_border(\n+        \"loaded\",\n+        expect![[r#\"tmGY7e4h+XA3px6BcqnCXF83NEdBqVw8PW9sQtpMAvM=\"#]],\n+    );\n+}\n","problem_statement":"Add support for compressed assets (tapes, snapshots)\nAdd support for `.gz` compressed assets loading (use `flate2` with miniz_oxide backend)\r\n\r\nAlso, use `.gz` for test assets to minimize repository assets footprint.\n","hints_text":"","created_at":1631,"merge_commit_sha":"6818e164fae45029bd610f0b3caeb9655e5606c4","ci_name_list":[]}
{"repo":"rustzx\/rustzx","pull_number":84,"instance_id":"rustzx__rustzx-84","issue_numbers":["68"],"base_commit":"53cfe0985162dc3e7f6f64fee77a67e3c08a1b9a","patch":"diff --git a\/.github\/workflows\/ci.yml b\/.github\/workflows\/ci.yml\nindex faad5e4..2573304 100644\n--- a\/.github\/workflows\/ci.yml\n+++ b\/.github\/workflows\/ci.yml\n@@ -11,10 +11,25 @@ env:\n \n jobs:\n   build:\n+    name: \"Build (${{ matrix.os }}-${{ matrix.arch }})\"\n     runs-on: ${{ matrix.os }}\n     strategy:\n       matrix:\n-        os: [ubuntu-latest, windows-latest, macos-latest]\n+        include:\n+          - os: ubuntu-20.04\n+            os_name: linux\n+            executable_suffix: \"\"\n+            arch: amd64\n+          - os: windows-2019\n+            os_name: windows\n+            executable_suffix: \".exe\"\n+            arch: amd64\n+          - os: macos-10.15\n+            os_name: macos\n+            executable_suffix: \"\"\n+            arch: amd64\n+    env:\n+      RUSTFLAGS: -D warnings\n     steps:\n       - uses: actions\/checkout@v2\n       - uses: actions-rs\/toolchain@v1\n@@ -43,13 +58,15 @@ jobs:\n         with:\n           command: build\n           args: --release -p rustzx-core --verbose\n-      - name: Build(rustzx-core) - Without AY\n-        uses: actions-rs\/cargo@v1\n-        with:\n-          command: build\n-          args: --release -p rustzx-core --features without-ay --verbose\n       - name: Test\n         uses: actions-rs\/cargo@v1\n         with:\n           command: test\n           args: --workspace --all-features --verbose\n+      - name: Upload artifacts\n+        uses: actions\/upload-artifact@v2\n+        with:\n+          name: \"rustzx-bin-${{ matrix.os_name }}-${{ matrix.arch }}\"\n+          path: |\n+            target\/release\/rustzx${{ matrix.executable_suffix }}\n+            target\/release\/vtx${{ matrix.executable_suffix }}\ndiff --git a\/.gitignore b\/.gitignore\nindex 2e42fae..39d0eb8 100644\n--- a\/.gitignore\n+++ b\/.gitignore\n@@ -6,10 +6,14 @@\n \n # Executables\n *.exe\n-\r\n-# Backups\r\n-*.bak\r\n+\n+# Backups\n+*.bak\n \n # Generated by Cargo\n \/target\/\n-\/target-install\/\n\\ No newline at end of file\n+\/target-install\/\n+\n+# RustZX-specific\n+*.rustzx.last.sna\n+*.rustzx.prev.sna\ndiff --git a\/CHANGELOG.md b\/CHANGELOG.md\nindex a9c8c88..af9a158 100644\n--- a\/CHANGELOG.md\n+++ b\/CHANGELOG.md\n@@ -1,3 +1,12 @@\n+### RustZX v0.13\n+- **[Feature]** Support for ZX Spectrum 128K SNA variant\n+- **[Feature]** Quick save\/load (`F1`\/`F2` keys) via SNA\n+- **[Feature]** Sinclair joysticks support\n+- **[Feature]** Separate joystick keyboard layout (press `F9` to activate)\n+- **[Feature]** Kempston mouse support (`--mouse`)\n+- **[Fix]** Fixed invalid kempston joystick port\n+- **[Fix]** Fixed missing screen update after SNA loading\n+\n ### RustZX v0.12\n - **[Feature]** Now using rust-only AY sound chip library (`aym`) instead of `libayumi` C library\n - **[Feature]** Added vtx sound format parsing\/playback library `vtx`\ndiff --git a\/Cargo.lock b\/Cargo.lock\nindex 60a8783..e2c4e23 100644\n--- a\/Cargo.lock\n+++ b\/Cargo.lock\n@@ -51,7 +51,7 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"aym\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n dependencies = [\n  \"libm\",\n  \"num-traits\",\n@@ -519,7 +519,7 @@ checksum = \"b9b1a3d5f46d53f4a3478e2be4a5a5ce5108ea58b100dcd139830eae7f79a3a1\"\n \n [[package]]\n name = \"rustzx\"\n-version = \"0.12.0\"\n+version = \"0.13.0\"\n dependencies = [\n  \"anyhow\",\n  \"env_logger\",\n@@ -531,7 +531,7 @@ dependencies = [\n \n [[package]]\n name = \"rustzx-core\"\n-version = \"0.12.0\"\n+version = \"0.13.0\"\n dependencies = [\n  \"aym\",\n  \"bitflags\",\n@@ -743,7 +743,7 @@ checksum = \"5fecdca9a5291cc2b8dcf7dc02453fee791a280f3743cb0905f8822ae463b3fe\"\n \n [[package]]\n name = \"vtx\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n dependencies = [\n  \"aym\",\n  \"byteorder\",\n@@ -757,7 +757,7 @@ dependencies = [\n \n [[package]]\n name = \"vtx-bin\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n dependencies = [\n  \"anyhow\",\n  \"structopt\",\ndiff --git a\/README.md b\/README.md\nindex 9f9b300..0a84556 100644\n--- a\/README.md\n+++ b\/README.md\n@@ -2,6 +2,9 @@ RustZX\n ===============================\n \n [![RustZX CI](https:\/\/github.com\/pacmancoder\/rustzx\/actions\/workflows\/ci.yml\/badge.svg)](https:\/\/github.com\/pacmancoder\/rustzx\/actions\/workflows\/ci.yml)\n+[![Crates.io](https:\/\/img.shields.io\/crates\/v\/rustzx)](https:\/\/crates.io\/crates\/rustzx)\n+[![License](https:\/\/img.shields.io\/crates\/l\/rustzx)](https:\/\/github.com\/pacmancoder\/rustzx\/blob\/master\/LICENSE.md)\n+[![Discord](https:\/\/img.shields.io\/discord\/844696167794475009?logo=discord&logoColor=white)](https:\/\/discord.gg\/aSHJh8UJre)\n \n ![logo](assets\/logo_small.png)\n \n@@ -16,11 +19,14 @@ ZX Spectrum emulator written in Rust\n - Perfect emulation of Z80 core\n - Highly precise AY chip emulation\n - Beeper sound emulation\n-- Supported formats: TAP, SNA\n+- Supported formats: TAP, SNA (both 48K and 128K version)\n - Fast loading of tap files with standard loader\n - Precise timings\n - Full border emulation\n-- Joystick emulation: Kempston\n+- Joystick emulation: Kempston, Sinclair\n+- Kempston mouse emulation\n+- Extended 128K keys emulation (arrows, backspace, caps lock)\n+- Quick save\/load\n - Separate `no_std` core library which can be used to port emulator\n   almost anywhere.\n     - Global allocator is still needed, but all dynamic\n@@ -43,6 +49,7 @@ rustzx --ay test.tap # Run in 48K mode with AY sound chip\n rustzx -m128 --tape test128.tap # Run in 128K mode with tape\n rustzx --rom tester.rom -s3 # Run with custom rom and 3x screen scaling\n rustzx --nofastload test.tap # Run without fast tape loading\n+rustzx --mouse test.tap # Run with Kempston mouse support\n ```\n For loading tape in 48K mode, press `j` then `Ctrl+p` twice, as on real Spectrum.\n You should see `LOAD \"\"` on emulator's screen, then press `Enter` (in 128K mode just press enter).\n@@ -50,8 +57,29 @@ In `--nofastload` mode, press `Insert` to play the tape and `Delete` to stop\n \n If you have choppy audio, try `--sound-latency` option with bigger values.\n \n-Use keys `F3 - F5` to set speed of emulation - this can be usefull when skipping some boring stuff.\n-Use `F6` to display FPS in window title.\n+## Default key bindings:\n+- `F1` - quick save\n+- `F2` - quick load\n+- `F3` - set normal emulation speed\n+- `F4` - set 2x emulation speed\n+- `F5` - max possible emulation speed\n+- `F6` - enable frame trace info\n+- `F9` - enable kempston\/sinclair joy keyboard layer\n+- `Insert` - start tape\n+- `Delete`- stop tape\n+- `End` - break command\n+- `Caps Lock` - caps lock command\n+- `Backspace` - delete\n+- `<Arrows>` - 128K arrow keys\n+- `Esc` - unlock mouse (if `--mouse` is used)\n+\n+## In joy keyboard layer mode (F9)\n+- `<Arrows>` - Kempston joy *arrows*\n+- `Alt` - Kempston *fire*\n+- `WASD`- Siclair Joy 1 *arrows*\n+- `Caps Lock` - Sinclair Joy 1 *fire*\n+- `IJKL`- Siclair Joy 2 *arrows*\n+- `Enter` - Sinclair Joy 2 *fire*\n \n ## Screenshots\n ![](screenshots\/rain.png)\ndiff --git a\/aym\/Cargo.toml b\/aym\/Cargo.toml\nindex 839476b..2dcdb10 100644\n--- a\/aym\/Cargo.toml\n+++ b\/aym\/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"aym\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n description = \"AY\/YM sound chip emulation library\"\n authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n license = \"MIT\"\ndiff --git a\/aym\/src\/backends\/precise.rs b\/aym\/src\/backends\/precise.rs\nindex b7959fc..5972bc3 100644\n--- a\/aym\/src\/backends\/precise.rs\n+++ b\/aym\/src\/backends\/precise.rs\n@@ -7,12 +7,12 @@ const DC_FILTER_SIZE: usize = 1024;\n \n #[derive(Default)]\n struct ToneChannel {\n-    tone_period: usize,\n-    tone_counter: usize,\n+    tone_period: u16,\n+    tone_counter: u16,\n     tone: usize,\n-    t_off: usize,\n-    n_off: usize,\n-    e_on: usize,\n+    tone_off_bit: usize,\n+    noise_off_bit: usize,\n+    envelope_enabled: bool,\n     volume: usize,\n     pan_left: f64,\n     pan_right: f64,\n@@ -46,27 +46,34 @@ impl Default for DcFilter {\n \/\/\/ Uses f64 for computations.\n pub struct AymPrecise {\n     channels: [ToneChannel; TONE_CHANNELS],\n-    noise_period: usize,\n-    noise_counter: usize,\n+\n+    noise_period: u16,\n+    noise_counter: u16,\n     noise: usize,\n-    envelope_counter: usize,\n-    envelope_period: usize,\n+\n+    envelope_counter: u16,\n+    envelope_period: u16,\n     envelope_shape: usize,\n     envelope_segment: usize,\n     envelope: usize,\n+\n     dac_table: &'static [f64; 32],\n     step: f64,\n     x: f64,\n     interpolator_left: Interpolator,\n     interpolator_right: Interpolator,\n+\n     fir_left: [f64; FIR_SIZE * 2],\n     fir_right: [f64; FIR_SIZE * 2],\n     fir_index: usize,\n+\n     dc_left: DcFilter,\n     dc_right: DcFilter,\n     dc_index: usize,\n+\n     left: f64,\n     right: f64,\n+\n     registers: [u8; AY_REGISTER_COUNT],\n     dc_filter: bool,\n }\n@@ -200,28 +207,33 @@ impl AymPrecise {\n         }\n     }\n \n-    fn set_tone(&mut self, index: usize, period: usize) {\n+    fn set_tone(&mut self, index: usize, period: u16) {\n         let period = period & 0xFFF;\n-        self.channels[index].tone_period = (period == 0) as usize | period;\n+        self.channels[index].tone_period = (period == 0) as u16 | period;\n     }\n \n-    fn set_noise(&mut self, period: usize) {\n+    fn set_noise(&mut self, period: u16) {\n         self.noise_period = period & 0x1F;\n     }\n \n-    fn set_mixer(&mut self, index: usize, t_off: usize, n_off: usize, e_on: usize) {\n-        self.channels[index].t_off = t_off & 1;\n-        self.channels[index].n_off = n_off & 1;\n-        self.channels[index].e_on = e_on;\n+    fn set_mixer(\n+        &mut self,\n+        index: usize,\n+        tone_enable: bool,\n+        noise_enable: bool,\n+        envelope_enabled: bool,\n+    ) {\n+        self.channels[index].tone_off_bit = (!tone_enable) as usize;\n+        self.channels[index].noise_off_bit = (!noise_enable) as usize;\n+        self.channels[index].envelope_enabled = envelope_enabled;\n     }\n \n     fn set_volume(&mut self, index: usize, volume: usize) {\n         self.channels[index].volume = volume & 0x0F;\n     }\n \n-    fn set_envelope(&mut self, period: usize) {\n-        let period = period & 0xFFFF;\n-        self.envelope_period = (period == 0) as usize | period;\n+    fn set_envelope(&mut self, period: u16) {\n+        self.envelope_period = (period == 0) as u16 | period;\n     }\n \n     fn set_envelope_shape(&mut self, shape: usize) {\n@@ -343,13 +355,14 @@ impl AymPrecise {\n         self.left = 0.0;\n         self.right = 0.0;\n         for i in 0..TONE_CHANNELS {\n-            let mut out =\n-                (self.update_tone(i) | self.channels[i].t_off) & (noise | self.channels[i].n_off);\n-            out *= if self.channels[i].e_on != 0 {\n+            let mut out = (self.update_tone(i) | self.channels[i].tone_off_bit)\n+                & (noise | self.channels[i].noise_off_bit);\n+            out *= if self.channels[i].envelope_enabled {\n                 envelope\n             } else {\n                 self.channels[i].volume * 2 + 1\n             };\n+            assert!(out < 32);\n             self.left += self.dac_table[out] * self.channels[i].pan_left;\n             self.right += self.dac_table[out] * self.channels[i].pan_right;\n         }\n@@ -358,6 +371,8 @@ impl AymPrecise {\n \n #[allow(clippy::excessive_precision)]\n fn decimate(x: &mut [f64]) -> f64 {\n+    assert!(x.len() >= FIR_SIZE);\n+\n     let y = -0.0000046183113992051936 * (x[1] + x[191])\n         + -0.00001117761640887225 * (x[2] + x[190])\n         + -0.000018610264502005432 * (x[3] + x[189])\n@@ -494,58 +509,58 @@ impl AymBackend for AymPrecise {\n         let r = self.registers;\n \n         match address {\n-            0 | 1 => self.set_tone(0, u16::from_le_bytes([r[0], r[1] & 0x0f]) as usize),\n-            2 | 3 => self.set_tone(1, u16::from_le_bytes([r[2], r[3] & 0x0f]) as usize),\n-            4 | 5 => self.set_tone(2, u16::from_le_bytes([r[4], r[5] & 0x0f]) as usize),\n-            6 => self.set_noise((r[6] & 0x1f) as usize),\n+            0 | 1 => self.set_tone(0, u16::from_le_bytes([r[0], r[1] & 0x0f])),\n+            2 | 3 => self.set_tone(1, u16::from_le_bytes([r[2], r[3] & 0x0f])),\n+            4 | 5 => self.set_tone(2, u16::from_le_bytes([r[4], r[5] & 0x0f])),\n+            6 => self.set_noise((r[6] & 0x1f) as u16),\n             7 => {\n                 self.set_mixer(\n                     0,\n-                    ((r[7] & 0x01) != 0) as usize,\n-                    ((r[7] & 0x08) != 0) as usize,\n-                    ((r[8] & 0x10) != 0) as usize,\n+                    (r[7] & 0x01) == 0,\n+                    (r[7] & 0x08) == 0,\n+                    (r[8] & 0x10) != 0,\n                 );\n                 self.set_mixer(\n                     1,\n-                    ((r[7] & 0x02) != 0) as usize,\n-                    ((r[7] & 0x10) != 0) as usize,\n-                    ((r[9] & 0x10) != 0) as usize,\n+                    (r[7] & 0x02) == 0,\n+                    (r[7] & 0x10) == 0,\n+                    (r[9] & 0x10) != 0,\n                 );\n                 self.set_mixer(\n                     2,\n-                    ((r[7] & 0x04) != 0) as usize,\n-                    ((r[7] & 0x20) != 0) as usize,\n-                    ((r[10] & 0x10) != 0) as usize,\n+                    (r[7] & 0x04) == 0,\n+                    (r[7] & 0x20) == 0,\n+                    (r[10] & 0x10) != 0,\n                 );\n             }\n             8 => {\n                 self.set_mixer(\n                     0,\n-                    ((r[7] & 0x01) != 0) as usize,\n-                    ((r[7] & 0x08) != 0) as usize,\n-                    ((r[8] & 0x10) != 0) as usize,\n+                    (r[7] & 0x01) == 0,\n+                    (r[7] & 0x08) == 0,\n+                    (r[8] & 0x10) != 0,\n                 );\n                 self.set_volume(0, (r[8] & 0x0F) as usize);\n             }\n             9 => {\n                 self.set_mixer(\n                     1,\n-                    ((r[7] & 0x02) != 0) as usize,\n-                    ((r[7] & 0x10) != 0) as usize,\n-                    ((r[9] & 0x10) != 0) as usize,\n+                    (r[7] & 0x02) == 0,\n+                    (r[7] & 0x10) == 0,\n+                    (r[9] & 0x10) != 0,\n                 );\n                 self.set_volume(1, (r[9] & 0x0F) as usize);\n             }\n             10 => {\n                 self.set_mixer(\n                     2,\n-                    ((r[7] & 0x04) != 0) as usize,\n-                    ((r[7] & 0x20) != 0) as usize,\n-                    ((r[10] & 0x10) != 0) as usize,\n+                    (r[7] & 0x04) == 0,\n+                    (r[7] & 0x20) == 0,\n+                    (r[10] & 0x10) != 0,\n                 );\n                 self.set_volume(2, (r[10] & 0x0F) as usize);\n             }\n-            11 | 12 => self.set_envelope(u16::from_le_bytes([r[11], r[12]]) as usize),\n+            11 | 12 => self.set_envelope(u16::from_le_bytes([r[11], r[12]])),\n             13 => self.set_envelope_shape((r[13] & 0x0F) as usize),\n             _ => unreachable!(),\n         }\ndiff --git a\/rustzx-core\/Cargo.toml b\/rustzx-core\/Cargo.toml\nindex df9654b..5c2f23c 100644\n--- a\/rustzx-core\/Cargo.toml\n+++ b\/rustzx-core\/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"rustzx-core\"\n-version = \"0.12.0\"\n+version = \"0.13.0\"\n authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n description = \"ZX Spectum emulator core library\"\n repository = \"https:\/\/github.com\/pacmancoder\/rustzx\"\n@@ -10,12 +10,12 @@ edition = \"2018\"\n \n [features]\n default = []\n-full = [\"ay\", \"precise-border\", \"embedded-roms\"]\n-without-ay = [\"sound\", \"precise-border\", \"embedded-roms\"]\n+full = [\"ay\", \"precise-border\", \"embedded-roms\", \"autoload\"]\n precise-border = []\n embedded-roms = []\n sound = []\n ay = [\"aym\", \"sound\"]\n+autoload = []\n \n [dependencies]\n bitflags = \"1\"\n@@ -23,4 +23,4 @@ lazy_static = \"1\"\n displaydoc = { version = \"0.2\", default-features = false }\n from_variants = \"0.6\"\n enum_dispatch = \"0.3\"\n-aym = { version = \"0.1\", path = \"..\/aym\", optional = true}\n+aym = { version = \"0.1.1\", path = \"..\/aym\", optional = true}\ndiff --git a\/rustzx-core\/src\/emulator\/loaders\/mod.rs b\/rustzx-core\/src\/emulator\/loaders\/mod.rs\nindex 5a1edb6..44ad516 100644\n--- a\/rustzx-core\/src\/emulator\/loaders\/mod.rs\n+++ b\/rustzx-core\/src\/emulator\/loaders\/mod.rs\n@@ -1,2 +1,1 @@\n-pub mod sna;\n pub mod tap;\ndiff --git a\/rustzx-core\/src\/emulator\/loaders\/sna.rs b\/rustzx-core\/src\/emulator\/loaders\/sna.rs\ndeleted file mode 100644\nindex 8464cb1..0000000\n--- a\/rustzx-core\/src\/emulator\/loaders\/sna.rs\n+++ \/dev\/null\n@@ -1,62 +0,0 @@\n-use crate::{\n-    emulator::Emulator,\n-    host::{Host, LoadableAsset},\n-    utils::{make_word, Clocks},\n-    z80::{opcodes::execute_pop_16, RegName16},\n-    zx::video::colors::ZXColor,\n-    Result,\n-};\n-\n-\/\/\/ SNA snapshot loading function\n-pub fn load_sna<H: Host>(emulator: &mut Emulator<H>, mut asset: H::SnapshotAsset) -> Result<()> {\n-    const SNA_HEADER_SIZE: usize = 27;\n-    let mut header = [0u8; SNA_HEADER_SIZE];\n-    asset.read_exact(&mut header)?;\n-\n-    \/\/ i-reg\n-    emulator.cpu.regs.set_i(header[0]);\n-    \/\/ alt-regs\n-    emulator.cpu.regs.set_hl(make_word(header[2], header[1]));\n-    emulator.cpu.regs.set_de(make_word(header[4], header[3]));\n-    emulator.cpu.regs.set_bc(make_word(header[6], header[5]));\n-    emulator.cpu.regs.exx();\n-    \/\/ af'\n-    emulator.cpu.regs.set_af(make_word(header[8], header[7]));\n-    emulator.cpu.regs.swap_af_alt();\n-    \/\/ regs\n-    emulator.cpu.regs.set_hl(make_word(header[10], header[9]));\n-    emulator.cpu.regs.set_de(make_word(header[12], header[11]));\n-    emulator.cpu.regs.set_bc(make_word(header[14], header[13]));\n-    \/\/ index regs\n-    emulator.cpu.regs.set_iy(make_word(header[16], header[15]));\n-    emulator.cpu.regs.set_ix(make_word(header[18], header[17]));\n-    \/\/ iff1, iff2\n-    let iff = (header[19] & 0x04) != 0;\n-    emulator.cpu.regs.set_iff1(iff);\n-    emulator.cpu.regs.set_iff2(iff);\n-    \/\/ r\n-    emulator.cpu.regs.set_r(header[20]);\n-    \/\/ af\n-    emulator.cpu.regs.set_af(make_word(header[22], header[21]));\n-    \/\/ sp\n-    emulator.cpu.regs.set_sp(make_word(header[24], header[23]));\n-    \/\/ interrupt mode\n-    emulator.cpu.set_im(header[25] & 0x03);\n-    emulator\n-        .controller\n-        .set_border_color(Clocks(0), ZXColor::from_bits(header[26] & 0x07));\n-    \/\/ ram pages\n-    for page_index in 0..3 {\n-        let page = emulator.controller.memory.ram_page_data_mut(page_index);\n-        asset.read_exact(page)?;\n-    }\n-\n-    \/\/ RET\n-    execute_pop_16(\n-        &mut emulator.cpu,\n-        &mut emulator.controller,\n-        RegName16::PC,\n-        Clocks(0),\n-    );\n-    Ok(())\n-}\ndiff --git a\/rustzx-core\/src\/emulator\/mod.rs b\/rustzx-core\/src\/emulator\/mod.rs\nindex f112991..08c4850 100644\n--- a\/rustzx-core\/src\/emulator\/mod.rs\n+++ b\/rustzx-core\/src\/emulator\/mod.rs\n@@ -1,17 +1,25 @@\n \/\/! Platform-independent high-level Emulator interaction module\n mod loaders;\n+mod snapshot;\n \n use crate::{\n     error::RomLoadError,\n-    host::{Host, LoadableAsset, RomFormat, RomSet, Snapshot, Tape},\n+    host::{\n+        DataRecorder, Host, LoadableAsset, RomFormat, RomSet, SeekableAsset, Snapshot,\n+        SnapshotRecorder, Tape,\n+    },\n     settings::RustzxSettings,\n     utils::EmulationSpeed,\n     z80::Z80,\n     zx::{\n         controller::ZXController,\n         events::EmulationEvents,\n-        joy::kempston::KempstonKey,\n-        keys::ZXKey,\n+        joy::{\n+            kempston::KempstonKey,\n+            sinclair::{SinclairJoyNum, SinclairKey},\n+        },\n+        keys::{CompoundKey, ZXKey},\n+        mouse::kempston::{KempstonMouseButton, KempstonMouseWheelDirection},\n         tape::{Tap, TapeImpl},\n         video::colors::ZXColor,\n     },\n@@ -20,6 +28,8 @@ use crate::{\n \n #[cfg(feature = \"sound\")]\n use crate::zx::sound::sample::SoundSample;\n+#[cfg(feature = \"autoload\")]\n+use crate::{host::BufferCursor, zx::machine::ZXMachine};\n \n use core::time::Duration;\n \n@@ -45,7 +55,7 @@ impl<H: Host> Emulator<H> {\n     \/\/\/ `settings` - emulator settings\n     pub fn new(settings: RustzxSettings, context: H::Context) -> Result<Self> {\n         let speed = settings.emulation_speed;\n-        let fast_load = settings.tape_fastload;\n+        let fast_load = settings.tape_fastload_enabled;\n         #[cfg(feature = \"sound\")]\n         let sound_enabled = settings.sound_enabled;\n \n@@ -92,9 +102,21 @@ impl<H: Host> Emulator<H> {\n         }\n     }\n \n-    pub fn load_snapshot(&mut self, snapshot: Snapshot<H::SnapshotAsset>) -> Result<()> {\n+    pub fn load_snapshot<A>(&mut self, snapshot: Snapshot<A>) -> Result<()>\n+    where\n+        A: LoadableAsset + SeekableAsset,\n+    {\n         match snapshot {\n-            Snapshot::Sna(asset) => loaders::sna::load_sna(self, asset),\n+            Snapshot::Sna(asset) => snapshot::sna::load(self, asset),\n+        }\n+    }\n+\n+    pub fn save_snapshot<R>(&mut self, recorder: SnapshotRecorder<R>) -> Result<()>\n+    where\n+        R: DataRecorder,\n+    {\n+        match recorder {\n+            SnapshotRecorder::Sna(recorder) => snapshot::sna::save(self, recorder),\n         }\n     }\n \n@@ -105,6 +127,16 @@ impl<H: Host> Emulator<H> {\n             }\n         }\n \n+        #[cfg(feature = \"autoload\")]\n+        if self.settings.autoload_enabled {\n+            let snapshot = match self.settings.machine {\n+                ZXMachine::Sinclair48K => &snapshot::autoload::tape::SNAPSHOT_SNA_48K,\n+                ZXMachine::Sinclair128K => &snapshot::autoload::tape::SNAPSHOT_SNA_128K,\n+            };\n+\n+            self.load_snapshot(Snapshot::Sna(BufferCursor::new(snapshot)))?;\n+        }\n+\n         Ok(())\n     }\n \n@@ -151,12 +183,32 @@ impl<H: Host> Emulator<H> {\n         self.controller.send_key(key, pressed);\n     }\n \n-    pub fn send_kempston_key(&mut self, key: KempstonKey, state: bool) {\n+    pub fn send_compound_key(&mut self, key: CompoundKey, pressed: bool) {\n+        self.controller.send_compound_key(key, pressed);\n+    }\n+\n+    pub fn send_kempston_key(&mut self, key: KempstonKey, pressed: bool) {\n         if let Some(joy) = &mut self.controller.kempston {\n-            joy.key(key, state);\n+            joy.key(key, pressed);\n         }\n     }\n \n+    pub fn send_sinclair_key(&mut self, num: SinclairJoyNum, key: SinclairKey, pressed: bool) {\n+        self.controller.send_sinclair_key(num, key, pressed);\n+    }\n+\n+    pub fn send_mouse_button(&mut self, button: KempstonMouseButton, pressed: bool) {\n+        self.controller.send_mouse_button(button, pressed);\n+    }\n+\n+    pub fn send_mouse_wheel(&mut self, dir: KempstonMouseWheelDirection) {\n+        self.controller.send_mouse_wheel(dir);\n+    }\n+\n+    pub fn send_mouse_pos(&mut self, x: i8, y: i8) {\n+        self.controller.send_mouse_pos_diff(x, y);\n+    }\n+\n     #[cfg(feature = \"sound\")]\n     pub fn next_audio_sample(&mut self) -> Option<SoundSample<f32>> {\n         self.controller.mixer.pop()\ndiff --git a\/rustzx-core\/src\/emulator\/snapshot\/autoload\/mod.rs b\/rustzx-core\/src\/emulator\/snapshot\/autoload\/mod.rs\nnew file mode 100644\nindex 0000000..54f2a52\n--- \/dev\/null\n+++ b\/rustzx-core\/src\/emulator\/snapshot\/autoload\/mod.rs\n@@ -0,0 +1,4 @@\n+pub mod tape {\n+    pub const SNAPSHOT_SNA_48K: &[u8] = include_bytes!(\"tape_48k.sna\");\n+    pub const SNAPSHOT_SNA_128K: &[u8] = include_bytes!(\"tape_128k.sna\");\n+}\ndiff --git a\/rustzx-core\/src\/emulator\/snapshot\/autoload\/tape_128k.sna b\/rustzx-core\/src\/emulator\/snapshot\/autoload\/tape_128k.sna\nnew file mode 100644\nindex 0000000..2849c1d\nBinary files \/dev\/null and b\/rustzx-core\/src\/emulator\/snapshot\/autoload\/tape_128k.sna differ\ndiff --git a\/rustzx-core\/src\/emulator\/snapshot\/autoload\/tape_48k.sna b\/rustzx-core\/src\/emulator\/snapshot\/autoload\/tape_48k.sna\nnew file mode 100644\nindex 0000000..9532555\nBinary files \/dev\/null and b\/rustzx-core\/src\/emulator\/snapshot\/autoload\/tape_48k.sna differ\ndiff --git a\/rustzx-core\/src\/emulator\/snapshot\/mod.rs b\/rustzx-core\/src\/emulator\/snapshot\/mod.rs\nnew file mode 100644\nindex 0000000..fdb6b77\n--- \/dev\/null\n+++ b\/rustzx-core\/src\/emulator\/snapshot\/mod.rs\n@@ -0,0 +1,3 @@\n+#[cfg(feature = \"autoload\")]\n+pub mod autoload;\n+pub mod sna;\ndiff --git a\/rustzx-core\/src\/emulator\/snapshot\/sna.rs b\/rustzx-core\/src\/emulator\/snapshot\/sna.rs\nnew file mode 100644\nindex 0000000..f136be6\n--- \/dev\/null\n+++ b\/rustzx-core\/src\/emulator\/snapshot\/sna.rs\n@@ -0,0 +1,273 @@\n+use crate::{\n+    emulator::Emulator,\n+    error::IoError,\n+    host::{DataRecorder, Host, LoadableAsset, SeekFrom, SeekableAsset},\n+    utils::{make_word, split_word, Clocks},\n+    z80::{\n+        opcodes::{execute_pop_16, execute_push_16},\n+        RegName16,\n+    },\n+    zx::{machine::ZXMachine, video::colors::ZXColor},\n+    Result,\n+};\n+\n+const SNA_HEADER_SIZE: usize = 27;\n+const SNA_128K_SECONDARY_HEADER_SIZE: usize = 4;\n+const SNA_48K_SIZE: usize = 49179;\n+const SNA_128K_SECONDARY_HEADER_OFFSET: usize = SNA_48K_SIZE;\n+const SNA_128K_SECONDARY_TAIL_BANKS_OFFSET: usize = 49183;\n+const SNA_128K_PERSISTENT_BANK_0: u8 = 5;\n+const SNA_128K_PERSISTENT_BANK_1: u8 = 2;\n+const SNA_IFF2_BIT_MASK: u8 = 0x04;\n+const SNA_INTERRUPT_MODE_MASK: u8 = 0x03;\n+const SNA_BORDER_COLOR_MASK: u8 = 0x07;\n+const SNA_128K_TAIL_BANKS: &[u8] = &[0, 1, 3, 4, 6, 7];\n+const SNA_PAGINATED_PAGED_BANK_ADDRESS: u16 = 0xFFFF;\n+const SNA_48K_RAM_PAGES_COUNT: u8 = 3;\n+\n+\/\/\/ SNA snapshot loading function\n+pub fn load<H, A>(emulator: &mut Emulator<H>, mut asset: A) -> Result<()>\n+where\n+    H: Host,\n+    A: LoadableAsset + SeekableAsset,\n+{\n+    let size = asset.seek(SeekFrom::End(0))?;\n+    asset.seek(SeekFrom::Start(0))?;\n+\n+    let is_128k = size > SNA_48K_SIZE;\n+\n+    if !is_128k && size < SNA_48K_SIZE {\n+        return Err(IoError::UnexpectedEof.into());\n+    }\n+\n+    let mut header = [0u8; SNA_HEADER_SIZE];\n+    asset.read_exact(&mut header)?;\n+\n+    \/\/ i-reg\n+    emulator.cpu.regs.set_i(header[0]);\n+    \/\/ alt-regs\n+    emulator.cpu.regs.set_hl(make_word(header[2], header[1]));\n+    emulator.cpu.regs.set_de(make_word(header[4], header[3]));\n+    emulator.cpu.regs.set_bc(make_word(header[6], header[5]));\n+    emulator.cpu.regs.exx();\n+    \/\/ af'\n+    emulator.cpu.regs.set_af(make_word(header[8], header[7]));\n+    emulator.cpu.regs.swap_af_alt();\n+    \/\/ regs\n+    emulator.cpu.regs.set_hl(make_word(header[10], header[9]));\n+    emulator.cpu.regs.set_de(make_word(header[12], header[11]));\n+    emulator.cpu.regs.set_bc(make_word(header[14], header[13]));\n+    \/\/ index regs\n+    emulator.cpu.regs.set_iy(make_word(header[16], header[15]));\n+    emulator.cpu.regs.set_ix(make_word(header[18], header[17]));\n+    \/\/ iff2, iff1\n+    let iff = (header[19] & SNA_IFF2_BIT_MASK) != 0;\n+    emulator.cpu.regs.set_iff1(iff);\n+    emulator.cpu.regs.set_iff2(iff);\n+    \/\/ r\n+    emulator.cpu.regs.set_r(header[20]);\n+    \/\/ af\n+    emulator.cpu.regs.set_af(make_word(header[22], header[21]));\n+    \/\/ sp\n+    emulator.cpu.regs.set_sp(make_word(header[24], header[23]));\n+    \/\/ interrupt mode\n+    emulator.cpu.set_im(header[25] & SNA_INTERRUPT_MODE_MASK);\n+    \/\/ Border color\n+    emulator.controller.set_border_color(\n+        Clocks(0),\n+        ZXColor::from_bits(header[26] & SNA_BORDER_COLOR_MASK),\n+    );\n+    if is_128k {\n+        \/\/ PC, 7ffd port, trdos pagination status\n+        let mut tmp = [0u8; SNA_128K_SECONDARY_HEADER_SIZE];\n+        asset.seek(SeekFrom::Start(SNA_128K_SECONDARY_HEADER_OFFSET))?;\n+        asset.read_exact(&mut tmp)?;\n+        emulator.cpu.regs.set_pc(make_word(tmp[1], tmp[0]));\n+        let port_7ffd = tmp[2];\n+        let _trdos_paged = tmp[3];\n+        \/\/ This will alsto setup required memory map before banks restore\n+        emulator.controller.write_7ffd(port_7ffd);\n+\n+        \/\/ Go to the previous position\n+        asset.seek(SeekFrom::Start(SNA_HEADER_SIZE))?;\n+        let paginated_bank = match emulator\n+            .controller\n+            .memory\n+            .get_page(SNA_PAGINATED_PAGED_BANK_ADDRESS)\n+        {\n+            crate::zx::memory::Page::Ram(bank) => bank,\n+            crate::zx::memory::Page::Rom(_) => 0,\n+        };\n+\n+        \/\/ write 3 head banks\n+        let head_banks = &[\n+            SNA_128K_PERSISTENT_BANK_0,\n+            SNA_128K_PERSISTENT_BANK_1,\n+            paginated_bank,\n+        ];\n+        for bank in head_banks {\n+            let page = emulator.controller.memory.ram_page_data_mut(*bank);\n+            asset.read_exact(page)?;\n+        }\n+\n+        \/\/ tail banks\n+        asset.seek(SeekFrom::Start(SNA_128K_SECONDARY_TAIL_BANKS_OFFSET))?;\n+        for bank in SNA_128K_TAIL_BANKS {\n+            if *bank == paginated_bank {\n+                continue;\n+            }\n+            let page = emulator.controller.memory.ram_page_data_mut(*bank);\n+            asset.read_exact(page)?;\n+        }\n+    } else {\n+        for page_index in 0..SNA_48K_RAM_PAGES_COUNT {\n+            let page = emulator.controller.memory.ram_page_data_mut(page_index);\n+            asset.read_exact(page)?;\n+        }\n+\n+        \/\/ Perform RET as 48K sna snapshot stores it in the machine stack\n+        execute_pop_16(\n+            &mut emulator.cpu,\n+            &mut emulator.controller,\n+            RegName16::PC,\n+            Clocks(0),\n+        );\n+    }\n+\n+    \/\/ Refresh screen and other memory-dependent peripheral\n+    emulator.controller.refresh_memory_dependent_devices();\n+\n+    Ok(())\n+}\n+\n+\/\/\/ Helper class to place emulator in the state required for\n+\/\/\/ snapshoting and return to normal state afterwards\n+struct ScopedSnapshotState<'a, H: Host> {\n+    pub emulator: &'a mut Emulator<H>,\n+    pub is_48k: bool,\n+}\n+\n+impl<'a, H: Host> ScopedSnapshotState<'a, H> {\n+    fn enter(emulator: &'a mut Emulator<H>) -> Self {\n+        let is_48k = emulator.settings.machine == ZXMachine::Sinclair48K;\n+        if is_48k {\n+            execute_push_16(\n+                &mut emulator.cpu,\n+                &mut emulator.controller,\n+                RegName16::PC,\n+                Clocks(0),\n+            );\n+        }\n+\n+        Self { emulator, is_48k }\n+    }\n+}\n+\n+impl<'a, H: Host> Drop for ScopedSnapshotState<'a, H> {\n+    fn drop(&mut self) {\n+        if self.is_48k {\n+            execute_pop_16(\n+                &mut self.emulator.cpu,\n+                &mut self.emulator.controller,\n+                RegName16::PC,\n+                Clocks(0),\n+            );\n+        }\n+    }\n+}\n+\n+pub fn save<H, R>(emulator: &mut Emulator<H>, mut recorder: R) -> Result<()>\n+where\n+    H: Host,\n+    R: DataRecorder,\n+{\n+    let state = ScopedSnapshotState::enter(emulator);\n+    let ScopedSnapshotState { emulator, is_48k } = &state;\n+\n+    let mut header = [0u8; SNA_HEADER_SIZE];\n+    \/\/ interrupt register\n+    header[0] = emulator.cpu.regs.get_i();\n+    \/\/ alt register pairs\n+    header[1] = emulator.cpu.regs.get_l_alt();\n+    header[2] = emulator.cpu.regs.get_h_alt();\n+    header[3] = emulator.cpu.regs.get_e_alt();\n+    header[4] = emulator.cpu.regs.get_d_alt();\n+    header[5] = emulator.cpu.regs.get_c_alt();\n+    header[6] = emulator.cpu.regs.get_b_alt();\n+    header[7] = emulator.cpu.regs.get_flags_alt();\n+    header[8] = emulator.cpu.regs.get_acc_alt();\n+    \/\/ hl, de, bc, iy, ix\n+    header[9] = emulator.cpu.regs.get_l();\n+    header[10] = emulator.cpu.regs.get_h();\n+    header[11] = emulator.cpu.regs.get_e();\n+    header[12] = emulator.cpu.regs.get_d();\n+    header[13] = emulator.cpu.regs.get_c();\n+    header[14] = emulator.cpu.regs.get_b();\n+    let (iyh, iyl) = split_word(emulator.cpu.regs.get_iy());\n+    header[15] = iyl;\n+    header[16] = iyh;\n+    let (ixh, ixl) = split_word(emulator.cpu.regs.get_ix());\n+    header[17] = ixl;\n+    header[18] = ixh;\n+    \/\/ iff2\n+    if emulator.cpu.regs.get_iff2() {\n+        header[19] = SNA_IFF2_BIT_MASK;\n+    }\n+    \/\/ r\n+    header[20] = emulator.cpu.regs.get_r();\n+    \/\/ AF\n+    header[21] = emulator.cpu.regs.get_flags();\n+    header[22] = emulator.cpu.regs.get_acc();\n+    \/\/ SP\n+    let (sph, spl) = split_word(emulator.cpu.regs.get_sp());\n+    header[23] = spl;\n+    header[24] = sph;\n+    \/\/ Interrupt mode\n+    header[25] = emulator.cpu.get_im().into();\n+    \/\/ Border color\n+    header[26] = emulator.controller.border_color.into();\n+\n+    recorder.write_all(&header)?;\n+\n+    if *is_48k {\n+        for page_index in 0..SNA_48K_RAM_PAGES_COUNT {\n+            let page = emulator.controller.memory.ram_page_data(page_index);\n+            recorder.write_all(page)?;\n+        }\n+    } else {\n+        let paginated_bank = match emulator\n+            .controller\n+            .memory\n+            .get_page(SNA_PAGINATED_PAGED_BANK_ADDRESS)\n+        {\n+            crate::zx::memory::Page::Ram(bank) => bank,\n+            crate::zx::memory::Page::Rom(_) => 0,\n+        };\n+        let head_banks = &[\n+            SNA_128K_PERSISTENT_BANK_0,\n+            SNA_128K_PERSISTENT_BANK_1,\n+            paginated_bank,\n+        ];\n+        for bank in head_banks {\n+            let page = emulator.controller.memory.ram_page_data(*bank);\n+            recorder.write_all(page)?;\n+        }\n+\n+        \/\/ PC, 7ffd, trdos\n+        let (pch, pcl) = split_word(emulator.cpu.regs.get_pc());\n+        let port_7ffd = emulator.controller.read_7ffd();\n+        let trdos_paged = 0x00;\n+        recorder.write_all(&[pcl, pch, port_7ffd, trdos_paged])?;\n+\n+        \/\/ remaining banks\n+        for bank in SNA_128K_TAIL_BANKS {\n+            if *bank == paginated_bank {\n+                continue;\n+            }\n+            let page = emulator.controller.memory.ram_page_data(*bank);\n+            recorder.write_all(page)?;\n+        }\n+    }\n+\n+    Ok(())\n+}\ndiff --git a\/rustzx-core\/src\/error.rs b\/rustzx-core\/src\/error.rs\nindex 5c96cf6..0ade567 100644\n--- a\/rustzx-core\/src\/error.rs\n+++ b\/rustzx-core\/src\/error.rs\n@@ -4,7 +4,7 @@ use from_variants::FromVariants;\n #[derive(Debug, Display, FromVariants)]\n pub enum Error {\n     \/\/\/ Failed to read asset\n-    AssetRead(AssetReadError),\n+    AssetRead(IoError),\n     \/\/\/ Failed to load rom\n     RomLoad(RomLoadError),\n     \/\/\/ Failed to load rom\n@@ -12,9 +12,13 @@ pub enum Error {\n }\n \n #[derive(Debug, Display)]\n-pub enum AssetReadError {\n+pub enum IoError {\n     \/\/\/ Unexpected end of file\n     UnexpectedEof,\n+    \/\/\/ Sink unexpectedly refused to write more bytes\n+    WriteZero,\n+    \/\/\/ Seek operation was performed with offset before beginning of the asset\n+    SeekBeforeStart,\n     \/\/\/ Host-provided asset implementation failed\n     HostAssetImplFailed,\n }\ndiff --git a\/rustzx-core\/src\/host\/io.rs b\/rustzx-core\/src\/host\/io.rs\nindex 9ba902a..9cc0f51 100644\n--- a\/rustzx-core\/src\/host\/io.rs\n+++ b\/rustzx-core\/src\/host\/io.rs\n@@ -1,6 +1,7 @@\n-use crate::error;\n+use crate::error::IoError;\n+use core::usize;\n \n-type Result<T> = core::result::Result<T, error::AssetReadError>;\n+type Result<T> = core::result::Result<T, IoError>;\n \n #[derive(Clone, Copy)]\n pub enum SeekFrom {\n@@ -9,14 +10,59 @@ pub enum SeekFrom {\n     Current(isize),\n }\n \n+\/\/\/ Implementation of loadable asset for buffer-like type\n+pub struct BufferCursor<T: AsRef<[u8]>> {\n+    data: T,\n+    pos: usize,\n+}\n+\n+impl<T: AsRef<[u8]>> BufferCursor<T> {\n+    pub fn new(data: T) -> Self {\n+        Self { data, pos: 0 }\n+    }\n+}\n+\n+impl<T: AsRef<[u8]>> SeekableAsset for BufferCursor<T> {\n+    fn seek(&mut self, pos: SeekFrom) -> Result<usize> {\n+        let new_pos = match pos {\n+            SeekFrom::Start(pos) => pos as isize,\n+            SeekFrom::End(pos) => self.data.as_ref().len() as isize + pos,\n+            SeekFrom::Current(pos) => self.pos as isize + pos,\n+        };\n+        if new_pos < 0 {\n+            return Err(IoError::SeekBeforeStart);\n+        }\n+        self.pos = new_pos as usize;\n+\n+        Ok(self.pos)\n+    }\n+}\n+\n+impl<T: AsRef<[u8]>> LoadableAsset for BufferCursor<T> {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n+        let data = self.data.as_ref();\n+\n+        if self.pos >= data.len() {\n+            return Err(IoError::UnexpectedEof);\n+        }\n+        let bytes_to_read = buf.len().min(data.len() - self.pos);\n+        buf[0..bytes_to_read].copy_from_slice(&data[self.pos..self.pos + bytes_to_read]);\n+        self.pos += bytes_to_read;\n+        Ok(bytes_to_read)\n+    }\n+}\n+\n+pub trait SeekableAsset {\n+    \/\/\/ Seek position in the asset. Returns current position in the asset\n+    fn seek(&mut self, pos: SeekFrom) -> Result<usize>;\n+}\n+\n \/\/ While no_std environment does not provide Read\n \/\/ trait, we are forced to use substitution for it\n pub trait LoadableAsset {\n     \/\/\/ Read data from asset to `buf`\n-    \/\/\/ Return count of read bytes. Should return 0 read bytes when EOF was reached\n+    \/\/\/ Returns count of read bytes. Should return 0 read bytes when EOF was reached\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n-    \/\/\/ Seek position in the asset. Returns current position in the asset\n-    fn seek(&mut self, pos: SeekFrom) -> Result<usize>;\n \n     fn read_exact(&mut self, mut buf: &mut [u8]) -> Result<()> {\n         while !buf.is_empty() {\n@@ -31,9 +77,59 @@ pub trait LoadableAsset {\n             }\n         }\n         if !buf.is_empty() {\n-            return Err(error::AssetReadError::UnexpectedEof);\n+            return Err(IoError::UnexpectedEof);\n         }\n \n         Ok(())\n     }\n }\n+\n+pub trait DataRecorder {\n+    \/\/\/ Writes given buffer to recorder.\n+    \/\/\/ Returns count of written bytes or 0 if end of the\n+    \/\/\/ destination asset was reached (e.g. buffer filled)\n+    fn write(&mut self, buf: &[u8]) -> Result<usize>;\n+\n+    \/\/\/ Writes all bytes to the destiantion or returns\n+    \/\/\/ [IoError::WriteZero] if destination refused to accept\n+    \/\/\/ more bytes\n+    fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n+        while !buf.is_empty() {\n+            match self.write(buf)? {\n+                0 => return Err(IoError::WriteZero),\n+                n => buf = &buf[n..],\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn buffer_cursor_seek_works() {\n+        const BUFFER: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let mut cursor = BufferCursor::new(BUFFER);\n+\n+        let mut tmp = [0u8; 1];\n+        cursor.read_exact(&mut tmp).unwrap();\n+        assert_eq!(tmp[0], 1);\n+\n+        cursor.seek(SeekFrom::Current(1)).unwrap();\n+        cursor.read_exact(&mut tmp).unwrap();\n+        assert_eq!(tmp[0], 3);\n+\n+        cursor.seek(SeekFrom::Start(2)).unwrap();\n+        cursor.read_exact(&mut tmp).unwrap();\n+        assert_eq!(tmp[0], 3);\n+\n+        let mut tmp = [0u8; 3];\n+        cursor.seek(SeekFrom::End(-2)).unwrap();\n+        let read_bytes = cursor.read(&mut tmp).unwrap();\n+        assert_eq!(read_bytes, 2);\n+        assert_eq!(tmp[0], 9);\n+        assert_eq!(tmp[1], 10);\n+    }\n+}\ndiff --git a\/rustzx-core\/src\/host\/mod.rs b\/rustzx-core\/src\/host\/mod.rs\nindex d1c97c2..d4b46b5 100644\n--- a\/rustzx-core\/src\/host\/mod.rs\n+++ b\/rustzx-core\/src\/host\/mod.rs\n@@ -2,13 +2,19 @@ mod frame_buffer;\n mod io;\n \n pub use frame_buffer::{FrameBuffer, FrameBufferSource};\n-pub use io::{LoadableAsset, SeekFrom};\n+pub use io::{DataRecorder, LoadableAsset, SeekFrom, SeekableAsset};\n+\n+pub use io::BufferCursor;\n \n pub enum Snapshot<LoadableAssetImpl: LoadableAsset> {\n     Sna(LoadableAssetImpl),\n     \/\/ TODO(#55): Implement SLT snapshot format support\n }\n \n+pub enum SnapshotRecorder<DataRecorderImpl: DataRecorder> {\n+    Sna(DataRecorderImpl),\n+}\n+\n pub enum Tape<LoadableAssetImpl: LoadableAsset> {\n     Tap(LoadableAssetImpl),\n     \/\/ TODO(#56): Implement TZX tape format support\n@@ -36,9 +42,7 @@ pub trait Host {\n     \/\/\/ context objects for host-defined emulator parts construction (e.g. FrameBuffers)\n     type Context: HostContext<Self>;\n     \/\/\/ File-like type implementation for tape loading\n-    type TapeAsset: LoadableAsset;\n-    \/\/\/ File-like type implementation for snapshot loading\n-    type SnapshotAsset: LoadableAsset;\n+    type TapeAsset: LoadableAsset + SeekableAsset;\n     \/\/\/ File-like type implementation for rom loading\n     type RomSet: RomSet;\n     \/\/\/ Frame buffer implementation\ndiff --git a\/rustzx-core\/src\/settings.rs b\/rustzx-core\/src\/settings.rs\nindex c60d79a..71c335a 100644\n--- a\/rustzx-core\/src\/settings.rs\n+++ b\/rustzx-core\/src\/settings.rs\n@@ -6,8 +6,9 @@ use crate::zx::sound::ay::ZXAYMode;\n pub struct RustzxSettings {\n     pub machine: ZXMachine,\n     pub emulation_speed: EmulationSpeed,\n-    pub tape_fastload: bool,\n-    pub enable_kempston: bool,\n+    pub tape_fastload_enabled: bool,\n+    pub kempston_enabled: bool,\n+    pub mouse_enabled: bool,\n     #[cfg(all(feature = \"sound\", feature = \"ay\"))]\n     pub ay_mode: ZXAYMode,\n     #[cfg(all(feature = \"sound\", feature = \"ay\"))]\n@@ -22,4 +23,6 @@ pub struct RustzxSettings {\n     pub sound_sample_rate: usize,\n     #[cfg(feature = \"embedded-roms\")]\n     pub load_default_rom: bool,\n+    #[cfg(feature = \"autoload\")]\n+    pub autoload_enabled: bool,\n }\ndiff --git a\/rustzx-core\/src\/z80\/common_types.rs b\/rustzx-core\/src\/z80\/common_types.rs\nindex e908c18..bbd46dc 100644\n--- a\/rustzx-core\/src\/z80\/common_types.rs\n+++ b\/rustzx-core\/src\/z80\/common_types.rs\n@@ -40,3 +40,13 @@ pub enum IntMode {\n     IM1,\n     IM2,\n }\n+\n+impl From<IntMode> for u8 {\n+    fn from(mode: IntMode) -> Self {\n+        match mode {\n+            IntMode::IM0 => 0,\n+            IntMode::IM1 => 1,\n+            IntMode::IM2 => 2,\n+        }\n+    }\n+}\ndiff --git a\/rustzx-core\/src\/z80\/registers.rs b\/rustzx-core\/src\/z80\/registers.rs\nindex efcdb6c..6d8f8f4 100644\n--- a\/rustzx-core\/src\/z80\/registers.rs\n+++ b\/rustzx-core\/src\/z80\/registers.rs\n@@ -464,6 +464,11 @@ impl Regs {\n         self.a\n     }\n \n+    \/\/\/ Returns alt accumulator\n+    pub fn get_acc_alt(&self) -> u8 {\n+        self.a_alt\n+    }\n+\n     \/\/\/ Changes accumulator\n     pub fn set_acc(&mut self, value: u8) -> u8 {\n         self.a = value;\n@@ -481,6 +486,11 @@ impl Regs {\n         self.f\n     }\n \n+    \/\/\/ Returns alt F\n+    pub fn get_flags_alt(&self) -> u8 {\n+        self.f_alt\n+    }\n+\n     \/\/\/ Returns I\n     pub fn get_i(&self) -> u8 {\n         self.i\n@@ -520,6 +530,16 @@ impl Regs {\n         self.c\n     }\n \n+    \/\/\/ Returns D\n+    pub fn get_d(&self) -> u8 {\n+        self.d\n+    }\n+\n+    \/\/\/ Returns E\n+    pub fn get_e(&self) -> u8 {\n+        self.e\n+    }\n+\n     \/\/\/ Returns H\n     pub fn get_h(&self) -> u8 {\n         self.h\n@@ -530,6 +550,36 @@ impl Regs {\n         self.l\n     }\n \n+    \/\/\/ Returns alt B\n+    pub fn get_b_alt(&self) -> u8 {\n+        self.b_alt\n+    }\n+\n+    \/\/\/ Returns alt C\n+    pub fn get_c_alt(&self) -> u8 {\n+        self.c_alt\n+    }\n+\n+    \/\/\/ Returns alt D\n+    pub fn get_d_alt(&self) -> u8 {\n+        self.d_alt\n+    }\n+\n+    \/\/\/ Returns alt E\n+    pub fn get_e_alt(&self) -> u8 {\n+        self.e_alt\n+    }\n+\n+    \/\/\/ Returns alt H\n+    pub fn get_h_alt(&self) -> u8 {\n+        self.h\n+    }\n+\n+    \/\/\/ Returns alt L\n+    pub fn get_l_alt(&self) -> u8 {\n+        self.l\n+    }\n+\n     \/\/ flip-flops --------------------------------------------------------------------------------\n \n     \/\/\/ Returns iff1\ndiff --git a\/rustzx-core\/src\/zx\/controller.rs b\/rustzx-core\/src\/zx\/controller.rs\nindex e654eb9..673b9b3 100644\n--- a\/rustzx-core\/src\/zx\/controller.rs\n+++ b\/rustzx-core\/src\/zx\/controller.rs\n@@ -8,10 +8,14 @@ use crate::{\n     zx::{\n         constants::{ADDR_LD_BREAK, CANVAS_HEIGHT, CLOCKS_PER_COL},\n         events::EmulationEvents,\n-        joy::kempston::KempstonJoy,\n-        keys::ZXKey,\n+        joy::{\n+            kempston::KempstonJoy,\n+            sinclair::{self, SinclairJoyNum, SinclairKey},\n+        },\n+        keys::{CompoundKey, ZXKey},\n         machine::ZXMachine,\n         memory::{Page, RamType, RomType, ZXMemory, PAGE_SIZE},\n+        mouse::kempston::{KempstonMouse, KempstonMouseButton, KempstonMouseWheelDirection},\n         tape::{TapeImpl, ZXTape},\n         video::{colors::ZXColor, screen::ZXScreen},\n     },\n@@ -34,9 +38,13 @@ pub(crate) struct ZXController<H: Host> {\n     #[cfg(feature = \"precise-border\")]\n     pub border: ZXBorder<H::FrameBuffer>,\n     pub kempston: Option<KempstonJoy>,\n+    pub mouse: Option<KempstonMouse>,\n     #[cfg(feature = \"sound\")]\n     pub mixer: ZXMixer,\n     pub keyboard: [u8; 8],\n+    pub keyboard_extended: [u8; 8],\n+    pub keyboard_sinclair: [u8; 8],\n+    pub caps_shift_modifier_mask: u32,\n     \/\/ current border color\n     pub border_color: ZXColor,\n     \/\/ clocls count from frame start\n@@ -50,6 +58,7 @@ pub(crate) struct ZXController<H: Host> {\n     ear: bool,\n     paging_enabled: bool,\n     screen_bank: u8,\n+    current_port_7ffd: u8,\n     \/\/ Z80 module expected controller implementation without errors,\n     \/\/ so we need to store the internal errors manually. For sake of simplicity,\n     \/\/ Only last error is saved\n@@ -72,12 +81,19 @@ impl<H: Host> ZXController<H> {\n                 screen_bank = 5;\n             }\n         };\n-        let kempston = if settings.enable_kempston {\n+\n+        let kempston = if settings.kempston_enabled {\n             Some(KempstonJoy::default())\n         } else {\n             None\n         };\n \n+        let mouse = if settings.mouse_enabled {\n+            Some(KempstonMouse::default())\n+        } else {\n+            None\n+        };\n+\n         let screen = ZXScreen::new(settings.machine, host_context.frame_buffer_context());\n         #[cfg(feature = \"precise-border\")]\n         let border = ZXBorder::new(settings.machine, host_context.frame_buffer_context());\n@@ -92,9 +108,13 @@ impl<H: Host> ZXController<H> {\n             #[cfg(feature = \"precise-border\")]\n             border,\n             kempston,\n+            mouse,\n             #[cfg(feature = \"sound\")]\n             mixer,\n             keyboard: [0xFF; 8],\n+            keyboard_extended: [0xFF; 8],\n+            keyboard_sinclair: [0xFF; 8],\n+            caps_shift_modifier_mask: 0,\n             border_color: ZXColor::Black,\n             frame_clocks: Clocks(0),\n             passed_frames: 0,\n@@ -104,6 +124,7 @@ impl<H: Host> ZXController<H> {\n             ear: false,\n             paging_enabled: paging,\n             screen_bank,\n+            current_port_7ffd: 0,\n             last_emulation_error: None,\n         };\n \n@@ -160,10 +181,59 @@ impl<H: Host> ZXController<H> {\n \n     \/\/\/ Changes key state in controller\n     pub fn send_key(&mut self, key: ZXKey, pressed: bool) {\n-        let row_id = key.row_id();\n-        self.keyboard[row_id] &= !key.mask();\n-        if !pressed {\n-            self.keyboard[row_id] |= key.mask();\n+        if pressed {\n+            self.keyboard[key.row_id()] &= !key.mask();\n+            return;\n+        }\n+        self.keyboard[key.row_id()] |= key.mask();\n+    }\n+\n+    pub fn send_sinclair_key(&mut self, num: SinclairJoyNum, key: SinclairKey, pressed: bool) {\n+        let key = sinclair::sinclair_event_to_zx_key(key, num);\n+        if pressed {\n+            self.keyboard_sinclair[key.row_id()] &= !key.mask();\n+            return;\n+        }\n+        self.keyboard_sinclair[key.row_id()] |= key.mask();\n+    }\n+\n+    pub fn send_compound_key(&mut self, key: CompoundKey, pressed: bool) {\n+        let mut dummy_modifier_mask = 0;\n+        let modifier_mask = match key.modifier_key() {\n+            ZXKey::Shift => &mut self.caps_shift_modifier_mask,\n+            _ => &mut dummy_modifier_mask,\n+        };\n+        let primary_key = key.primary_key();\n+        let modifier_key = key.modifier_key();\n+\n+        if pressed {\n+            *modifier_mask |= key.modifier_mask();\n+            self.keyboard_extended[primary_key.row_id()] &= !primary_key.mask();\n+            self.keyboard_extended[modifier_key.row_id()] &= !modifier_key.mask();\n+        } else {\n+            *modifier_mask &= !key.modifier_mask();\n+            if *modifier_mask == 0 {\n+                self.keyboard_extended[modifier_key.row_id()] |= modifier_key.mask();\n+            }\n+            self.keyboard_extended[primary_key.row_id()] |= primary_key.mask();\n+        }\n+    }\n+\n+    pub fn send_mouse_button(&mut self, button: KempstonMouseButton, pressed: bool) {\n+        if let Some(mouse) = &mut self.mouse {\n+            mouse.send_button(button, pressed);\n+        }\n+    }\n+\n+    pub fn send_mouse_wheel(&mut self, dir: KempstonMouseWheelDirection) {\n+        if let Some(mouse) = &mut self.mouse {\n+            mouse.send_wheel(dir);\n+        }\n+    }\n+\n+    pub fn send_mouse_pos_diff(&mut self, x: i8, y: i8) {\n+        if let Some(mouse) = &mut self.mouse {\n+            mouse.send_pos_diff(x, y);\n         }\n     }\n \n@@ -268,10 +338,11 @@ impl<H: Host> ZXController<H> {\n         self.frame_clocks\n     }\n \n-    fn write_7ffd(&mut self, val: u8) {\n+    pub fn write_7ffd(&mut self, val: u8) {\n         if !self.paging_enabled {\n             return;\n         }\n+        self.current_port_7ffd = val;\n         \/\/ remap top 16K of the ram\n         self.memory.remap(3, Page::Ram(val & 0x07));\n         \/\/ third block is not pageable\n@@ -287,6 +358,10 @@ impl<H: Host> ZXController<H> {\n         }\n     }\n \n+    pub fn read_7ffd(&self) -> u8 {\n+        self.current_port_7ffd\n+    }\n+\n     #[cfg(all(feature = \"sound\", feature = \"ay\"))]\n     fn read_ay_port(&mut self) -> u8 {\n         self.mixer.ay.read()\n@@ -326,6 +401,24 @@ impl<H: Host> ZXController<H> {\n     pub(crate) fn take_last_emulation_error(&mut self) -> Option<Error> {\n         self.last_emulation_error.take()\n     }\n+\n+    pub(crate) fn refresh_memory_dependent_devices(&mut self) {\n+        match self.machine {\n+            ZXMachine::Sinclair48K => {\n+                for (idx, data) in self.memory.ram_page_data(0).iter().enumerate() {\n+                    self.screen.update(idx as u16, 0, *data);\n+                }\n+            }\n+            ZXMachine::Sinclair128K => {\n+                for (idx, data) in self.memory.ram_page_data(5).iter().enumerate() {\n+                    self.screen.update(idx as u16, 5, *data);\n+                }\n+                for (idx, data) in self.memory.ram_page_data(7).iter().enumerate() {\n+                    self.screen.update(idx as u16, 7, *data);\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<H: Host> Z80Bus for ZXController<H> {\n@@ -416,7 +509,9 @@ impl<H: Host> Z80Bus for ZXController<H> {\n             for n in 0..8 {\n                 \/\/ if bit of row reset\n                 if ((h >> n) & 0x01) == 0 {\n-                    tmp &= self.keyboard[n];\n+                    let keyboard_byte =\n+                        self.keyboard[n] & self.keyboard_extended[n] & self.keyboard_sinclair[n];\n+                    tmp &= keyboard_byte;\n                 }\n             }\n             \/\/ invert bit 6 if mic_hw active;\n@@ -425,14 +520,16 @@ impl<H: Host> Z80Bus for ZXController<H> {\n             }\n             \/\/ 5 and 7 unused\n             tmp\n+        } else if self.mouse.is_some() && (port & 0x0121 == 0x0001) {\n+            self.mouse.as_ref().unwrap().buttons_port\n+        } else if self.mouse.is_some() && (port & 0x0521 == 0x0101) {\n+            self.mouse.as_ref().unwrap().x_pos_port\n+        } else if self.mouse.is_some() && (port & 0x0521 == 0x0501) {\n+            self.mouse.as_ref().unwrap().y_pos_port\n         } else if port & 0xC002 == 0xC000 {\n             self.read_ay_port()\n-        } else if self.kempston.is_some() && (port & 0x0020 == 0) {\n-            if let Some(ref joy) = self.kempston {\n-                joy.read()\n-            } else {\n-                unreachable!()\n-            }\n+        } else if self.kempston.is_some() && (port & 0x00E0 == 0) {\n+            self.kempston.as_ref().unwrap().read()\n         } else {\n             self.floating_bus_value()\n         };\ndiff --git a\/rustzx-core\/src\/zx\/joy\/mod.rs b\/rustzx-core\/src\/zx\/joy\/mod.rs\nindex f84329b..859ed62 100644\n--- a\/rustzx-core\/src\/zx\/joy\/mod.rs\n+++ b\/rustzx-core\/src\/zx\/joy\/mod.rs\n@@ -1,1 +1,2 @@\n pub mod kempston;\n+pub mod sinclair;\ndiff --git a\/rustzx-core\/src\/zx\/joy\/sinclair.rs b\/rustzx-core\/src\/zx\/joy\/sinclair.rs\nnew file mode 100644\nindex 0000000..2b0851a\n--- \/dev\/null\n+++ b\/rustzx-core\/src\/zx\/joy\/sinclair.rs\n@@ -0,0 +1,29 @@\n+use crate::zx::keys::ZXKey;\n+\n+pub enum SinclairKey {\n+    Left,\n+    Right,\n+    Up,\n+    Down,\n+    Fire,\n+}\n+\n+pub enum SinclairJoyNum {\n+    Fist,\n+    Second,\n+}\n+\n+pub(crate) fn sinclair_event_to_zx_key(key: SinclairKey, num: SinclairJoyNum) -> ZXKey {\n+    match (num, key) {\n+        (SinclairJoyNum::Fist, SinclairKey::Left) => ZXKey::N6,\n+        (SinclairJoyNum::Fist, SinclairKey::Right) => ZXKey::N7,\n+        (SinclairJoyNum::Fist, SinclairKey::Up) => ZXKey::N9,\n+        (SinclairJoyNum::Fist, SinclairKey::Down) => ZXKey::N8,\n+        (SinclairJoyNum::Fist, SinclairKey::Fire) => ZXKey::N0,\n+        (SinclairJoyNum::Second, SinclairKey::Left) => ZXKey::N1,\n+        (SinclairJoyNum::Second, SinclairKey::Right) => ZXKey::N2,\n+        (SinclairJoyNum::Second, SinclairKey::Up) => ZXKey::N4,\n+        (SinclairJoyNum::Second, SinclairKey::Down) => ZXKey::N2,\n+        (SinclairJoyNum::Second, SinclairKey::Fire) => ZXKey::N5,\n+    }\n+}\ndiff --git a\/rustzx-core\/src\/zx\/keys.rs b\/rustzx-core\/src\/zx\/keys.rs\nindex 1919c6d..9fbbeec 100644\n--- a\/rustzx-core\/src\/zx\/keys.rs\n+++ b\/rustzx-core\/src\/zx\/keys.rs\n@@ -22,6 +22,51 @@ pub enum ZXKey {\n     Space, SymShift, M, N, B,\n }\n \n+#[derive(Clone, Copy)]\n+pub enum CompoundKey {\n+    ArrowLeft,\n+    ArrowRight,\n+    ArrowUp,\n+    ArrowDown,\n+    CapsLock,\n+    Delete,\n+    Break,\n+}\n+\n+impl CompoundKey {\n+    \/\/\/ This mask is required to implement logic to keep\n+    \/\/\/ modifier key pressed while one of the compound\n+    \/\/\/ keys were released, but one of them is still\n+    \/\/\/ pressed, therefore modifier should be unchanged\n+    pub(crate) fn modifier_mask(self) -> u32 {\n+        match self {\n+            CompoundKey::ArrowLeft => 0x00000001,\n+            CompoundKey::ArrowRight => 0x00000002,\n+            CompoundKey::ArrowUp => 0x00000004,\n+            CompoundKey::ArrowDown => 0x00000008,\n+            CompoundKey::CapsLock => 0x00000010,\n+            CompoundKey::Delete => 0x00000020,\n+            CompoundKey::Break => 0x00000040,\n+        }\n+    }\n+\n+    pub(crate) fn modifier_key(self) -> ZXKey {\n+        ZXKey::Shift\n+    }\n+\n+    pub(crate) fn primary_key(self) -> ZXKey {\n+        match self {\n+            CompoundKey::ArrowLeft => ZXKey::N5,\n+            CompoundKey::ArrowRight => ZXKey::N8,\n+            CompoundKey::ArrowUp => ZXKey::N7,\n+            CompoundKey::ArrowDown => ZXKey::N6,\n+            CompoundKey::CapsLock => ZXKey::N2,\n+            CompoundKey::Delete => ZXKey::N0,\n+            CompoundKey::Break => ZXKey::Space,\n+        }\n+    }\n+}\n+\n impl ZXKey {\n     pub(crate) fn row_id(self) -> usize {\n         match self.half_port() {\ndiff --git a\/rustzx-core\/src\/zx\/memory.rs b\/rustzx-core\/src\/zx\/memory.rs\nindex 0110e7e..a01cc09 100644\n--- a\/rustzx-core\/src\/zx\/memory.rs\n+++ b\/rustzx-core\/src\/zx\/memory.rs\n@@ -147,6 +147,15 @@ impl ZXMemory {\n         &mut self.ram[shift..shift + PAGE_SIZE]\n     }\n \n+    \/\/\/ Returns slice to ram page\n+    pub fn ram_page_data(&self, page: u8) -> &[u8] {\n+        if (page as usize + 1) * PAGE_SIZE > self.ram.len() {\n+            panic!(\"[ERROR] Ram page {} does not exists!\", page);\n+        }\n+        let shift = page as usize * PAGE_SIZE;\n+        &self.ram[shift..shift + PAGE_SIZE]\n+    }\n+\n     \/\/\/ Dumps current address space\n     pub fn dump(&self) -> Vec<u8> {\n         let mut out = Vec::new();\ndiff --git a\/rustzx-core\/src\/zx\/mod.rs b\/rustzx-core\/src\/zx\/mod.rs\nindex f591012..44dd3e1 100644\n--- a\/rustzx-core\/src\/zx\/mod.rs\n+++ b\/rustzx-core\/src\/zx\/mod.rs\n@@ -11,6 +11,8 @@ pub mod constants;\n pub mod joy;\n pub mod keys;\n pub mod machine;\n+pub mod mouse;\n+\n #[cfg(feature = \"sound\")]\n pub mod sound;\n pub mod video;\ndiff --git a\/rustzx-core\/src\/zx\/mouse\/kempston.rs b\/rustzx-core\/src\/zx\/mouse\/kempston.rs\nnew file mode 100644\nindex 0000000..44dad98\n--- \/dev\/null\n+++ b\/rustzx-core\/src\/zx\/mouse\/kempston.rs\n@@ -0,0 +1,58 @@\n+const WHEEL_MASK: u8 = 0xF0;\n+const WHEEL_SHIFT: usize = 4;\n+\n+\/\/ non_exhaustive allows to restrict struct instantiation only to `Default::deafault`\n+#[non_exhaustive]\n+pub(crate) struct KempstonMouse {\n+    pub buttons_port: u8,\n+    pub x_pos_port: u8,\n+    pub y_pos_port: u8,\n+}\n+\n+impl Default for KempstonMouse {\n+    fn default() -> Self {\n+        Self {\n+            buttons_port: 0xFF,\n+            x_pos_port: 0xFF,\n+            y_pos_port: 0xFF,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+pub enum KempstonMouseButton {\n+    Left = 0x01,\n+    Right = 0x02,\n+    Middle = 0x04,\n+    Additional = 0x08,\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+#[repr(i8)]\n+pub enum KempstonMouseWheelDirection {\n+    Up = 1,\n+    Down = -1,\n+}\n+\n+impl KempstonMouse {\n+    pub fn send_button(&mut self, button: KempstonMouseButton, pressed: bool) {\n+        if pressed {\n+            self.buttons_port &= !(button as u8);\n+            return;\n+        }\n+\n+        self.buttons_port |= button as u8\n+    }\n+\n+    pub fn send_wheel(&mut self, dir: KempstonMouseWheelDirection) {\n+        let mut current = (self.buttons_port & WHEEL_MASK) >> WHEEL_SHIFT;\n+        current = ((current as i8) + (dir as i8)) as u8;\n+        self.buttons_port =\n+            (self.buttons_port & (!WHEEL_MASK)) | ((current << WHEEL_SHIFT) & WHEEL_MASK);\n+    }\n+\n+    pub fn send_pos_diff(&mut self, x: i8, y: i8) {\n+        self.x_pos_port = ((self.x_pos_port as i16) + x as i16) as u8;\n+        self.y_pos_port = ((self.y_pos_port as i16) - y as i16) as u8;\n+    }\n+}\ndiff --git a\/rustzx-core\/src\/zx\/mouse\/mod.rs b\/rustzx-core\/src\/zx\/mouse\/mod.rs\nnew file mode 100644\nindex 0000000..f84329b\n--- \/dev\/null\n+++ b\/rustzx-core\/src\/zx\/mouse\/mod.rs\n@@ -0,0 +1,1 @@\n+pub mod kempston;\ndiff --git a\/rustzx-core\/src\/zx\/tape\/mod.rs b\/rustzx-core\/src\/zx\/tape\/mod.rs\nindex 1188910..1880a9b 100644\n--- a\/rustzx-core\/src\/zx\/tape\/mod.rs\n+++ b\/rustzx-core\/src\/zx\/tape\/mod.rs\n@@ -3,17 +3,21 @@ mod tap;\n \n pub use self::{empty::Empty, tap::Tap};\n \n-use crate::{host::LoadableAsset, utils::Clocks, Result};\n+use crate::{\n+    host::{LoadableAsset, SeekableAsset},\n+    utils::Clocks,\n+    Result,\n+};\n \n use enum_dispatch::enum_dispatch;\n \n #[enum_dispatch(TapeImpl)]\n-pub enum ZXTape<A: LoadableAsset> {\n+pub enum ZXTape<A: LoadableAsset + SeekableAsset> {\n     Tap(Tap<A>),\n     Empty(Empty),\n }\n \n-impl<A: LoadableAsset> Default for ZXTape<A> {\n+impl<A: LoadableAsset + SeekableAsset> Default for ZXTape<A> {\n     fn default() -> Self {\n         Self::Empty(Empty)\n     }\ndiff --git a\/rustzx-core\/src\/zx\/tape\/tap.rs b\/rustzx-core\/src\/zx\/tape\/tap.rs\nindex ca66c9e..183c716 100644\n--- a\/rustzx-core\/src\/zx\/tape\/tap.rs\n+++ b\/rustzx-core\/src\/zx\/tape\/tap.rs\n@@ -1,6 +1,6 @@\n use crate::{\n     error::TapeLoadError,\n-    host::{LoadableAsset, SeekFrom},\n+    host::{LoadableAsset, SeekFrom, SeekableAsset},\n     utils::{make_word, Clocks},\n     zx::tape::TapeImpl,\n     Result,\n@@ -28,7 +28,7 @@ enum TapeState {\n     Pause,\n }\n \n-pub struct Tap<A: LoadableAsset> {\n+pub struct Tap<A: LoadableAsset + SeekableAsset> {\n     asset: A,\n     state: TapeState,\n     prev_state: TapeState,\n@@ -43,7 +43,7 @@ pub struct Tap<A: LoadableAsset> {\n     delay: Clocks,\n }\n \n-impl<A: LoadableAsset> Tap<A> {\n+impl<A: LoadableAsset + SeekableAsset> Tap<A> {\n     pub fn from_asset(asset: A) -> Result<Self> {\n         let tap = Self {\n             prev_state: TapeState::Stop,\n@@ -62,7 +62,7 @@ impl<A: LoadableAsset> Tap<A> {\n     }\n }\n \n-impl<A: LoadableAsset> TapeImpl for Tap<A> {\n+impl<A: LoadableAsset + SeekableAsset> TapeImpl for Tap<A> {\n     fn can_fast_load(&self) -> bool {\n         self.state == TapeState::Stop\n     }\ndiff --git a\/rustzx-core\/src\/zx\/video\/colors.rs b\/rustzx-core\/src\/zx\/video\/colors.rs\nindex 2248852..3009151 100644\n--- a\/rustzx-core\/src\/zx\/video\/colors.rs\n+++ b\/rustzx-core\/src\/zx\/video\/colors.rs\n@@ -39,6 +39,21 @@ impl ZXColor {\n     }\n }\n \n+impl From<ZXColor> for u8 {\n+    fn from(color: ZXColor) -> Self {\n+        match color {\n+            ZXColor::Black => 0,\n+            ZXColor::Blue => 1,\n+            ZXColor::Red => 2,\n+            ZXColor::Purple => 3,\n+            ZXColor::Green => 4,\n+            ZXColor::Cyan => 5,\n+            ZXColor::Yellow => 6,\n+            ZXColor::White => 7,\n+        }\n+    }\n+}\n+\n \/\/\/ ZX Spectrum attribute structure\n \/\/\/ It contains information about ink, paper color,\n \/\/\/ flash attribute and brightness\ndiff --git a\/rustzx\/Cargo.toml b\/rustzx\/Cargo.toml\nindex 884b6ea..607d735 100644\n--- a\/rustzx\/Cargo.toml\n+++ b\/rustzx\/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"rustzx\"\n-version = \"0.12.0\"\n+version = \"0.13.0\"\n authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n description = \"ZX Spectum emulator\"\n repository = \"https:\/\/github.com\/pacmancoder\/rustzx\"\n@@ -13,7 +13,7 @@ edition = \"2018\"\n \n [dependencies]\n sdl2 = { version = \"0.34\", features = [\"unsafe_textures\", \"bundled\", \"static-link\"] }\n-rustzx-core = { version = \"0.12\", path =  \"..\/rustzx-core\", features = [\"full\"] }\n+rustzx-core = { version = \"0.13\", path =  \"..\/rustzx-core\", features = [\"full\"] }\n log = \"0.4\"\n anyhow = \"1\"\n structopt = \"0.3\"\ndiff --git a\/rustzx\/src\/app\/events\/events_sdl.rs b\/rustzx\/src\/app\/events\/events_sdl.rs\nindex 84f4a2c..444bda5 100644\n--- a\/rustzx\/src\/app\/events\/events_sdl.rs\n+++ b\/rustzx\/src\/app\/events\/events_sdl.rs\n@@ -2,35 +2,86 @@\n use super::{Event, EventDevice};\n use crate::{app::settings::Settings, backends::SDL_CONTEXT};\n use rustzx_core::{\n-    zx::{joy::kempston::KempstonKey, keys::ZXKey},\n+    zx::{\n+        joy::{\n+            kempston::KempstonKey,\n+            sinclair::{SinclairJoyNum, SinclairKey},\n+        },\n+        keys::{CompoundKey, ZXKey},\n+        mouse::kempston::{KempstonMouseButton, KempstonMouseWheelDirection},\n+    },\n     EmulationSpeed,\n };\n-use sdl2::{event::Event as SdlEvent, keyboard::Scancode, EventPump};\n+use sdl2::{\n+    event::Event as SdlEvent,\n+    keyboard::Scancode,\n+    mouse::{MouseButton, MouseUtil},\n+    EventPump,\n+};\n \n \/\/\/ Represents SDL Envets bakend\n pub struct EventsSdl {\n     event_pump: EventPump,\n+    mouse: MouseUtil,\n+    kempston_enabled: bool,\n+    mouse_enabled: bool,\n+    mouse_locked: bool,\n+    screen_scale: usize,\n+    mouse_sensitivity: usize,\n+    enable_joy_keyaboard_layer: bool,\n+    mouse_x_counter: i32,\n+    mouse_y_counter: i32,\n }\n \n impl EventsSdl {\n     \/\/\/ constructs new event backend from setttigs\/\n     \/\/\/ Settings will be used in future for key bindings sittings\n-    pub fn new(_settings: &Settings) -> EventsSdl {\n+    pub fn new(settings: &Settings) -> EventsSdl {\n         \/\/ init event system\n-        let mut pump = None;\n-        SDL_CONTEXT.with(|sdl| {\n-            pump = sdl.borrow_mut().event_pump().ok();\n+        let (event_pump, mouse) = SDL_CONTEXT.with(|sdl| {\n+            let context = sdl.borrow_mut();\n+            let pump = context\n+                .event_pump()\n+                .expect(\"[ERROR] Sdl event pump init error\");\n+\n+            let mouse = context.mouse();\n+\n+            (pump, mouse)\n         });\n-        if let Some(pump) = pump {\n-            EventsSdl { event_pump: pump }\n-        } else {\n-            panic!(\"[ERROR] Sdl event pump init error\");\n+\n+        EventsSdl {\n+            event_pump,\n+            mouse,\n+            mouse_enabled: settings.enable_mouse,\n+            mouse_locked: false,\n+            kempston_enabled: !settings.disable_kempston,\n+            screen_scale: settings.scale,\n+            enable_joy_keyaboard_layer: false,\n+            mouse_sensitivity: settings.mouse_sensitivity,\n+            mouse_x_counter: 0,\n+            mouse_y_counter: 0,\n+        }\n+    }\n+\n+    fn lock_mouse(&mut self) {\n+        if self.mouse_enabled {\n+            self.mouse.set_relative_mouse_mode(true);\n+            self.mouse.show_cursor(false);\n+            self.mouse_locked = true;\n+        }\n+    }\n+\n+    fn unlock_mouse(&mut self) {\n+        if self.mouse_enabled {\n+            self.mouse.set_relative_mouse_mode(false);\n+            self.mouse.show_cursor(true);\n+            self.mouse_locked = false;\n         }\n     }\n \n     \/\/\/ returns ZX Spectum key form scancode of None if not found\n-    fn scancode_to_zxkey(&self, scancode: Option<Scancode>) -> Option<ZXKey> {\n-        match scancode? {\n+    fn scancode_to_zxkey_event(&self, scancode: Option<Scancode>, pressed: bool) -> Option<Event> {\n+        let zxkey_event = match scancode? {\n             \/\/ FEFE\n             Scancode::LShift | Scancode::RShift => Some(ZXKey::Shift),\n             Scancode::Z => Some(ZXKey::Z),\n@@ -80,18 +131,109 @@ impl EventsSdl {\n             Scancode::N => Some(ZXKey::N),\n             Scancode::B => Some(ZXKey::B),\n             _ => None,\n-        }\n+        };\n+\n+        zxkey_event.map(|k| Event::ZXKey(k, pressed))\n+    }\n+\n+    fn scancode_to_compound_key_event(\n+        &self,\n+        scancode: Option<Scancode>,\n+        pressed: bool,\n+    ) -> Option<Event> {\n+        let compound_key_event = match scancode? {\n+            Scancode::Up => Some(CompoundKey::ArrowUp),\n+            Scancode::Down => Some(CompoundKey::ArrowDown),\n+            Scancode::Left => Some(CompoundKey::ArrowLeft),\n+            Scancode::Right => Some(CompoundKey::ArrowDown),\n+            Scancode::CapsLock => Some(CompoundKey::CapsLock),\n+            Scancode::Backspace => Some(CompoundKey::Delete),\n+            Scancode::End => Some(CompoundKey::Break),\n+            _ => None,\n+        };\n+\n+        compound_key_event.map(|k| Event::CompoundKey(k, pressed))\n     }\n \n     \/\/\/ returns kempston key form scancode of None if not found\n-    fn scancode_to_joy(&self, scancode: Option<Scancode>) -> Option<KempstonKey> {\n-        match scancode? {\n+    fn scancode_to_kempston_event(\n+        &self,\n+        scancode: Option<Scancode>,\n+        pressed: bool,\n+    ) -> Option<Event> {\n+        if !(self.kempston_enabled && self.enable_joy_keyaboard_layer) {\n+            return None;\n+        }\n+\n+        let kempston_event = match scancode? {\n             Scancode::LAlt | Scancode::RAlt => Some(KempstonKey::Fire),\n             Scancode::Up => Some(KempstonKey::Up),\n             Scancode::Down => Some(KempstonKey::Down),\n             Scancode::Left => Some(KempstonKey::Left),\n             Scancode::Right => Some(KempstonKey::Right),\n             _ => None,\n+        };\n+\n+        kempston_event.map(|k| Event::Kempston(k, pressed))\n+    }\n+\n+    fn scancode_to_sinclair_event(\n+        &self,\n+        scancode: Option<Scancode>,\n+        pressed: bool,\n+    ) -> Option<Event> {\n+        if !self.enable_joy_keyaboard_layer {\n+            return None;\n+        }\n+\n+        let sinclair_event = match scancode? {\n+            \/\/ Joy 1\n+            Scancode::A => Some((SinclairJoyNum::Fist, SinclairKey::Left)),\n+            Scancode::W => Some((SinclairJoyNum::Fist, SinclairKey::Up)),\n+            Scancode::S => Some((SinclairJoyNum::Fist, SinclairKey::Down)),\n+            Scancode::D => Some((SinclairJoyNum::Fist, SinclairKey::Right)),\n+            Scancode::CapsLock => Some((SinclairJoyNum::Fist, SinclairKey::Fire)),\n+            \/\/ Joy 2\n+            Scancode::J => Some((SinclairJoyNum::Second, SinclairKey::Left)),\n+            Scancode::I => Some((SinclairJoyNum::Second, SinclairKey::Up)),\n+            Scancode::K => Some((SinclairJoyNum::Second, SinclairKey::Down)),\n+            Scancode::L => Some((SinclairJoyNum::Second, SinclairKey::Right)),\n+            Scancode::Return => Some((SinclairJoyNum::Second, SinclairKey::Fire)),\n+            _ => None,\n+        };\n+\n+        sinclair_event.map(|(n, k)| Event::Sinclair(n, k, pressed))\n+    }\n+\n+    fn scancode_to_emulator_event(\n+        &mut self,\n+        scancode: Option<Scancode>,\n+        pressed: bool,\n+    ) -> Option<Event> {\n+        if let (Some(code), true) = (scancode, pressed) {\n+            match code {\n+                Scancode::F1 => Some(Event::QuickSave),\n+                Scancode::F2 => Some(Event::QuickLoad),\n+                Scancode::F3 => Some(Event::ChangeSpeed(EmulationSpeed::Definite(1))),\n+                Scancode::F4 => Some(Event::ChangeSpeed(EmulationSpeed::Definite(2))),\n+                Scancode::F5 => Some(Event::ChangeSpeed(EmulationSpeed::Max)),\n+                Scancode::F6 => Some(Event::SwitchFrameTrace),\n+                Scancode::F9 => {\n+                    self.enable_joy_keyaboard_layer = !self.enable_joy_keyaboard_layer;\n+                    Some(Event::ChangeJoyKeyboardLayer(\n+                        self.enable_joy_keyaboard_layer,\n+                    ))\n+                }\n+                Scancode::Insert => Some(Event::InsertTape),\n+                Scancode::Delete => Some(Event::StopTape),\n+                Scancode::Escape => {\n+                    self.unlock_mouse();\n+                    None\n+                }\n+                _ => None,\n+            }\n+        } else {\n+            None\n         }\n     }\n }\n@@ -107,43 +249,81 @@ impl EventDevice for EventsSdl {\n                 \/\/ if any key pressed\n                 action @ SdlEvent::KeyDown { .. } | action @ SdlEvent::KeyUp { .. } => {\n                     \/\/ assemble tuple from scancode and its state\n-                    let (scancode, state) = match action {\n+                    let (scancode, pressed) = match action {\n                         SdlEvent::KeyDown { scancode: code, .. } => (code, true),\n                         SdlEvent::KeyUp { scancode: code, .. } => (code, false),\n                         _ => unreachable!(),\n                     };\n-                    if let Some(key) = self.scancode_to_zxkey(scancode) {\n-                        \/\/ if zx spectrum key found\n-                        Some(Event::GameKey(key, state))\n-                    } else if let Some(key) = self.scancode_to_joy(scancode) {\n-                        \/\/ of kempston key found\n-                        Some(Event::Kempston(key, state))\n+\n+                    \/\/ Form highest priority event to lowest\n+                    self.scancode_to_emulator_event(scancode, pressed)\n+                        .or_else(|| self.scancode_to_kempston_event(scancode, pressed))\n+                        .or_else(|| self.scancode_to_sinclair_event(scancode, pressed))\n+                        .or_else(|| self.scancode_to_zxkey_event(scancode, pressed))\n+                        .or_else(|| self.scancode_to_compound_key_event(scancode, pressed))\n+                }\n+                SdlEvent::MouseMotion { xrel, yrel, .. } => {\n+                    \/\/ Change of direction  requires counter reset to elimiate lag\n+                    if self.mouse_x_counter.signum() != xrel.signum() {\n+                        self.mouse_x_counter = xrel;\n+                    } else {\n+                        self.mouse_x_counter += xrel;\n+                    }\n+                    if self.mouse_y_counter.signum() != yrel.signum() {\n+                        self.mouse_y_counter = yrel;\n                     } else {\n-                        \/\/ if speial keys are used\n-                        if state {\n-                            if let Some(code) = scancode {\n-                                match code {\n-                                    \/\/ speed control\n-                                    Scancode::F3 => {\n-                                        Some(Event::ChangeSpeed(EmulationSpeed::Definite(1)))\n-                                    }\n-                                    Scancode::F4 => {\n-                                        Some(Event::ChangeSpeed(EmulationSpeed::Definite(2)))\n-                                    }\n-                                    Scancode::F5 => Some(Event::ChangeSpeed(EmulationSpeed::Max)),\n-                                    \/\/ debug info control\n-                                    Scancode::F6 => Some(Event::SwitchDebug),\n-                                    \/\/ tape control\n-                                    Scancode::Insert => Some(Event::InsertTape),\n-                                    Scancode::Delete => Some(Event::StopTape),\n-                                    _ => None,\n-                                }\n-                            } else {\n-                                None\n-                            }\n+                        self.mouse_y_counter += yrel;\n+                    }\n+\n+                    \/\/ Depending on sensitivity, diffent distance is required to move\n+                    \/\/ kempston mouse\n+                    let ticks_to_move =\n+                        sensitivity_to_mouse_counter_ticks(self.mouse_sensitivity) as i32;\n+                    let xshift = self.mouse_x_counter \/ ticks_to_move;\n+                    let yshift = self.mouse_y_counter \/ ticks_to_move;\n+                    let xrem = self.mouse_x_counter % ticks_to_move;\n+                    let yrem = self.mouse_y_counter % ticks_to_move;\n+                    if xshift != 0 {\n+                        self.mouse_x_counter = xrem;\n+                    }\n+                    if yshift != 0 {\n+                        self.mouse_y_counter = yrem;\n+                    }\n+\n+                    if self.mouse_locked {\n+                        let x = xshift.clamp(i8::MIN as i32, i8::MAX as i32) as i8;\n+                        let y = yshift.clamp(i8::MIN as i32, i8::MAX as i32) as i8;\n+                        Some(Event::MouseMove { x, y })\n+                    } else {\n+                        None\n+                    }\n+                }\n+                SdlEvent::MouseButtonDown { mouse_btn, .. } => {\n+                    self.lock_mouse();\n+                    if self.mouse_locked {\n+                        sdl_mouse_button_to_kempston(mouse_btn)\n+                            .map(|button| Event::MouseButton(button, true))\n+                    } else {\n+                        None\n+                    }\n+                }\n+                SdlEvent::MouseButtonUp { mouse_btn, .. } => {\n+                    if self.mouse_locked {\n+                        sdl_mouse_button_to_kempston(mouse_btn)\n+                            .map(|button| Event::MouseButton(button, false))\n+                    } else {\n+                        None\n+                    }\n+                }\n+                SdlEvent::MouseWheel { y, .. } => {\n+                    if self.mouse_locked {\n+                        if y > 0 {\n+                            Some(Event::MouseWheel(KempstonMouseWheelDirection::Up))\n                         } else {\n-                            None\n+                            Some(Event::MouseWheel(KempstonMouseWheelDirection::Down))\n                         }\n+                    } else {\n+                        None\n                     }\n                 }\n                 SdlEvent::DropFile { filename, .. } => Some(Event::OpenFile(filename.into())),\n@@ -154,3 +334,20 @@ impl EventDevice for EventsSdl {\n         }\n     }\n }\n+\n+fn sdl_mouse_button_to_kempston(button: MouseButton) -> Option<KempstonMouseButton> {\n+    match button {\n+        MouseButton::Left => Some(KempstonMouseButton::Left),\n+        MouseButton::Right => Some(KempstonMouseButton::Right),\n+        MouseButton::Middle => Some(KempstonMouseButton::Middle),\n+        MouseButton::X1 => Some(KempstonMouseButton::Additional),\n+        _ => None,\n+    }\n+}\n+\n+fn sensitivity_to_mouse_counter_ticks(sensitivity: usize) -> usize {\n+    const MIN_MOUSE_SENSITIVITY: usize = 1;\n+    const MAX_MOUSE_SENSITIVITY: usize = 100;\n+\n+    MAX_MOUSE_SENSITIVITY \/ sensitivity.clamp(MIN_MOUSE_SENSITIVITY, MAX_MOUSE_SENSITIVITY)\n+}\ndiff --git a\/rustzx\/src\/app\/events\/mod.rs b\/rustzx\/src\/app\/events\/mod.rs\nindex 75b1194..d413839 100644\n--- a\/rustzx\/src\/app\/events\/mod.rs\n+++ b\/rustzx\/src\/app\/events\/mod.rs\n@@ -3,7 +3,14 @@\n mod events_sdl;\n \n use rustzx_core::{\n-    zx::{joy::kempston::KempstonKey, keys::ZXKey},\n+    zx::{\n+        joy::{\n+            kempston::KempstonKey,\n+            sinclair::{SinclairJoyNum, SinclairKey},\n+        },\n+        keys::{CompoundKey, ZXKey},\n+        mouse::kempston::{KempstonMouseButton, KempstonMouseWheelDirection},\n+    },\n     EmulationSpeed,\n };\n use std::path::PathBuf;\n@@ -12,15 +19,20 @@ pub use events_sdl::EventsSdl;\n \n \/\/ Event type\n pub enum Event {\n-    GameKey(ZXKey, bool),\n+    ZXKey(ZXKey, bool),\n+    CompoundKey(CompoundKey, bool),\n     Kempston(KempstonKey, bool),\n-    SwitchDebug,\n+    Sinclair(SinclairJoyNum, SinclairKey, bool),\n+    MouseMove { x: i8, y: i8 },\n+    MouseButton(KempstonMouseButton, bool),\n+    MouseWheel(KempstonMouseWheelDirection),\n+    SwitchFrameTrace,\n+    ChangeJoyKeyboardLayer(bool),\n     ChangeSpeed(EmulationSpeed),\n     InsertTape,\n     StopTape,\n-    \/\/ QuickSave,\n-    \/\/ QuickLoad,\n-    \/\/ Pause,\n+    QuickSave,\n+    QuickLoad,\n     OpenFile(PathBuf),\n     Exit,\n }\ndiff --git a\/rustzx\/src\/app\/rustzx.rs b\/rustzx\/src\/app\/rustzx.rs\nindex dadb2db..1d9e1d5 100644\n--- a\/rustzx\/src\/app\/rustzx.rs\n+++ b\/rustzx\/src\/app\/rustzx.rs\n@@ -9,17 +9,19 @@ use crate::{\n         sound::{SoundDevice, SoundSdl},\n         video::{Rect, TextureInfo, VideoDevice, VideoSdl},\n     },\n-    host::{self, AppHost, AppHostContext, DetectedFileKind},\n+    host::{self, AppHost, AppHostContext, DetectedFileKind, FileAsset},\n };\n use anyhow::anyhow;\n use rustzx_core::{\n+    host::SnapshotRecorder,\n     zx::constants::{\n         CANVAS_HEIGHT, CANVAS_WIDTH, CANVAS_X, CANVAS_Y, FPS, SCREEN_HEIGHT, SCREEN_WIDTH,\n     },\n     Emulator, Stopwatch,\n };\n use std::{\n-    path::Path,\n+    fs::{self, File},\n+    path::{Path, PathBuf},\n     thread,\n     time::{Duration, Instant},\n };\n@@ -75,6 +77,10 @@ pub struct RustzxApp {\n     tex_border: TextureInfo,\n     tex_canvas: TextureInfo,\n     scale: u32,\n+    settings: Settings,\n+\n+    enable_frame_trace: bool,\n+    enable_joy_keyaboard_layer: bool,\n }\n \n impl RustzxApp {\n@@ -110,6 +116,8 @@ impl RustzxApp {\n                 .map_err(|e| anyhow!(\"Emulator failed to load tape: {}\", e))?;\n         }\n \n+        let file_autodetect = settings.file_autodetect.clone();\n+\n         let mut app = RustzxApp {\n             emulator,\n             snd,\n@@ -118,17 +126,35 @@ impl RustzxApp {\n             tex_border,\n             tex_canvas,\n             scale,\n+            settings,\n+            enable_frame_trace: cfg!(debug_assertions),\n+            enable_joy_keyaboard_layer: false,\n         };\n \n-        if let Some(file) = settings.file_autodetect.as_ref() {\n+        if let Some(file) = file_autodetect.as_ref() {\n             app.load_file_autodetect(file)?;\n         }\n \n+        app.update_window_title();\n+\n         Ok(app)\n     }\n \n+    fn update_window_title(&mut self) {\n+        let mut title = format!(\"{} v{}\", env!(\"CARGO_PKG_NAME\"), env!(\"CARGO_PKG_VERSION\"));\n+\n+        if self.enable_joy_keyaboard_layer {\n+            title.push_str(\" [JOY]\");\n+        }\n+\n+        if self.enable_frame_trace {\n+            title.push_str(\" [FRAME_TRACE]\");\n+        }\n+\n+        self.video.set_title(&title);\n+    }\n+\n     pub fn start(&mut self) -> anyhow::Result<()> {\n-        let mut debug = false;\n         let scale = self.scale;\n         let mut stopwatch = InstantStopwatch::default();\n         'emulator: loop {\n@@ -176,20 +202,21 @@ impl RustzxApp {\n             );\n             self.video.end();\n             \/\/ check all events\n-            if let Some(event) = self.events.pop_event() {\n+            while let Some(event) = self.events.pop_event() {\n                 match event {\n                     Event::Exit => {\n                         break 'emulator;\n                     }\n-                    Event::GameKey(key, state) => {\n+                    Event::ZXKey(key, state) => {\n                         self.emulator.send_key(key, state);\n                     }\n-                    Event::SwitchDebug => {\n-                        debug = !debug;\n-                        if !debug {\n-                            self.video\n-                                .set_title(&format!(\"RustZX v{}\", env!(\"CARGO_PKG_VERSION\")));\n-                        }\n+                    Event::SwitchFrameTrace => {\n+                        self.enable_frame_trace = !self.enable_frame_trace;\n+                        self.update_window_title();\n+                    }\n+                    Event::ChangeJoyKeyboardLayer(value) => {\n+                        self.enable_joy_keyaboard_layer = value;\n+                        self.update_window_title();\n                     }\n                     Event::ChangeSpeed(speed) => {\n                         self.emulator.set_speed(speed);\n@@ -197,9 +224,26 @@ impl RustzxApp {\n                     Event::Kempston(key, state) => {\n                         self.emulator.send_kempston_key(key, state);\n                     }\n+                    Event::Sinclair(num, key, state) => {\n+                        self.emulator.send_sinclair_key(num, key, state);\n+                    }\n+                    Event::CompoundKey(key, state) => {\n+                        self.emulator.send_compound_key(key, state);\n+                    }\n+                    Event::MouseMove { x, y } => {\n+                        self.emulator.send_mouse_pos(x, y);\n+                    }\n+                    Event::MouseButton(buton, pressed) => {\n+                        self.emulator.send_mouse_button(buton, pressed);\n+                    }\n+                    Event::MouseWheel(direction) => {\n+                        self.emulator.send_mouse_wheel(direction);\n+                    }\n                     Event::InsertTape => self.emulator.play_tape(),\n                     Event::StopTape => self.emulator.stop_tape(),\n                     Event::OpenFile(path) => self.load_file_autodetect(&path)?,\n+                    Event::QuickSave => self.quick_save()?,\n+                    Event::QuickLoad => self.quick_load()?,\n                 }\n             }\n             \/\/ how long emulation iteration was\n@@ -212,12 +256,12 @@ impl RustzxApp {\n             \/\/ get exceed clocks and use them on next iteration\n             let frame_dt = frame_start.elapsed();\n             \/\/ change window header\n-            if debug {\n-                self.video.set_title(&format!(\n+            if self.enable_frame_trace {\n+                log::trace!(\n                     \"CPU: {:7.3}ms; FRAME:{:7.3}ms\",\n                     cpu_dt.as_millis(),\n                     frame_dt.as_millis()\n-                ));\n+                );\n             }\n         }\n         Ok(())\n@@ -240,4 +284,48 @@ impl RustzxApp {\n         }\n         Ok(())\n     }\n+\n+    fn quick_save(&mut self) -> anyhow::Result<()> {\n+        let new_path = self.last_quick_snapshot_path();\n+        let prev_path = self.prev_quick_snapshot_path();\n+\n+        if new_path.exists() {\n+            if prev_path.exists() {\n+                fs::remove_file(&prev_path)?;\n+            }\n+            fs::rename(&new_path, &prev_path)?;\n+        }\n+\n+        let recorder = SnapshotRecorder::Sna(FileAsset::from(File::create(new_path)?));\n+        self.emulator\n+            .save_snapshot(recorder)\n+            .map_err(|e| anyhow!(\"Failed to save qick snapshot: {}\", e))?;\n+        Ok(())\n+    }\n+\n+    fn quick_load(&mut self) -> anyhow::Result<()> {\n+        let last_snapshot_path = self.last_quick_snapshot_path();\n+        if !last_snapshot_path.exists() {\n+            log::warn!(\"Quick snapshot was not found\");\n+            return Ok(());\n+        }\n+        self.emulator\n+            .load_snapshot(host::load_snapshot(&last_snapshot_path)?)\n+            .map_err(|e| anyhow!(\"Emulator failed to load quick snapshot: {}\", e))?;\n+        Ok(())\n+    }\n+\n+    fn last_quick_snapshot_path(&self) -> PathBuf {\n+        if let Some(path) = self.settings.file_autodetect.as_ref() {\n+            return path.with_extension(\".rustzx.last.sna\");\n+        }\n+        Path::new(\"default.rustzx.last.sna\").to_owned()\n+    }\n+\n+    fn prev_quick_snapshot_path(&self) -> PathBuf {\n+        if let Some(path) = self.settings.file_autodetect.as_ref() {\n+            return path.with_extension(\".rustzx.prev.sna\");\n+        }\n+        Path::new(\"default.rustzx.prev.sna\").to_owned()\n+    }\n }\ndiff --git a\/rustzx\/src\/app\/settings.rs b\/rustzx\/src\/app\/settings.rs\nindex a32cb2e..9eb25e8 100644\n--- a\/rustzx\/src\/app\/settings.rs\n+++ b\/rustzx\/src\/app\/settings.rs\n@@ -22,14 +22,24 @@ pub struct Settings {\n     \/\/\/ Disable fast tape loading\n     #[structopt(long = \"nofastload\")]\n     pub disable_fastload: bool,\n+    \/\/\/ Disable automatic tape loading via placing emulator to tape load state immediately\n+    \/\/\/ after launch\n+    #[structopt(long = \"noautoload\")]\n+    pub disable_autoload: bool,\n     \/\/\/ Set windows scale for emulator. Can be set as decimal non-zero value. Defaults to 2\n     #[structopt(short, long, default_value = \"2\", parse(try_from_str = scale_from_str))]\n     pub scale: usize,\n-    \/\/\/ Disable kempston joy support. In enabled, arrow and `Alt` keys are bound by default\n-    \/\/\/ to the kempston joy.\n+    \/\/\/ Disable kempston joy support. If enabled, arrow and `Alt` keys are bound by default\n+    \/\/\/ to the kempston joy\n     #[structopt(long = \"nokempston\")]\n     pub disable_kempston: bool,\n-    \/\/\/ Set AY-3-8910 sound chip mode. Can be set to `mono`, `abc`(stereo) or `acb`(stereo).\n+    \/\/\/ Enables kempston mouse support. If enabled, locks mouse in application\n+    #[structopt(long = \"mouse\")]\n+    pub enable_mouse: bool,\n+    \/\/\/ Sets mouse sensitivity [1..=100]. Defaults to 20\n+    #[structopt(long = \"mouse-sensitivity\", default_value = \"20\")]\n+    pub mouse_sensitivity: usize,\n+    \/\/\/ Set AY-3-8910 sound chip mode. Can be set to `mono`, `abc`(stereo) or `acb`(stereo)\n     \/\/\/ Defaults to `abc`\n     #[structopt(long, default_value = \"abc\", parse(try_from_str = ay_mode_from_str))]\n     \/\/\/ Disable AY-3-8910 chip support\n@@ -145,8 +155,9 @@ impl Settings {\n         RustzxSettings {\n             machine: self.machine,\n             emulation_speed: self.speed,\n-            tape_fastload: !self.disable_fastload,\n-            enable_kempston: !self.disable_kempston,\n+            tape_fastload_enabled: !self.disable_fastload,\n+            kempston_enabled: !self.disable_kempston,\n+            mouse_enabled: self.enable_mouse,\n             ay_mode: self.ay_mode,\n             ay_enabled,\n             beeper_enabled: !self.disable_beeper,\n@@ -154,6 +165,7 @@ impl Settings {\n             sound_volume: 100,\n             load_default_rom: self.rom.is_none(),\n             sound_sample_rate: self.sound_sample_rate,\n+            autoload_enabled: !self.disable_autoload,\n         }\n     }\n }\ndiff --git a\/rustzx\/src\/app\/video\/video_sdl.rs b\/rustzx\/src\/app\/video\/video_sdl.rs\nindex d421f01..2010794 100644\n--- a\/rustzx\/src\/app\/video\/video_sdl.rs\n+++ b\/rustzx\/src\/app\/video\/video_sdl.rs\n@@ -32,11 +32,7 @@ impl VideoSdl {\n                 SCREEN_HEIGHT * settings.scale,\n             );\n             let window = video\n-                .window(\n-                    &format!(\"RustZX v{}\", env!(\"CARGO_PKG_VERSION\")),\n-                    width as u32,\n-                    height as u32,\n-                )\n+                .window(\"RustZX\", width as u32, height as u32)\n                 .position_centered()\n                 .opengl()\n                 .build()\ndiff --git a\/rustzx\/src\/host\/io.rs b\/rustzx\/src\/host\/io.rs\nindex 93b5e6a..66b94c0 100644\n--- a\/rustzx\/src\/host\/io.rs\n+++ b\/rustzx\/src\/host\/io.rs\n@@ -1,11 +1,11 @@\n use rustzx_core::{\n-    error::AssetReadError,\n-    host::{LoadableAsset, SeekFrom},\n+    error::IoError,\n+    host::{DataRecorder, LoadableAsset, SeekFrom, SeekableAsset},\n };\n \n use std::{\n     fs::File,\n-    io::{Read, Seek},\n+    io::{Read, Seek, Write},\n };\n \n pub struct FileAsset {\n@@ -18,25 +18,36 @@ impl From<File> for FileAsset {\n     }\n }\n \n-impl LoadableAsset for FileAsset {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<usize, AssetReadError> {\n-        self.file.read(buf).map_err(|e| {\n-            log::error!(\"Failed to read asset: {}\", e);\n-            AssetReadError::HostAssetImplFailed\n-        })\n-    }\n-\n-    fn seek(&mut self, pos: SeekFrom) -> Result<usize, AssetReadError> {\n+impl SeekableAsset for FileAsset {\n+    fn seek(&mut self, pos: SeekFrom) -> Result<usize, IoError> {\n         self.file\n             .seek(into_std_seek_pos(pos))\n             .map_err(|e| {\n                 log::error!(\"Failed to seeek asset: {}\", e);\n-                AssetReadError::HostAssetImplFailed\n+                IoError::HostAssetImplFailed\n             })\n             .map(|count| count as usize)\n     }\n }\n \n+impl LoadableAsset for FileAsset {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize, IoError> {\n+        self.file.read(buf).map_err(|e| {\n+            log::error!(\"Failed to read asset: {}\", e);\n+            IoError::HostAssetImplFailed\n+        })\n+    }\n+}\n+\n+impl DataRecorder for FileAsset {\n+    fn write(&mut self, buf: &[u8]) -> Result<usize, IoError> {\n+        self.file.write(buf).map_err(|e| {\n+            log::error!(\"Failed to write data to file: {}\", e);\n+            IoError::HostAssetImplFailed\n+        })\n+    }\n+}\n+\n fn into_std_seek_pos(pos: SeekFrom) -> std::io::SeekFrom {\n     match pos {\n         SeekFrom::Start(offset) => std::io::SeekFrom::Start(offset as u64),\ndiff --git a\/rustzx\/src\/host\/mod.rs b\/rustzx\/src\/host\/mod.rs\nindex 190a571..5fbc868 100644\n--- a\/rustzx\/src\/host\/mod.rs\n+++ b\/rustzx\/src\/host\/mod.rs\n@@ -3,7 +3,7 @@ mod io;\n \n use anyhow::{anyhow, bail, Context};\n use frame_buffer::{FrameBufferContext, RgbaFrameBuffer};\n-use io::FileAsset;\n+pub use io::FileAsset;\n use rustzx_core::{\n     host::{FrameBuffer, Host, HostContext, RomFormat, RomSet, Snapshot, Tape},\n     zx::machine::ZXMachine,\n@@ -19,7 +19,6 @@ impl Host for AppHost {\n     type Context = AppHostContext;\n     type FrameBuffer = RgbaFrameBuffer;\n     type RomSet = FileRomSet;\n-    type SnapshotAsset = FileAsset;\n     type TapeAsset = FileAsset;\n }\n \ndiff --git a\/vtx\/Cargo.toml b\/vtx\/Cargo.toml\nindex 418d181..2a4c89a 100644\n--- a\/vtx\/Cargo.toml\n+++ b\/vtx\/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"vtx\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n description = \"VTX sound format parsing and playback library\"\n authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n edition = \"2018\"\n@@ -14,7 +14,7 @@ thiserror = \"1\"\n byteorder = \"1\"\n num-traits = { version = \"0.2\", default-features = false }\n num-derive = \"0.3\"\n-aym = { version = \"0.1\", path = \"..\/aym\" }\n+aym = { version = \"0.1.1\", path = \"..\/aym\" }\n \n [dev-dependencies]\n expect-test = \"1\"\ndiff --git a\/vtx\/src\/lib.rs b\/vtx\/src\/lib.rs\nindex 465952b..985acfa 100644\n--- a\/vtx\/src\/lib.rs\n+++ b\/vtx\/src\/lib.rs\n@@ -1,8 +1,6 @@\n \/\/! VTX sound format parsing library\n \/\/!\n \/\/! See sources of `vtx-bin` crate for usage example\n-#![allow(dead_code)]\n-\n pub mod player;\n \n use byteorder::{LittleEndian, ReadBytesExt};\ndiff --git a\/vtx\/vtx-bin\/Cargo.toml b\/vtx\/vtx-bin\/Cargo.toml\nindex 50d2eba..7524d13 100644\n--- a\/vtx\/vtx-bin\/Cargo.toml\n+++ b\/vtx\/vtx-bin\/Cargo.toml\n@@ -1,7 +1,7 @@\n [package]\n name = \"vtx-bin\"\n description = \"VTX sound format toolbox\"\n-version = \"0.1.0\"\n+version = \"0.1.1\"\n authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n edition = \"2018\"\n license = \"MIT\"\n","test_patch":"","problem_statement":"Automatic binary release preparation from CI on master\nAdd a new CI step to prepare binary releases on each push to master with the higher crate version.\r\n- Also, maybe publish to crates.io also can be automized \n","hints_text":"","created_at":1621,"merge_commit_sha":"b109a56ca15210dc8ebc59a2ac57d33eb639497b","ci_name_list":[]}
{"repo":"linebender\/resvg","pull_number":690,"instance_id":"linebender__resvg-690","issue_numbers":["685"],"base_commit":"701539c715b97452ed2a10b59504d9f45c1a7e3b","patch":"diff --git a\/crates\/resvg\/src\/filter\/mod.rs b\/crates\/resvg\/src\/filter\/mod.rs\nindex 4ad198a91..ebeef5058 100644\n--- a\/crates\/resvg\/src\/filter\/mod.rs\n+++ b\/crates\/resvg\/src\/filter\/mod.rs\n@@ -972,7 +972,15 @@ fn apply_image(\n         }\n         usvg::filter::ImageKind::Use(ref node) => {\n             let (sx, sy) = ts.get_scale();\n-            let transform = tiny_skia::Transform::from_scale(sx, sy);\n+\n+            let transform = tiny_skia::Transform::from_row(\n+                sx,\n+                0.0,\n+                0.0,\n+                sy,\n+                subregion.x() as f32,\n+                subregion.y() as f32,\n+            );\n \n             let ctx = crate::render::Context {\n                 max_bbox: tiny_skia::IntRect::from_xywh(0, 0, region.width(), region.height())\n","test_patch":"diff --git a\/crates\/resvg\/tests\/integration\/render.rs b\/crates\/resvg\/tests\/integration\/render.rs\nindex 56c41cf8d..2843f39b7 100644\n--- a\/crates\/resvg\/tests\/integration\/render.rs\n+++ b\/crates\/resvg\/tests\/integration\/render.rs\n@@ -196,6 +196,9 @@ use crate::render;\n #[test] fn filters_feImage_with_subregion_3() { assert_eq!(render(\"tests\/filters\/feImage\/with-subregion-3\"), 0); }\n #[test] fn filters_feImage_with_subregion_4() { assert_eq!(render(\"tests\/filters\/feImage\/with-subregion-4\"), 0); }\n #[test] fn filters_feImage_with_subregion_5() { assert_eq!(render(\"tests\/filters\/feImage\/with-subregion-5\"), 0); }\n+#[test] fn filters_feImage_with_x_y_and_protruding_subregion_1() { assert_eq!(render(\"tests\/filters\/feImage\/with-x-y-and-protruding-subregion-1\"), 0); }\n+#[test] fn filters_feImage_with_x_y_and_protruding_subregion_2() { assert_eq!(render(\"tests\/filters\/feImage\/with-x-y-and-protruding-subregion-2\"), 0); }\n+#[test] fn filters_feImage_with_x_y() { assert_eq!(render(\"tests\/filters\/feImage\/with-x-y\"), 0); }\n #[test] fn filters_feMerge_color_interpolation_filters_eq_linearRGB() { assert_eq!(render(\"tests\/filters\/feMerge\/color-interpolation-filters=linearRGB\"), 0); }\n #[test] fn filters_feMerge_color_interpolation_filters_eq_sRGB() { assert_eq!(render(\"tests\/filters\/feMerge\/color-interpolation-filters=sRGB\"), 0); }\n #[test] fn filters_feMerge_complex_transform() { assert_eq!(render(\"tests\/filters\/feMerge\/complex-transform\"), 0); }\ndiff --git a\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y-and-protruding-subregion-1.png b\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y-and-protruding-subregion-1.png\nnew file mode 100644\nindex 000000000..88e2c6fb1\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y-and-protruding-subregion-1.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y-and-protruding-subregion-1.svg b\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y-and-protruding-subregion-1.svg\nnew file mode 100644\nindex 000000000..43e051132\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y-and-protruding-subregion-1.svg\n@@ -0,0 +1,15 @@\n+<svg width=\"200\" height=\"200\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+     xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\">\n+    <title>With x and y<\/title>\n+    <defs>\n+        <rect fill=\"green\" id=\"rect3\" width=\"100\" height=\"100\"\/>\n+        <filter id=\"filter1\" >\n+            <feImage xlink:href=\"#rect3\" x=\"60\" y=\"90\"\/>\n+        <\/filter>\n+    <\/defs>\n+    <rect id=\"rect2\" x=\"50\" y=\"50\" width=\"100\" height=\"100\" fill=\"#1e1705\" filter=\"url(#filter1)\"\/>\n+    <rect id=\"rect1\" x=\"50\" y=\"50\" width=\"100\" height=\"100\" stroke=\"#00f\" fill=\"none\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\n\\ No newline at end of file\ndiff --git a\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y-and-protruding-subregion-2.png b\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y-and-protruding-subregion-2.png\nnew file mode 100644\nindex 000000000..5f16e4bca\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y-and-protruding-subregion-2.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y-and-protruding-subregion-2.svg b\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y-and-protruding-subregion-2.svg\nnew file mode 100644\nindex 000000000..4ac91da77\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y-and-protruding-subregion-2.svg\n@@ -0,0 +1,15 @@\n+<svg width=\"200\" height=\"200\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+     xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\">\n+    <title>With x and y<\/title>\n+    <defs>\n+        <rect fill=\"green\" id=\"rect3\" width=\"100\" height=\"100\"\/>\n+        <filter id=\"filter1\" >\n+            <feImage xlink:href=\"#rect3\" x=\"20\" y=\"0\"\/>\n+        <\/filter>\n+    <\/defs>\n+    <rect id=\"rect2\" x=\"50\" y=\"50\" width=\"100\" height=\"100\" fill=\"#1e1705\" filter=\"url(#filter1)\"\/>\n+    <rect id=\"rect1\" x=\"50\" y=\"50\" width=\"100\" height=\"100\" stroke=\"#00f\" fill=\"none\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\n\\ No newline at end of file\ndiff --git a\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y.png b\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y.png\nnew file mode 100644\nindex 000000000..e4a462a74\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y.svg b\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y.svg\nnew file mode 100644\nindex 000000000..494ae12cd\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/filters\/feImage\/with-x-y.svg\n@@ -0,0 +1,15 @@\n+<svg width=\"200\" height=\"200\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+     xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\">\n+    <title>With x and y<\/title>\n+    <defs>\n+        <rect fill=\"green\" id=\"rect3\" width=\"100\" height=\"100\"\/>\n+        <filter id=\"filter1\" >\n+            <feImage xlink:href=\"#rect3\" x=\"50\" y=\"50\"\/>\n+        <\/filter>\n+    <\/defs>\n+    <rect id=\"rect2\" x=\"50\" y=\"50\" width=\"100\" height=\"100\" fill=\"#1e1705\" filter=\"url(#filter1)\"\/>\n+    <rect id=\"rect1\" x=\"50\" y=\"50\" width=\"100\" height=\"100\" stroke=\"#00f\" fill=\"none\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\n\\ No newline at end of file\n","problem_statement":"When `feImage` contains `x` or `y`, the rendering is incorrect.\n```xml\r\n<svg width=\"200\" height=\"200\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\">\r\n  <rect width=\"200\" height=\"200\" fill=\"#ffdd88\"\/>\r\n\r\n  <defs>\r\n    <rect fill=\"#ff0000\" opacity=\"1\" id=\"rect\" width=\"100\" height=\"100\"\/>\r\n    <filter id=\"colorful-image\" >\r\n      <feImage xlink:href=\"#rect\" href=\"#rect\" x=\"30\" y=\"50\" \r\n        result=\"feImageResultnode\" \/>\r\n      <feMerge>\r\n        <feMergeNode in=\"feImageResultnode\" \/>\r\n      <\/feMerge>\r\n    <\/filter>\r\n  <\/defs>\r\n  <rect x=\"30\" y=\"50\" width=\"100\" height=\"100\" fill=\"#1e1705\" filter=\"url(#colorful-image)\"\/>\r\n  <rect x=\"30\" y=\"50\" width=\"100\" height=\"100\" stroke=\"#00f\" fill=\"none\"\/>\r\n<\/svg>\r\n```\r\n![](https:\/\/pichuang.oss-cn-beijing.aliyuncs.com\/img\/202311221843954.png)\r\ni get left\n","hints_text":"In `filter\/mod.rs\/apply_inner`, content on the left and top was mistakenly cropped first. After that, the `sub_pixmap` wasn't drawn correctly to its respective position. Using `<feImage xlink:href=\"#rect\" href=\"#rect\" x=\"40\" y=\"60\"` will make the issue more apparent.\nWill take a look. `feImage` in general is a minefield and essentially unsupported. Mainly because it's completely undocumented and each library does [whatever it wants](https:\/\/razrfalcon.github.io\/resvg-test-suite\/svg-support-table.html#filters-feImage).","created_at":1703,"merge_commit_sha":"cb52988ae36efa3c5b82f2f5db6200d75b84db9d","ci_name_list":[]}
{"repo":"rustzx\/rustzx","pull_number":60,"instance_id":"rustzx__rustzx-60","issue_numbers":["53"],"base_commit":"bbde543e33354c7748c655b9e77608998dfad259","patch":"diff --git a\/.github\/workflows\/ci.yml b\/.github\/workflows\/ci.yml\nindex 5f78e0b..93aaa56 100644\n--- a\/.github\/workflows\/ci.yml\n+++ b\/.github\/workflows\/ci.yml\n@@ -14,7 +14,7 @@ jobs:\n     runs-on: ${{ matrix.os }}\n     strategy:\n       matrix:\n-        os: [ubuntu-latest, windows-latest]\n+        os: [ubuntu-latest, windows-latest, macos-latest]\n     steps:\n       - uses: actions\/checkout@v2\n       - uses: actions-rs\/toolchain@v1\n@@ -38,6 +38,16 @@ jobs:\n         with:\n           command: build\n           args: --release --all --all-features --verbose\n+      - name: Lib build - Minimal\n+        uses: actions-rs\/cargo@v1\n+        with:\n+          command: build\n+          args: --release -p rustzx-core --verbose\n+      - name: Lib build - Without AY\n+        uses: actions-rs\/cargo@v1\n+        with:\n+          command: build\n+          args: --release -p rustzx-core --features without-ay --verbose\n       - name: Test\n         uses: actions-rs\/cargo@v1\n         with:\ndiff --git a\/CHANGELOG.md b\/CHANGELOG.md\nnew file mode 100644\nindex 0000000..5a0e921\n--- \/dev\/null\n+++ b\/CHANGELOG.md\n@@ -0,0 +1,78 @@\n+### RustZX v0.11\n+Authors:\n+- Vladyslav Nikonov (@pacmancoder)\n+\n+Changes:\n+- **[Feature]** Separated project to `rustzx` application and `no_std`-capable `rustzx-core` crate\n+- **[Feature]** Updated CLI\n+    - More features now enabled by default\n+    - File autodetect from CLI\n+    - Added configurable sound sample rate\n+    - Removed redundant args\n+- **[Dependencies]** Switched to bundled `sdl` crate mode, making build almost dependecy-free (CMake and C compiller are still requird)\n+- **[Infrastructure]** Moved CI to _Github Actions_\n+    - Added `rustfmt` step to CI\n+    - Added `clippy` step to CI\n+- **[Refactroing]** Performed deep global refactoring of the project\n+    - Updated to Rust 2018 edition\n+    - Updated dependencies\n+    - Fixed all `clippy` errors\n+    - Minimized `rustzx-core` public interface\n+    - Added feature gates for resource-hungry `rustzx-core` features\n+    - Eliminated a lot of not redundant code\n+    - Made groundwork for a future emulator features\n+\n+### RustZX v0.9\n+Authors:\n+- Konstantin Mochalov (@kolen)\n+\n+Changes:\n+- **[Feature]** Drag-n-drop support for TAP and SNA files\n+- **[Refactoring]** Multiple small refactoring changes\n+- **[Dependencies]** Updated `sdl` crate\n+\n+### Pre-pelease\n+Authors:\n+- Vladyslav Nikonov (@pacmancoder)\n+\n+Changes:\n+- **[19.08.2016]** RustzxApp and RustzxSettings refactoring\n+- **[18.08.2016]** Moved sound, video, event to sdl lib.\n+- **[15.08.2016]** Moving from **portaudio** to **cpal**\n+- **[14.08.2016]** Kempston Joystick\n+- **[14.08.2016]** AY implementation finished\n+- **[12.08.2016]** AY implementation start\n+- **[09.08.2016]** Refactoring\n+- **[08.08.2016]** Aspect ratio correction, custom 128K rom loading\n+- **[08.08.2016]** Window scale selection with `--scale` option\n+- **[07.07.2016]** ZXScreen rewrite\n+- **[06.07.2016]** Base 128K features implemented\n+- **[05.07.2016]** v0.8 development started in branch `develop`\n+- **[27.06.2016]** Release v0.7.1\n+- **[26.06.2016]** Beeper sound implemented :notes:, release planed to July 1 :rocket:\n+- **[12.06.2016]** Some Comand line arguments fixes\/enchantments\n+- **[12.06.2016]** SNA files loading\n+- **[11.06.2016]** Command line arguments using **clap** crate\n+- **[11.06.2016]** Tap files fast loading implemented, finnaly!\n+- **[07.06.2016]** Speed improvements (maybe :smile:) in flag setting [z80]\n+- **[04.06.2016]** Border FX implemented\n+- **[28.05.2016]** Some architecture rewrite, working on border\n+- **[21.05.2016]** OVERSCAN and SHOCK demo's passed! :sparkles:\n+- **[21.05.2016]** Screen reorganization and OpenGL rendering part fix\n+- **[19.05.2016]** Documentation, Rustfmt\n+- **[15.05.2016]** Fixed bug in INC\/DEC (IX\/IY + dd). After 2 weeks :smile:\n+- **[12.05.2016]** Fixed CALL timings\n+- **[06.05.2016]** Floating bus fix\n+- **[28.04.2016]** All contentions implemented!\n+- **[24.04.2016]** Almost all contentions working perfectly (IO still broken)\n+- **[24.04.2016]** IM2 bug fixed, finally I found it! :smile:\n+- **[24.04.2016]** new Z80Bus interface, serious z80 emulation part rewrite\n+- **[22.04.2016]** work on implementing correct timings started.\n+- **[18.04.2016]** fixed many instruction bugs (IO section still not finished)\n+- **[12.04.2016]** fixed shader bug causing bad performance - palette was declared as non-const\n+- **[12.04.2016]** log file added\n+- **[29.03.2016]** Screen emulation, keyboard, test run of ROMs\n+- **[14.03.2016]** All features of CPU have been implemented :sunglasses:\n+- **[11.03.2016]** Serious code reorganization\n+- **[06.03.2016]** All Z80 instruction groups have been implemented! :tada:\n+- **[02.02.2016]** First commit\ndiff --git a\/Cargo.lock b\/Cargo.lock\nindex ed18f98..0077fcc 100644\n--- a\/Cargo.lock\n+++ b\/Cargo.lock\n@@ -17,6 +17,15 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"ansi_term\"\n+version = \"0.11.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"anyhow\"\n version = \"1.0.40\"\n@@ -74,36 +83,19 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"clap\"\n-version = \"3.0.0-beta.2\"\n+version = \"2.33.3\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"4bd1061998a501ee7d4b6d449020df3266ca3124b941ec56cf2005c3779ca142\"\n+checksum = \"37e58ac78573c40708d45522f0d80fa2f01cc4f9b4e2bf749807255454312002\"\n dependencies = [\n+ \"ansi_term\",\n  \"atty\",\n  \"bitflags\",\n- \"clap_derive\",\n- \"indexmap\",\n- \"lazy_static\",\n- \"os_str_bytes\",\n- \"strsim 0.10.0\",\n- \"termcolor\",\n+ \"strsim 0.8.0\",\n  \"textwrap\",\n  \"unicode-width\",\n  \"vec_map\",\n ]\n \n-[[package]]\n-name = \"clap_derive\"\n-version = \"3.0.0-beta.2\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"370f715b81112975b1b69db93e0b56ea4cd4e5002ac43b2da8474106a54096a1\"\n-dependencies = [\n- \"heck\",\n- \"proc-macro-error\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n [[package]]\n name = \"cmake\"\n version = \"0.1.45\"\n@@ -259,12 +251,6 @@ version = \"0.3.55\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"8f5f3913fa0bfe7ee1fd8248b6b9f42a5af4b9d65ec2dd2c3c26132b950ecfc2\"\n \n-[[package]]\n-name = \"hashbrown\"\n-version = \"0.9.1\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04\"\n-\n [[package]]\n name = \"heck\"\n version = \"0.3.2\"\n@@ -295,16 +281,6 @@ version = \"1.0.1\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39\"\n \n-[[package]]\n-name = \"indexmap\"\n-version = \"1.6.2\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"824845a0bf897a9042383849b02c1bc219c2383772efcd5c6f9766fa4b81aef3\"\n-dependencies = [\n- \"autocfg\",\n- \"hashbrown\",\n-]\n-\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\"\n@@ -348,12 +324,6 @@ version = \"1.7.2\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"af8b08b04175473088b46763e51ee54da5f9a164bc162f615b91bc179dbf15a3\"\n \n-[[package]]\n-name = \"os_str_bytes\"\n-version = \"2.4.0\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"afb2e1c3ee07430c2cf76151675e583e0f19985fa6efae47d6848a3e2c824f85\"\n-\n [[package]]\n name = \"proc-macro-error\"\n version = \"1.0.4\"\n@@ -424,21 +394,22 @@ checksum = \"24d5f089152e60f62d28b835fbff2cd2e8dc0baf1ac13343bef92ab7eed84548\"\n \n [[package]]\n name = \"rustzx\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n dependencies = [\n  \"anyhow\",\n- \"clap\",\n  \"env_logger\",\n  \"log\",\n  \"rustzx-core\",\n  \"sdl2\",\n+ \"structopt\",\n ]\n \n [[package]]\n name = \"rustzx-core\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n dependencies = [\n  \"ayumi\",\n+ \"bitflags\",\n  \"displaydoc\",\n  \"enum_dispatch\",\n  \"from_variants\",\n@@ -472,6 +443,12 @@ dependencies = [\n  \"version-compare\",\n ]\n \n+[[package]]\n+name = \"strsim\"\n+version = \"0.8.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n+\n [[package]]\n name = \"strsim\"\n version = \"0.9.3\"\n@@ -479,10 +456,28 @@ source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"6446ced80d6c486436db5c078dde11a9f73d42b57fb273121e160b84f63d894c\"\n \n [[package]]\n-name = \"strsim\"\n-version = \"0.10.0\"\n+name = \"structopt\"\n+version = \"0.3.21\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"5277acd7ee46e63e5168a80734c9f6ee81b1367a7d8772a2d765df2a3705d28c\"\n+dependencies = [\n+ \"clap\",\n+ \"lazy_static\",\n+ \"structopt-derive\",\n+]\n+\n+[[package]]\n+name = \"structopt-derive\"\n+version = \"0.4.14\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623\"\n+checksum = \"5ba9cdfda491b814720b6b06e0cac513d922fc407582032e8706e9f137976f90\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro-error\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n \n [[package]]\n name = \"syn\"\n@@ -517,9 +512,9 @@ dependencies = [\n \n [[package]]\n name = \"textwrap\"\n-version = \"0.12.1\"\n+version = \"0.11.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"203008d98caf094106cfaba70acfed15e18ed3ddb7d94e49baec153a2b462789\"\n+checksum = \"d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060\"\n dependencies = [\n  \"unicode-width\",\n ]\ndiff --git a\/LOG.md b\/LOG.md\ndeleted file mode 100644\nindex 9ba1d08..0000000\n--- a\/LOG.md\n+++ \/dev\/null\n@@ -1,40 +0,0 @@\n-**[19.08.2016]** RustzxApp and RustzxSettings refactoring  \n-**[18.08.2016]** Moved sound, video, event to sdl lib.  \n-**[15.08.2016]** Moving from **portaudio** to **cpal**  \n-**[14.08.2016]** Kempston Joystick  \n-**[14.08.2016]** AY implementation finished  \n-**[12.08.2016]** AY implementation start  \n-**[09.08.2016]** Refactoring  \n-**[08.08.2016]** Aspect ratio correction, custom 128K rom loading  \n-**[08.08.2016]** Window scale selection with `--scale` option  \n-**[07.07.2016]** ZXScreen rewrite  \n-**[06.07.2016]** Base 128K features implemented  \n-**[05.07.2016]** v0.8 development started in branch `develop`  \n-**[27.06.2016]** Release v0.7.1  \n-**[26.06.2016]** Beeper sound implemented :notes:, release planed to July 1 :rocket:  \n-**[12.06.2016]** Some Comand line arguments fixes\/enchantments  \n-**[12.06.2016]** SNA files loading  \n-**[11.06.2016]** Command line arguments using **clap** crate  \n-**[11.06.2016]** Tap files fast loading implemented, finnaly!  \n-**[07.06.2016]** Speed improvements (maybe :smile:) in flag setting [z80]    \n-**[04.06.2016]** Border FX implemented  \n-**[28.05.2016]** Some architecture rewrite, working on border    \n-**[21.05.2016]** OVERSCAN and SHOCK demo's passed! :sparkles:     \n-**[21.05.2016]** Screen reorganization and OpenGL rendering part fix  \n-**[19.05.2016]** Documentation, Rustfmt  \n-**[15.05.2016]** Fixed bug in INC\/DEC (IX\/IY + dd). After 2 weeks :smile:  \n-**[12.05.2016]** Fixed CALL timings  \n-**[06.05.2016]** Floating bus fix  \n-**[28.04.2016]** All contentions implemented!  \n-**[24.04.2016]** Almost all contentions working perfectly (IO still broken)  \n-**[24.04.2016]** IM2 bug fixed, finally I found it! :smile:  \n-**[24.04.2016]** new Z80Bus interface, serious z80 emulation part rewrite  \n-**[22.04.2016]** work on implementing correct timings started.  \n-**[18.04.2016]** fixed many instruction bugs (IO section still not finished)  \n-**[12.04.2016]** fixed shader bug causing bad performance - palette was declared as non-const  \n-**[12.04.2016]** log file added  \n-**[29.03.2016]** Screen emulation, keyboard, test run of ROMs    \n-**[14.03.2016]** All features of CPU have been implemented :sunglasses:  \n-**[11.03.2016]** Serious code reorganization  \n-**[06.03.2016]** All Z80 instruction groups have been implemented! :tada:  \n-**[02.02.2016]** First commit  \ndiff --git a\/README.md b\/README.md\nindex ed9b3bb..d54c4b5 100644\n--- a\/README.md\n+++ b\/README.md\n@@ -1,60 +1,54 @@\n-# rustzx\n-![logo](assets\/logo_small.png)\n+RustZX\n+===============================\n+\n+[![RustZX CI](https:\/\/github.com\/pacmancoder\/rustzx\/actions\/workflows\/ci.yml\/badge.svg)](https:\/\/github.com\/pacmancoder\/rustzx\/actions\/workflows\/ci.yml)\n \n-ZX Spectrum emulator which I writing in rust.\n-I develop this project just for fun and for learning the basics of computer\n-architecture.\n-Licensed under MIT License.\n+![logo](assets\/logo_small.png)\n \n-**Watch [this](https:\/\/youtu.be\/Xho3GWFyP2I) video showcase!**\n+ZX Spectrum emulator written in Rust\n+- Watch [this](https:\/\/youtu.be\/Xho3GWFyP2I) video showcase (`v0.9.x`)\n+- Read [CHANGELOG.md](CHANGELOG.md) for info on the latest version (`v0.11.x`) changes\n \n-[![Build Status](https:\/\/travis-ci.org\/pacmancoder\/rustzx.svg?branch=master)](https:\/\/travis-ci.org\/pacmancoder\/rustzx)\n ## Features\n - Written in pure rust\n - Cross-platform\n-- Documented source\n - Full ZX Spectrum 48K and 128K emulation\n - Perfect emulation of Z80 core\n - Highly precise AY chip emulation with Ayumi library\n - Beeper sound emulation\n-- Can handle tap, sna files\n+- Supported formats: TAP, SNA\n - Fast loading of tap files with standard loader\n-- Emulates border\n-- Kempston joystick emulation\n-- Correct contentons\n-\n-## Download [v0.9.2]\n-Packages are available in github releases.\n-**Note:** On linux platforms sdl2 library must be installed\n+- Precise timings\n+- Full border emulation\n+- Joystick emulation: Kempston\n+- Separate `no_std` core library which can be used to port emulator\n+  almost anywhere.\n+    - Global allocator is still needed, but all dynamic\n+       allocations were minimized\n+    - All resource-heavy features are configurable via cargo `features`\n \n-## Compiling\n-Before compiling make shure that you have C compiller and CMate to\n+## Compiling from the latest master\n+1. Sure that you have C compiller and CMake to\n build bundled `sdl2`\n-\n-Then just install it with cargo\n-\n+2. Install it with cargo\n ```bash\n-cargo install\n+cargo install --path .\/rustzx\n ```\n-For advanced info use `--help` flag\n \n ## How to use\n-Here some examples of usage:\n ```bash\n-rustzx --help\n-rustzx --fastload --tap test.tap\n-rustzx -f --128k --AY abc --tap test128.tap\n-rustzx --rom tester.rom --scale 3 --volume 50\n+rustzx --help # Show help\n+rustzx test.tap # Autodetect file type and run in 48K mode\n+rustzx --ay test.tap # Run in 48K mode with AY sound chip\n+rustzx -m128 --tape test128.tap # Run in 128K mode with tape\n+rustzx --rom tester.rom -s3 # Run with custom rom and 3x screen scaling\n+rustzx --nofastload test.tap # Run without fast tape loading\n ```\n For loading tape in 48K mode, press `j` then `Ctrl+p` twice, as on real Spectrum.\n-You must see `LOAD \"\"` on emulator's screen. And then press `Enter`.\n-If you `--fastload` option before launching, game will be launched, in other\n-case press `Insert` to insert tape. `Delete` can be used for ejecting tape from\n-tape reader. `--128k` flag launches emulator in 128K mode. For loading tape just\n-press `Enter`.\n+You should see `LOAD \"\"` on emulator's screen, then press `Enter` (in 128K mode just press enter).\n+In `--nofastload` mode, press `Insert` to play the tape and `Delete` to stop\n \n-If you have some audio troubles - use `--latency` flag with bigger samples\n-count.\n+If you have choppy audio, try `--sound-latency` option with bigger values.\n \n Use keys `F3 - F5` to set speed of emulation - this can be usefull when skipping some boring stuff.\n Use `F6` to display FPS in window title.\n@@ -64,13 +58,11 @@ Use `F6` to display FPS in window title.\n ![](screenshots\/q.png)\n ![](screenshots\/arkanoid.png)\n ![](screenshots\/sentinel.png)\n-## Log\n-Watch [LOG](LOG.md) for details and github issues\n-for current plans and help requests.\n+\n ## References\n-Of course, I used many resources to find out, how to build my first\n-emulator in life. So there is a list of useful references, from where I dig most\n-information about Z80, ULA and other ZX Spectrum hardware parts:\n+Many resources were used to find out, how to buildthis emulator.\n+Huge thanks to the following resources which helped to figure out a lot of\n+defails about ZX Spectrum.\n - Of course [z80.info](http:\/\/www.z80.info\/)\n     - [Decoding Z80 opcodes](http:\/\/www.z80.info\/decoding.htm)\n     - [Opcodes list](http:\/\/www.z80.info\/z80code.txt)\n@@ -93,6 +85,8 @@ information about Z80, ULA and other ZX Spectrum hardware parts:\n - [FUSE](http:\/\/fuse-emulator.sourceforge.net\/) emulator source for finding out correct timings\n \n ## ROM's\n-Emulator contains ROM's, created by by Sinclair Research Ltd (now owned by Amstrad plc),\n-Amstrad was given permissions for distributing their ROM's with emulators, so they are\n-included in source of emulator (mod zx::roms). More about this read [here](https:\/\/groups.google.com\/forum\/?hl=en#!msg\/comp.sys.amstrad.8bit\/HtpBU2Bzv_U\/HhNDSU3MksAJ)\n+Emulator contains ROMs, created by by Sinclair Research Ltd (now owned by Amstrad plc),\n+Amstrad has [given](https:\/\/groups.google.com\/forum\/?hl=en#!msg\/comp.sys.amstrad.8bit\/HtpBU2Bzv_U\/HhNDSU3MksAJ)\n+permission to distribute their ROM's in conjunction with emulators.\n+In RustZX these ROMs included in source of the core emulator library `mod rustzx_core::zx::roms`. Embedded roms\n+can be opted-out from the core library by disabling feature `embedded-roms`.\ndiff --git a\/rustfmt.toml b\/rustfmt.toml\nindex 4301c1c..c5d444e 100644\n--- a\/rustfmt.toml\n+++ b\/rustfmt.toml\n@@ -1,11 +1,13 @@\n use_field_init_shorthand = true\n use_try_shorthand = true\n+# Available in nightly, but does not affect success of\n+# stable rustfmt\n+report_fixme = \"Unnumbered\"\n+report_todo = \"Unnumbered\"\n+imports_granularity = \"Crate\"\n+normalize_comments = true\n+condense_wildcard_suffixes = true\n+format_strings = true\n+reorder_impl_items = true\n # Uncomment following if available in stable rustfmt\n-# imports_granularity = \"Crate\"\n-# normalize_comments = true\n-# condense_wildcard_suffixes = true\n-# format_strings = true\n # imports_layout = \"HorizontalVertical\"\n-# reorder_impl_items = true\n-# report_fixme = \"Unnumbered\"\n-# report_todo = \"Unnumbered\"\ndiff --git a\/rustzx-core\/Cargo.toml b\/rustzx-core\/Cargo.toml\nindex 7a8bcc6..497f36b 100644\n--- a\/rustzx-core\/Cargo.toml\n+++ b\/rustzx-core\/Cargo.toml\n@@ -1,17 +1,26 @@\n [package]\n name = \"rustzx-core\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n authors = [\"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n-publish = false\n description = \"ZX Spectum emulator core library\"\n repository = \"https:\/\/github.com\/pacmancoder\/rustzx\"\n keywords = [\"emulator\", \"game\", \"z80\", \"no_std\"]\n license = \"MIT\"\n edition = \"2018\"\n \n+[features]\n+default = []\n+full = [\"ay\", \"precise-border\", \"embedded-roms\"]\n+without-ay = [\"sound\", \"precise-border\", \"embedded-roms\"]\n+precise-border = []\n+embedded-roms = []\n+sound = []\n+ay = [\"ayumi\", \"sound\"]\n+\n [dependencies]\n-lazy_static = \"1.4\"\n+bitflags = \"1\"\n+lazy_static = \"1\"\n displaydoc = { version = \"0.2\", default-features = false }\n from_variants = \"0.6\"\n enum_dispatch = \"0.3\"\n-ayumi = { git = \"https:\/\/github.com\/pacmancoder\/rust-ayumi.git\", rev = \"9e57902\" }\n+ayumi = { git = \"https:\/\/github.com\/pacmancoder\/rust-ayumi.git\", rev = \"9e57902\", optional = true }\ndiff --git a\/rustzx-core\/src\/emulator\/loaders\/sna.rs b\/rustzx-core\/src\/emulator\/loaders\/sna.rs\nindex 6297782..8464cb1 100644\n--- a\/rustzx-core\/src\/emulator\/loaders\/sna.rs\n+++ b\/rustzx-core\/src\/emulator\/loaders\/sna.rs\n@@ -3,58 +3,53 @@ use crate::{\n     host::{Host, LoadableAsset},\n     utils::{make_word, Clocks},\n     z80::{opcodes::execute_pop_16, RegName16},\n-    zx::colors::ZXColor,\n+    zx::video::colors::ZXColor,\n     Result,\n };\n-use alloc::vec::Vec;\n \n \/\/\/ SNA snapshot loading function\n pub fn load_sna<H: Host>(emulator: &mut Emulator<H>, mut asset: H::SnapshotAsset) -> Result<()> {\n-    \/\/ TODO(#54): Eliminate loading a whole file to vector in sna loader\n-    let mut data = Vec::new();\n-    asset.read_to_end(&mut data)?;\n-    assert!(data.len() == 49179);\n+    const SNA_HEADER_SIZE: usize = 27;\n+    let mut header = [0u8; SNA_HEADER_SIZE];\n+    asset.read_exact(&mut header)?;\n+\n     \/\/ i-reg\n-    emulator.cpu.regs.set_i(data[0]);\n+    emulator.cpu.regs.set_i(header[0]);\n     \/\/ alt-regs\n-    emulator.cpu.regs.set_hl(make_word(data[2], data[1]));\n-    emulator.cpu.regs.set_de(make_word(data[4], data[3]));\n-    emulator.cpu.regs.set_bc(make_word(data[6], data[5]));\n+    emulator.cpu.regs.set_hl(make_word(header[2], header[1]));\n+    emulator.cpu.regs.set_de(make_word(header[4], header[3]));\n+    emulator.cpu.regs.set_bc(make_word(header[6], header[5]));\n     emulator.cpu.regs.exx();\n     \/\/ af'\n-    emulator.cpu.regs.set_af(make_word(data[8], data[7]));\n+    emulator.cpu.regs.set_af(make_word(header[8], header[7]));\n     emulator.cpu.regs.swap_af_alt();\n     \/\/ regs\n-    emulator.cpu.regs.set_hl(make_word(data[10], data[9]));\n-    emulator.cpu.regs.set_de(make_word(data[12], data[11]));\n-    emulator.cpu.regs.set_bc(make_word(data[14], data[13]));\n+    emulator.cpu.regs.set_hl(make_word(header[10], header[9]));\n+    emulator.cpu.regs.set_de(make_word(header[12], header[11]));\n+    emulator.cpu.regs.set_bc(make_word(header[14], header[13]));\n     \/\/ index regs\n-    emulator.cpu.regs.set_iy(make_word(data[16], data[15]));\n-    emulator.cpu.regs.set_ix(make_word(data[18], data[17]));\n+    emulator.cpu.regs.set_iy(make_word(header[16], header[15]));\n+    emulator.cpu.regs.set_ix(make_word(header[18], header[17]));\n     \/\/ iff1, iff2\n-    let iff = (data[19] & 0x04) != 0;\n+    let iff = (header[19] & 0x04) != 0;\n     emulator.cpu.regs.set_iff1(iff);\n     emulator.cpu.regs.set_iff2(iff);\n     \/\/ r\n-    emulator.cpu.regs.set_r(data[20]);\n+    emulator.cpu.regs.set_r(header[20]);\n     \/\/ af\n-    emulator.cpu.regs.set_af(make_word(data[22], data[21]));\n+    emulator.cpu.regs.set_af(make_word(header[22], header[21]));\n     \/\/ sp\n-    emulator.cpu.regs.set_sp(make_word(data[24], data[23]));\n+    emulator.cpu.regs.set_sp(make_word(header[24], header[23]));\n     \/\/ interrupt mode\n-    emulator.cpu.set_im(data[25] & 0x03);\n-    \/\/ set border\n+    emulator.cpu.set_im(header[25] & 0x03);\n     emulator\n         .controller\n-        .border\n-        .set_border(Clocks(0), ZXColor::from_bits(data[26] & 0x07));\n+        .set_border_color(Clocks(0), ZXColor::from_bits(header[26] & 0x07));\n     \/\/ ram pages\n-    let page = emulator.controller.memory.ram_page_data_mut(0);\n-    page.copy_from_slice(&data[27..16411]);\n-    let page = emulator.controller.memory.ram_page_data_mut(1);\n-    page.copy_from_slice(&data[16411..32795]);\n-    let page = emulator.controller.memory.ram_page_data_mut(2);\n-    page.copy_from_slice(&data[32795..49179]);\n+    for page_index in 0..3 {\n+        let page = emulator.controller.memory.ram_page_data_mut(page_index);\n+        asset.read_exact(page)?;\n+    }\n \n     \/\/ RET\n     execute_pop_16(\ndiff --git a\/rustzx-core\/src\/emulator\/loaders\/tap.rs b\/rustzx-core\/src\/emulator\/loaders\/tap.rs\nindex 9b62c13..934d579 100644\n--- a\/rustzx-core\/src\/emulator\/loaders\/tap.rs\n+++ b\/rustzx-core\/src\/emulator\/loaders\/tap.rs\n@@ -3,13 +3,12 @@ use crate::{\n     emulator::Emulator,\n     host::Host,\n     utils::{make_word, Clocks},\n-    z80::*,\n+    z80::{opcodes, RegName16, Z80Bus, FLAG_CARRY, FLAG_ZERO},\n     zx::tape::TapeImpl,\n+    Result,\n };\n \n-pub fn fast_load_tap<H: Host>(emulator: &mut Emulator<H>) {\n-    \/\/ resetting tape pos to beginning.\n-    emulator.controller.tape.reset_pos_in_block();\n+pub fn fast_load_tap<H: Host>(emulator: &mut Emulator<H>) -> Result<()> {\n     \/\/ So, at current moment we at 0x056C in 48K Rom.\n     \/\/ AF contains some garbage. so we need to swap if wtih A'F'\n     emulator.cpu.regs.swap_af_alt();\n@@ -18,20 +17,22 @@ pub fn fast_load_tap<H: Host>(emulator: &mut Emulator<H>) {\n     let mut acc = emulator.cpu.regs.get_acc();\n     \/\/ variable to store resulting flags\n     let mut result_flags;\n-    \/\/ pos relative to block start\n-    let mut pos = 0;\n     \/\/ destination address in RAM\n     let mut dest = emulator.cpu.regs.get_reg_16(RegName16::IX);\n     \/\/ remaining length\n     let mut length = emulator.cpu.regs.get_reg_16(RegName16::DE);\n     \/\/ parity accumulator and current byte (h, l) regs\n     let (mut parity_acc, mut current_byte) = (0, 0);\n+    \/\/ move to next block\n+    if !emulator.controller.tape.next_block()? {\n+        return Ok(());\n+    }\n+\n     'loader: loop {\n         \/\/ if we still on block\n-        if let Some(byte) = emulator.controller.tape.block_byte(pos) {\n+        if let Some(byte) = emulator.controller.tape.next_block_byte()? {\n             \/\/ set current byte, shift position and do parity check iteration\n             current_byte = byte;\n-            pos += 1;\n             parity_acc ^= current_byte;\n             \/\/ no bytes left, set A to parity accumulator (works as in ROM)\n             \/\/ and check parity last time\n@@ -98,6 +99,5 @@ pub fn fast_load_tap<H: Host>(emulator: &mut Emulator<H>) {\n         );\n     }\n     emulator.cpu.regs.set_flags(f);\n-    \/\/ move to next block\n-    emulator.controller.tape.next_block();\n+    Ok(())\n }\ndiff --git a\/rustzx-core\/src\/emulator\/mod.rs b\/rustzx-core\/src\/emulator\/mod.rs\nindex a83b22a..f112991 100644\n--- a\/rustzx-core\/src\/emulator\/mod.rs\n+++ b\/rustzx-core\/src\/emulator\/mod.rs\n@@ -5,27 +5,32 @@ use crate::{\n     error::RomLoadError,\n     host::{Host, LoadableAsset, RomFormat, RomSet, Snapshot, Tape},\n     settings::RustzxSettings,\n-    utils::*,\n-    z80::*,\n+    utils::EmulationSpeed,\n+    z80::Z80,\n     zx::{\n+        controller::ZXController,\n+        events::EmulationEvents,\n         joy::kempston::KempstonKey,\n-        sound::sample::SoundSample,\n+        keys::ZXKey,\n         tape::{Tap, TapeImpl},\n-        ZXController, ZXKey,\n+        video::colors::ZXColor,\n     },\n     Result,\n };\n \n+#[cfg(feature = \"sound\")]\n+use crate::zx::sound::sample::SoundSample;\n+\n use core::time::Duration;\n \n \/\/\/ Represents main Emulator structure\n pub struct Emulator<H: Host> {\n     settings: RustzxSettings,\n     cpu: Z80,\n-    \/\/ TODO(#52): eliminate direct access to the controller\n-    pub controller: ZXController<H>,\n+    controller: ZXController<H>,\n     speed: EmulationSpeed,\n     fast_load: bool,\n+    #[cfg(feature = \"sound\")]\n     sound_enabled: bool,\n }\n \n@@ -38,13 +43,14 @@ impl<H: Host> Emulator<H> {\n     \/\/\/ Constructs new emulator\n     \/\/\/ # Arguments\n     \/\/\/ `settings` - emulator settings\n-    pub fn new(settings: RustzxSettings) -> Result<Self> {\n+    pub fn new(settings: RustzxSettings, context: H::Context) -> Result<Self> {\n         let speed = settings.emulation_speed;\n         let fast_load = settings.tape_fastload;\n+        #[cfg(feature = \"sound\")]\n         let sound_enabled = settings.sound_enabled;\n \n         let cpu = Z80::default();\n-        let controller = ZXController::<H>::new(&settings);\n+        let controller = ZXController::<H>::new(&settings, context);\n \n         let this = Self {\n             settings,\n@@ -52,6 +58,7 @@ impl<H: Host> Emulator<H> {\n             controller,\n             speed,\n             fast_load,\n+            #[cfg(feature = \"sound\")]\n             sound_enabled,\n         };\n \n@@ -69,11 +76,13 @@ impl<H: Host> Emulator<H> {\n     }\n \n     \/\/\/ changes sound playback flag\n+    #[cfg(feature = \"sound\")]\n     pub fn set_sound(&mut self, value: bool) {\n         self.sound_enabled = value;\n     }\n \n     \/\/\/ function for sound generation request check\n+    #[cfg(feature = \"sound\")]\n     pub fn have_sound(&self) -> bool {\n         \/\/ enable sound only if speed is normal\n         if let EmulationSpeed::Definite(1) = self.speed {\n@@ -125,6 +134,19 @@ impl<H: Host> Emulator<H> {\n         self.controller.tape.stop();\n     }\n \n+    pub fn screen_buffer(&self) -> &H::FrameBuffer {\n+        self.controller.screen.frame_buffer()\n+    }\n+\n+    #[cfg(feature = \"precise-border\")]\n+    pub fn border_buffer(&self) -> &H::FrameBuffer {\n+        self.controller.border.frame_buffer()\n+    }\n+\n+    pub fn border_color(&self) -> ZXColor {\n+        self.controller.border_color\n+    }\n+\n     pub fn send_key(&mut self, key: ZXKey, pressed: bool) {\n         self.controller.send_key(key, pressed);\n     }\n@@ -135,32 +157,25 @@ impl<H: Host> Emulator<H> {\n         }\n     }\n \n+    #[cfg(feature = \"sound\")]\n     pub fn next_audio_sample(&mut self) -> Option<SoundSample<f32>> {\n         self.controller.mixer.pop()\n     }\n \n-    fn process_event(&mut self, event: Event) {\n-        let Event { kind: e, time: _ } = event;\n-        match e {\n-            \/\/ Fast tape loading found, use it\n-            EventKind::FastTapeLoad if self.controller.tape.can_fast_load() && self.fast_load => {\n-                loaders::tap::fast_load_tap(self);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    \/\/ processes all events, happened at frame emulation cycle\n-    fn process_all_events(&mut self) {\n-        while let Some(event) = self.controller.pop_event() {\n-            self.process_event(event);\n+    fn process_events(&mut self, event: EmulationEvents) -> Result<()> {\n+        if event.contains(EmulationEvents::TAPE_FAST_LOAD_TRIGGER_DETECTED)\n+            && self.controller.tape.can_fast_load()\n+            && self.fast_load\n+        {\n+            loaders::tap::fast_load_tap(self)?;\n         }\n+        Ok(())\n     }\n \n     \/\/\/ Emulate frames, maximum in `max_time` time, returns emulation time in nanoseconds\n     \/\/\/ in most cases time is max 1\/50 of second, even when using\n     \/\/\/ loader acceleration\n-    pub fn emulate_frames<S>(&mut self, max_time: Duration, stopwatch: &mut S) -> Duration\n+    pub fn emulate_frames<S>(&mut self, max_time: Duration, stopwatch: &mut S) -> Result<Duration>\n     where\n         S: Stopwatch,\n     {\n@@ -172,17 +187,19 @@ impl<H: Host> Emulator<H> {\n             self.controller.reset_frame_counter();\n             'cpu: loop {\n                 \/\/ Emulation step. if instant event happened then accept in and execute\n-                if !self.cpu.emulate(&mut self.controller) {\n-                    if let Some(event) = self.controller.pop_event() {\n-                        self.process_event(event);\n-                    }\n+                self.cpu.emulate(&mut self.controller);\n+                if let Some(e) = self.controller.take_last_emulation_error() {\n+                    return Err(e);\n+                }\n+                if !self.controller.events().is_empty() {\n+                    self.process_events(self.controller.events())?;\n+                    self.controller.clear_events();\n                 }\n                 \/\/ If speed is defined\n                 if let EmulationSpeed::Definite(multiplier) = self.speed {\n                     if self.controller.frames_count() >= multiplier {\n                         \/\/ no more frames\n-                        self.controller.clear_events();\n-                        return stopwatch.measure();\n+                        return Ok(stopwatch.measure());\n                     };\n                 \/\/ if speed is maximal.\n                 } else {\n@@ -198,7 +215,6 @@ impl<H: Host> Emulator<H> {\n                 break 'frame;\n             }\n         }\n-        self.controller.clear_events();\n-        time\n+        Ok(time)\n     }\n }\ndiff --git a\/rustzx-core\/src\/error.rs b\/rustzx-core\/src\/error.rs\nindex 8dbd531..5c96cf6 100644\n--- a\/rustzx-core\/src\/error.rs\n+++ b\/rustzx-core\/src\/error.rs\n@@ -7,6 +7,8 @@ pub enum Error {\n     AssetRead(AssetReadError),\n     \/\/\/ Failed to load rom\n     RomLoad(RomLoadError),\n+    \/\/\/ Failed to load rom\n+    TapeLoad(TapeLoadError),\n }\n \n #[derive(Debug, Display)]\n@@ -22,3 +24,9 @@ pub enum RomLoadError {\n     \/\/\/ More assets required to load rom\n     MoreAssetsRequired,\n }\n+\n+#[derive(Debug, Display)]\n+pub enum TapeLoadError {\n+    \/\/\/ Provided tap file is invalid\n+    InvalidTapFile,\n+}\ndiff --git a\/rustzx-core\/src\/host\/frame_buffer.rs b\/rustzx-core\/src\/host\/frame_buffer.rs\nnew file mode 100644\nindex 0000000..56620a4\n--- \/dev\/null\n+++ b\/rustzx-core\/src\/host\/frame_buffer.rs\n@@ -0,0 +1,14 @@\n+use crate::zx::video::colors::{ZXBrightness, ZXColor};\n+\n+pub enum FrameBufferSource {\n+    Screen,\n+    Border,\n+}\n+\n+pub trait FrameBuffer {\n+    type Context: Clone;\n+    \/\/\/ Creates canvas size with required dimensions (`width`, `height`)\n+    fn new(width: usize, height: usize, source: FrameBufferSource, context: Self::Context) -> Self;\n+    \/\/\/ Set `color` with `brightness` for pixel on canvas at (`x`, `y`)\n+    fn set_color(&mut self, x: usize, y: usize, color: ZXColor, brightness: ZXBrightness);\n+}\ndiff --git a\/rustzx-core\/src\/host\/io.rs b\/rustzx-core\/src\/host\/io.rs\nindex 504e648..9ba902a 100644\n--- a\/rustzx-core\/src\/host\/io.rs\n+++ b\/rustzx-core\/src\/host\/io.rs\n@@ -36,14 +36,4 @@ pub trait LoadableAsset {\n \n         Ok(())\n     }\n-\n-    fn read_to_end(&mut self, buf: &mut alloc::vec::Vec<u8>) -> Result<()> {\n-        let mut buffer = [0u8; 1024];\n-        let mut read_bytes = self.read(&mut buffer)?;\n-        while read_bytes != 0 {\n-            buf.extend_from_slice(&buffer[0..read_bytes]);\n-            read_bytes = self.read(&mut buffer)?;\n-        }\n-        Ok(())\n-    }\n }\ndiff --git a\/rustzx-core\/src\/host\/mod.rs b\/rustzx-core\/src\/host\/mod.rs\nindex 1f9ca8e..d1c97c2 100644\n--- a\/rustzx-core\/src\/host\/mod.rs\n+++ b\/rustzx-core\/src\/host\/mod.rs\n@@ -1,5 +1,7 @@\n+mod frame_buffer;\n mod io;\n \n+pub use frame_buffer::{FrameBuffer, FrameBufferSource};\n pub use io::{LoadableAsset, SeekFrom};\n \n pub enum Snapshot<LoadableAssetImpl: LoadableAsset> {\n@@ -23,13 +25,22 @@ pub trait RomSet {\n     fn next_asset(&mut self) -> Option<Self::Asset>;\n }\n \n+pub trait HostContext<H: Host + ?Sized>: Sized {\n+    fn frame_buffer_context(&self) -> <H::FrameBuffer as FrameBuffer>::Context;\n+}\n+\n \/\/\/ Represents set of required types for emulator implementation\n \/\/\/ based on `rustzx-core`.\n pub trait Host {\n+    \/\/\/ Immutable `Context` implementation which is used to obtain host-specific\n+    \/\/\/ context objects for host-defined emulator parts construction (e.g. FrameBuffers)\n+    type Context: HostContext<Self>;\n     \/\/\/ File-like type implementation for tape loading\n     type TapeAsset: LoadableAsset;\n     \/\/\/ File-like type implementation for snapshot loading\n     type SnapshotAsset: LoadableAsset;\n     \/\/\/ File-like type implementation for rom loading\n     type RomSet: RomSet;\n+    \/\/\/ Frame buffer implementation\n+    type FrameBuffer: FrameBuffer;\n }\ndiff --git a\/rustzx-core\/src\/lib.rs b\/rustzx-core\/src\/lib.rs\nindex 6c0c18b..bbd415c 100644\n--- a\/rustzx-core\/src\/lib.rs\n+++ b\/rustzx-core\/src\/lib.rs\n@@ -1,15 +1,19 @@\n #![no_std]\n #![allow(dead_code)]\n \n-pub mod emulator;\n+pub(crate) mod emulator;\n+pub(crate) mod settings;\n+pub(crate) mod utils;\n+pub(crate) mod z80;\n+\n pub mod error;\n pub mod host;\n-pub mod settings;\n-pub mod utils;\n-pub mod z80;\n pub mod zx;\n \n+pub use emulator::{Emulator, Stopwatch};\n+pub use settings::RustzxSettings;\n+pub use utils::EmulationSpeed;\n+\n extern crate alloc;\n \n-pub use crate::error::Error;\n-pub type Result<T> = core::result::Result<T, Error>;\n+pub type Result<T> = core::result::Result<T, error::Error>;\ndiff --git a\/rustzx-core\/src\/settings.rs b\/rustzx-core\/src\/settings.rs\nindex 637ace7..c60d79a 100644\n--- a\/rustzx-core\/src\/settings.rs\n+++ b\/rustzx-core\/src\/settings.rs\n@@ -1,17 +1,25 @@\n-use crate::{\n-    utils::EmulationSpeed,\n-    zx::{machine::ZXMachine, sound::ay::ZXAYMode},\n-};\n+use crate::{utils::EmulationSpeed, zx::machine::ZXMachine};\n+\n+#[cfg(all(feature = \"sound\", feature = \"ay\"))]\n+use crate::zx::sound::ay::ZXAYMode;\n \n pub struct RustzxSettings {\n     pub machine: ZXMachine,\n     pub emulation_speed: EmulationSpeed,\n     pub tape_fastload: bool,\n     pub enable_kempston: bool,\n+    #[cfg(all(feature = \"sound\", feature = \"ay\"))]\n     pub ay_mode: ZXAYMode,\n+    #[cfg(all(feature = \"sound\", feature = \"ay\"))]\n     pub ay_enabled: bool,\n+    #[cfg(feature = \"sound\")]\n     pub beeper_enabled: bool,\n+    #[cfg(feature = \"sound\")]\n     pub sound_enabled: bool,\n+    #[cfg(feature = \"sound\")]\n     pub sound_volume: u8,\n+    #[cfg(feature = \"sound\")]\n+    pub sound_sample_rate: usize,\n+    #[cfg(feature = \"embedded-roms\")]\n     pub load_default_rom: bool,\n }\ndiff --git a\/rustzx-core\/src\/utils\/events.rs b\/rustzx-core\/src\/utils\/events.rs\ndeleted file mode 100644\nindex a8eed0c..0000000\n--- a\/rustzx-core\/src\/utils\/events.rs\n+++ \/dev\/null\n@@ -1,50 +0,0 @@\n-use crate::utils::{Clocks, EmulationSpeed};\n-use alloc::collections::VecDeque;\n-\n-\/\/\/ Type of happened event\n-pub enum EventKind {\n-    Accelerate(EmulationSpeed),\n-    Deaccelerate,\n-    FastTapeLoad,\n-}\n-\n-\/\/\/ event, have information about kind and time of event\n-pub struct Event {\n-    pub kind: EventKind,\n-    pub time: Clocks,\n-}\n-\n-impl Event {\n-    \/\/\/ constructs new event\n-    pub fn new(kind: EventKind, time: Clocks) -> Event {\n-        Event { kind, time }\n-    }\n-}\n-\n-\/\/\/ Queue-based event container\n-#[derive(Default)]\n-pub struct EventQueue {\n-    deque: VecDeque<Event>,\n-}\n-\n-impl EventQueue {\n-    \/\/\/ addd new event\n-    pub fn send_event(&mut self, e: Event) {\n-        self.deque.push_back(e);\n-    }\n-\n-    \/\/\/ pops last event from deque\n-    pub fn receive_event(&mut self) -> Option<Event> {\n-        self.deque.pop_front()\n-    }\n-\n-    \/\/\/ returns true if container is empty\n-    pub fn is_empty(&self) -> bool {\n-        self.deque.is_empty()\n-    }\n-\n-    \/\/\/ removes all events\n-    pub fn clear(&mut self) {\n-        self.deque.clear();\n-    }\n-}\ndiff --git a\/rustzx-core\/src\/utils\/instantflag.rs b\/rustzx-core\/src\/utils\/instantflag.rs\ndeleted file mode 100644\nindex 7a7faa3..0000000\n--- a\/rustzx-core\/src\/utils\/instantflag.rs\n+++ \/dev\/null\n@@ -1,32 +0,0 @@\n-use core::cell::Cell;\n-\n-\/\/\/ Instant flag - type, which resets self on immutable read\n-pub struct InstantFlag {\n-    f: Cell<bool>,\n-}\n-\n-impl InstantFlag {\n-    \/\/\/ constructs self from initial value\n-    pub fn new(value: bool) -> InstantFlag {\n-        InstantFlag {\n-            f: Cell::new(value),\n-        }\n-    }\n-\n-    \/\/\/ immutable read with reset\n-    pub fn pick(&self) -> bool {\n-        let value = self.f.get();\n-        self.f.set(false);\n-        value\n-    }\n-\n-    \/\/\/ read, but not reset\n-    pub fn get_direct(&self) -> bool {\n-        self.f.get()\n-    }\n-\n-    \/\/\/ set flag\n-    pub fn set(&mut self) {\n-        self.f.set(true);\n-    }\n-}\ndiff --git a\/rustzx-core\/src\/utils\/mod.rs b\/rustzx-core\/src\/utils\/mod.rs\nindex 9245209..1ed947e 100644\n--- a\/rustzx-core\/src\/utils\/mod.rs\n+++ b\/rustzx-core\/src\/utils\/mod.rs\n@@ -1,11 +1,10 @@\n \/\/! Some emulator-related utils\n \n pub mod clocks;\n-pub mod events;\n-pub mod instantflag;\n pub mod screen;\n pub mod smallnum;\n-pub use self::{clocks::*, events::*, instantflag::*, smallnum::*};\n+\n+pub use self::{clocks::*, smallnum::*};\n \n #[derive(Copy, Clone)]\n pub enum EmulationSpeed {\ndiff --git a\/rustzx-core\/src\/utils\/screen.rs b\/rustzx-core\/src\/utils\/screen.rs\nindex 400585c..f19e097 100644\n--- a\/rustzx-core\/src\/utils\/screen.rs\n+++ b\/rustzx-core\/src\/utils\/screen.rs\n@@ -1,5 +1,5 @@\n use super::split_word;\n-use crate::zx::constants::*;\n+use crate::zx::constants::{ATTR_BASE_REL, ATTR_COLS, ATTR_MAX_REL, CANVAS_HEIGHT};\n \n \/\/\/ Encode line number to read memory address\n pub fn bitmap_line_addr(line: usize) -> u16 {\ndiff --git a\/rustzx-core\/src\/utils\/smallnum.rs b\/rustzx-core\/src\/utils\/smallnum.rs\nindex 539327b..7c7be30 100644\n--- a\/rustzx-core\/src\/utils\/smallnum.rs\n+++ b\/rustzx-core\/src\/utils\/smallnum.rs\n@@ -4,6 +4,7 @@\n pub enum U1 {\n     N0, N1,\n }\n+\n impl U1 {\n     \/\/\/ Constructs self from byte\n     \/\/\/ # Panics\n@@ -24,12 +25,14 @@ impl U1 {\n         }\n     }\n }\n+\n #[derive(Clone, Copy, PartialEq, Eq)]\n #[rustfmt::skip]\n \/\/\/ 2 bit unsigned\n pub enum U2 {\n     N0, N1, N2, N3,\n }\n+\n impl U2 {\n     \/\/\/ Constructs self from byte\n     \/\/\/ # Panics\n@@ -54,12 +57,14 @@ impl U2 {\n         }\n     }\n }\n+\n #[derive(Clone, Copy, PartialEq, Eq)]\n #[rustfmt::skip]\n \/\/\/ 3 bit unsigned\n pub enum U3 {\n     N0, N1, N2, N3, N4, N5, N6, N7,\n }\n+\n impl U3 {\n     \/\/\/ Constructs self from byte\n     \/\/\/ # Panics\ndiff --git a\/rustzx-core\/src\/z80\/bus.rs b\/rustzx-core\/src\/z80\/bus.rs\nindex eaaec45..309dd2c 100644\n--- a\/rustzx-core\/src\/z80\/bus.rs\n+++ b\/rustzx-core\/src\/z80\/bus.rs\n@@ -1,4 +1,4 @@\n-use crate::utils::*;\n+use crate::utils::{make_word, split_word, Clocks};\n \n \/\/\/ Z80 processor System bus\n \/\/\/ Implement it for communication with CPU.\n@@ -61,8 +61,6 @@ pub trait Z80Bus {\n     fn int_active(&self) -> bool;\n     \/\/\/ Checks nmi signal\n     fn nmi_active(&self) -> bool;\n-    \/\/\/ Must return true if devices on bus invoked events\n-    fn instant_event(&self) -> bool;\n     \/\/\/ invokes breakpoints check on bus device\n     fn pc_callback(&mut self, addr: u16);\n }\ndiff --git a\/rustzx-core\/src\/z80\/cpu.rs b\/rustzx-core\/src\/z80\/cpu.rs\nindex ef8a4e6..2fa1f81 100644\n--- a\/rustzx-core\/src\/z80\/cpu.rs\n+++ b\/rustzx-core\/src\/z80\/cpu.rs\n@@ -1,8 +1,11 @@\n \/\/! Z80 CPU module\n \n use crate::{\n-    utils::*,\n-    z80::{opcodes::*, *},\n+    utils::{make_word, Clocks},\n+    z80::{\n+        opcodes::{execute_bits, execute_extended, execute_normal, execute_push_16, Opcode},\n+        IntMode, Prefix, RegName16, Regs, Z80Bus,\n+    },\n };\n \n \/\/\/ Z80 Processor struct\n@@ -75,7 +78,7 @@ impl Z80 {\n     \/\/\/ Main emulation step function\n     \/\/\/ return `false` if execution can be continued or true if last event must be executed\n     \/\/\/ instantly\n-    pub fn emulate(&mut self, bus: &mut dyn Z80Bus) -> bool {\n+    pub fn emulate(&mut self, bus: &mut dyn Z80Bus) {\n         \/\/ check interrupts\n         if !self.skip_interrupt {\n             \/\/ at first check nmi\n@@ -194,11 +197,7 @@ impl Z80 {\n             let opcode = Opcode::from_byte(byte1);\n             execute_normal(self, bus, opcode, Prefix::None);\n         };\n-        \/\/ check events on bus\n-        \/\/ if some events found, then signal that emulator must process events before\n-        \/\/ next cpu step\n+        \/\/ Allow bus implementation to process pc-based events\n         bus.pc_callback(self.regs.get_pc());\n-        \/\/ return true if events happened\n-        bus.instant_event()\n     }\n }\ndiff --git a\/rustzx-core\/src\/z80\/opcodes\/group_bits.rs b\/rustzx-core\/src\/z80\/opcodes\/group_bits.rs\nindex 944fe56..3775928 100644\n--- a\/rustzx-core\/src\/z80\/opcodes\/group_bits.rs\n+++ b\/rustzx-core\/src\/z80\/opcodes\/group_bits.rs\n@@ -1,7 +1,11 @@\n-use super::*;\n use crate::{\n-    utils::*,\n-    z80::{tables::*, *},\n+    utils::{bool_to_u8, word_displacement, Clocks, U2},\n+    z80::{\n+        opcodes::{execute_rot, BitOperand8, Opcode},\n+        tables::F3F5_TABLE,\n+        Prefix, RegName16, RegName8, Z80Bus, FLAG_CARRY, FLAG_HALF_CARRY, FLAG_PV, FLAG_SIGN,\n+        FLAG_ZERO, Z80,\n+    },\n };\n \n \/\/\/ Instruction group which operatis with bits\ndiff --git a\/rustzx-core\/src\/z80\/opcodes\/group_extended.rs b\/rustzx-core\/src\/z80\/opcodes\/group_extended.rs\nindex dcac441..4048406 100644\n--- a\/rustzx-core\/src\/z80\/opcodes\/group_extended.rs\n+++ b\/rustzx-core\/src\/z80\/opcodes\/group_extended.rs\n@@ -1,7 +1,16 @@\n-use super::*;\n use crate::{\n-    utils::*,\n-    z80::{tables::*, *},\n+    utils::{bool_to_u8, Clocks, U1, U2, U3},\n+    z80::{\n+        opcodes::{\n+            execute_cpi_cpd, execute_ini_ind, execute_ldi_ldd, execute_outi_outd, execute_pop_16,\n+            BlockDir, Opcode,\n+        },\n+        tables::{\n+            lookup16_r12, lookup8_r12, HALF_CARRY_ADD_TABLE, HALF_CARRY_SUB_TABLE,\n+            OVERFLOW_ADD_TABLE, OVERFLOW_SUB_TABLE, SZF3F5_TABLE, SZPF3F5_TABLE,\n+        },\n+        Flag, IntMode, RegName16, RegName8, Z80Bus, FLAG_CARRY, FLAG_PV, FLAG_SUB, FLAG_ZERO, Z80,\n+    },\n };\n \n \/\/\/ Extended instruction group (ED-prefixed)\ndiff --git a\/rustzx-core\/src\/z80\/opcodes\/group_nonprefixed.rs b\/rustzx-core\/src\/z80\/opcodes\/group_nonprefixed.rs\nindex 40db9aa..88d7088 100644\n--- a\/rustzx-core\/src\/z80\/opcodes\/group_nonprefixed.rs\n+++ b\/rustzx-core\/src\/z80\/opcodes\/group_nonprefixed.rs\n@@ -1,7 +1,14 @@\n-use super::*;\n use crate::{\n-    utils::*,\n-    z80::{tables::*, *},\n+    utils::{bool_to_u8, make_word, split_word, word_displacement, Clocks, U1, U2, U3},\n+    z80::{\n+        opcodes::{execute_alu_8, execute_pop_16, execute_push_16, LoadOperand8, Opcode},\n+        tables::{\n+            lookup16_r12, lookup8_r12, F3F5_TABLE, HALF_CARRY_ADD_TABLE, HALF_CARRY_SUB_TABLE,\n+            SZF3F5_TABLE, SZPF3F5_TABLE,\n+        },\n+        Condition, Flag, Prefix, RegName16, RegName8, Z80Bus, FLAG_CARRY, FLAG_F3, FLAG_F5,\n+        FLAG_HALF_CARRY, FLAG_PV, FLAG_SIGN, FLAG_SUB, FLAG_ZERO, Z80,\n+    },\n };\n \n \/\/\/ normal execution group, can be modified with prefixes DD, FD, providing\ndiff --git a\/rustzx-core\/src\/z80\/opcodes\/internal_alu.rs b\/rustzx-core\/src\/z80\/opcodes\/internal_alu.rs\nindex b914b24..29f301d 100644\n--- a\/rustzx-core\/src\/z80\/opcodes\/internal_alu.rs\n+++ b\/rustzx-core\/src\/z80\/opcodes\/internal_alu.rs\n@@ -1,6 +1,12 @@\n use crate::{\n-    utils::*,\n-    z80::{tables::*, *},\n+    utils::{bool_to_u8, U3},\n+    z80::{\n+        tables::{\n+            lookup8_r12, F3F5_TABLE, HALF_CARRY_ADD_TABLE, HALF_CARRY_SUB_TABLE,\n+            OVERFLOW_ADD_TABLE, OVERFLOW_SUB_TABLE, PARITY_TABLE,\n+        },\n+        Flag, FLAG_CARRY, FLAG_HALF_CARRY, FLAG_SIGN, FLAG_SUB, FLAG_ZERO, Z80,\n+    },\n };\n \n \/\/\/ 8-bit ALU operations\ndiff --git a\/rustzx-core\/src\/z80\/opcodes\/internal_block.rs b\/rustzx-core\/src\/z80\/opcodes\/internal_block.rs\nindex 250e68f..10e73b5 100644\n--- a\/rustzx-core\/src\/z80\/opcodes\/internal_block.rs\n+++ b\/rustzx-core\/src\/z80\/opcodes\/internal_block.rs\n@@ -1,7 +1,11 @@\n-use super::*;\n use crate::{\n-    utils::*,\n-    z80::{tables::*, *},\n+    utils::{bool_to_u8, Clocks},\n+    z80::{\n+        opcodes::BlockDir,\n+        tables::{lookup8_r12, HALF_CARRY_SUB_TABLE, PARITY_TABLE, SZF3F5_TABLE},\n+        RegName16, RegName8, Z80Bus, FLAG_CARRY, FLAG_F3, FLAG_F5, FLAG_HALF_CARRY, FLAG_PV,\n+        FLAG_SIGN, FLAG_SUB, FLAG_ZERO, Z80,\n+    },\n };\n \n \/\/\/ ldi or ldd instruction\ndiff --git a\/rustzx-core\/src\/z80\/opcodes\/internal_rot.rs b\/rustzx-core\/src\/z80\/opcodes\/internal_rot.rs\nindex dfb8b52..592c2d3 100644\n--- a\/rustzx-core\/src\/z80\/opcodes\/internal_rot.rs\n+++ b\/rustzx-core\/src\/z80\/opcodes\/internal_rot.rs\n@@ -1,7 +1,6 @@\n-use super::*;\n use crate::{\n-    utils::*,\n-    z80::{tables::*, *},\n+    utils::{bool_to_u8, Clocks, U3},\n+    z80::{opcodes::BitOperand8, tables::SZPF3F5_TABLE, Flag, Z80Bus, FLAG_CARRY, Z80},\n };\n \n \/\/\/ Rotate operations (RLC, RRC, RL, RR, SLA, SRA, SLL, SRL)\ndiff --git a\/rustzx-core\/src\/z80\/opcodes\/internal_stack.rs b\/rustzx-core\/src\/z80\/opcodes\/internal_stack.rs\nindex dbe63aa..ef924f7 100644\n--- a\/rustzx-core\/src\/z80\/opcodes\/internal_stack.rs\n+++ b\/rustzx-core\/src\/z80\/opcodes\/internal_stack.rs\n@@ -1,6 +1,6 @@\n use crate::{\n     utils::{make_word, split_word, Clocks},\n-    z80::*,\n+    z80::{RegName16, Z80Bus, Z80},\n };\n \n \/\/\/ Pushes 16 bit value to the stack. Clocks count using for each byte write\ndiff --git a\/rustzx-core\/src\/z80\/opcodes\/mod.rs b\/rustzx-core\/src\/z80\/opcodes\/mod.rs\nindex 63eb7bf..6641900 100644\n--- a\/rustzx-core\/src\/z80\/opcodes\/mod.rs\n+++ b\/rustzx-core\/src\/z80\/opcodes\/mod.rs\n@@ -9,7 +9,7 @@ mod internal_rot;\n mod internal_stack;\n mod types;\n \n-\/\/ re-export all functions\n+\/\/ re-export all public functions\n pub use self::{\n     group_bits::*, group_extended::*, group_nonprefixed::*, internal_alu::*, internal_block::*,\n     internal_rot::*, internal_stack::*, types::*,\ndiff --git a\/rustzx-core\/src\/z80\/opcodes\/types.rs b\/rustzx-core\/src\/z80\/opcodes\/types.rs\nindex 721f762..ccbc1cf 100644\n--- a\/rustzx-core\/src\/z80\/opcodes\/types.rs\n+++ b\/rustzx-core\/src\/z80\/opcodes\/types.rs\n@@ -1,4 +1,7 @@\n-use crate::{utils::*, z80::*};\n+use crate::{\n+    utils::{U1, U2, U3},\n+    z80::RegName8,\n+};\n \n \/\/\/ Operand for 8-bit LD instructions\n pub enum LoadOperand8 {\ndiff --git a\/rustzx-core\/src\/z80\/registers.rs b\/rustzx-core\/src\/z80\/registers.rs\nindex 89f433d..efcdb6c 100644\n--- a\/rustzx-core\/src\/z80\/registers.rs\n+++ b\/rustzx-core\/src\/z80\/registers.rs\n@@ -1,5 +1,8 @@\n \/\/! Module which contains Z80 registers implementation\n-use crate::{utils::*, z80::Prefix};\n+use crate::{\n+    utils::{make_word, split_word, word_displacement, U2, U3},\n+    z80::Prefix,\n+};\n use core::fmt;\n \n \/\/ Flag register bits\ndiff --git a\/rustzx-core\/src\/z80\/tables\/mod.rs b\/rustzx-core\/src\/z80\/tables\/mod.rs\nindex 7cc515d..626f207 100644\n--- a\/rustzx-core\/src\/z80\/tables\/mod.rs\n+++ b\/rustzx-core\/src\/z80\/tables\/mod.rs\n@@ -1,6 +1,5 @@\n \/\/! Contains internal emulator tables\n-\n-use crate::z80::registers::*;\n+use crate::z80::{FLAG_F3, FLAG_F5, FLAG_HALF_CARRY, FLAG_PV, FLAG_SIGN, FLAG_ZERO};\n use lazy_static::lazy_static;\n \n \/\/ TABLES FORM FUSE ZX SPECTRUM EMULATOR:\ndiff --git a\/rustzx-core\/src\/zx\/constants.rs b\/rustzx-core\/src\/zx\/constants.rs\nindex 3418e2b..1c3c510 100644\n--- a\/rustzx-core\/src\/zx\/constants.rs\n+++ b\/rustzx-core\/src\/zx\/constants.rs\n@@ -1,31 +1,31 @@\n \/\/! Module contains constants\n-\/\/\/ addresses\n-pub const BITMAP_BASE_ADDR: u16 = 0x4000;\n-pub const ATTR_BASE_ADDR: u16 = 0x5800;\n-pub const ATTR_MAX_ADDR: u16 = 0x5AFF;\n-\/\/\/ relative addresses\n-pub const BITMAP_MAX_REL: u16 = 0x17FF;\n-pub const ATTR_BASE_REL: u16 = 0x1800;\n-pub const ATTR_MAX_REL: u16 = 0x1AFF;\n+\n \/\/\/ main spectrum screen (canvas) constants\n pub const CANVAS_WIDTH: usize = 256;\n pub const CANVAS_HEIGHT: usize = 192;\n pub const CANVAS_X: usize = 32;\n pub const CANVAS_Y: usize = 24;\n-\/\/\/ on all spectrums theese values are fixed\n-pub const CLOCKS_PER_COL: usize = 4;\n-pub const PIXELS_PER_CLOCK: usize = 2;\n-\/\/\/ size of screen in rows, cols\n-pub const ATTR_COLS: usize = CANVAS_WIDTH \/ 8;\n-pub const ATTR_ROWS: usize = CANVAS_HEIGHT \/ 8;\n-pub const BORDER_COLS: usize = 4;\n-pub const BORDER_ROWS: usize = 3;\n \/\/\/ canvas (emulated screen) constants\n pub const SCREEN_WIDTH: usize = CANVAS_WIDTH + BORDER_COLS * 8 * 2;\n pub const SCREEN_HEIGHT: usize = CANVAS_HEIGHT + BORDER_ROWS * 8 * 2;\n-pub const PIXEL_COUNT: usize = SCREEN_HEIGHT * SCREEN_WIDTH;\n-pub const BYTES_PER_PIXEL: usize = 4;\n \/\/\/ Frames per second\n pub const FPS: usize = 50;\n+\n+\/\/\/ addresses\n+pub(crate) const BITMAP_BASE_ADDR: u16 = 0x4000;\n+pub(crate) const ATTR_BASE_ADDR: u16 = 0x5800;\n+pub(crate) const ATTR_MAX_ADDR: u16 = 0x5AFF;\n+\/\/\/ relative addresses\n+pub(crate) const BITMAP_MAX_REL: u16 = 0x17FF;\n+pub(crate) const ATTR_BASE_REL: u16 = 0x1800;\n+pub(crate) const ATTR_MAX_REL: u16 = 0x1AFF;\n+\/\/\/ on all spectrums theese values are fixed\n+pub(crate) const CLOCKS_PER_COL: usize = 4;\n+pub(crate) const PIXELS_PER_CLOCK: usize = 2;\n+\/\/\/ size of screen in rows, cols\n+pub(crate) const ATTR_COLS: usize = CANVAS_WIDTH \/ 8;\n+pub(crate) const ATTR_ROWS: usize = CANVAS_HEIGHT \/ 8;\n+pub(crate) const BORDER_COLS: usize = 4;\n+pub(crate) const BORDER_ROWS: usize = 3;\n \/\/\/ Tape loading trap at LD-BREAK routine in ROM\n-pub const ADDR_LD_BREAK: u16 = 0x056B;\n+pub(crate) const ADDR_LD_BREAK: u16 = 0x056B;\ndiff --git a\/rustzx-core\/src\/zx\/controller.rs b\/rustzx-core\/src\/zx\/controller.rs\nindex 218a6fe..793fb83 100644\n--- a\/rustzx-core\/src\/zx\/controller.rs\n+++ b\/rustzx-core\/src\/zx\/controller.rs\n@@ -1,63 +1,64 @@\n \/\/! Contains ZX Spectrum System contrller (like ula or so) of emulator\n use crate::{\n-    host::Host,\n+    error::Error,\n+    host::{Host, HostContext},\n     settings::RustzxSettings,\n-    utils::{events::*, screen::*, split_word, Clocks, InstantFlag},\n+    utils::{screen::bitmap_line_addr, split_word, Clocks},\n     z80::Z80Bus,\n     zx::{\n-        constants::*,\n-        joy::kempston::*,\n+        constants::{ADDR_LD_BREAK, CANVAS_HEIGHT, CLOCKS_PER_COL},\n+        events::EmulationEvents,\n+        joy::kempston::KempstonJoy,\n+        keys::ZXKey,\n         machine::ZXMachine,\n-        memory::{Page, PAGE_SIZE},\n-        roms::*,\n-        screen::{\n-            border::ZXBorder,\n-            canvas::ZXCanvas,\n-            colors::{ZXColor, ZXPalette},\n-        },\n-        sound::mixer::ZXMixer,\n-        tape::{Tap, TapeImpl, ZXTape},\n-        RamType, RomType, ZXKey, ZXMemory,\n+        memory::{Page, RamType, RomType, ZXMemory, PAGE_SIZE},\n+        tape::{TapeImpl, ZXTape},\n+        video::{colors::ZXColor, screen::ZXScreen},\n     },\n };\n \n-\/\/ TODO(#57): Feature gates for resource-heavy features\n+#[cfg(feature = \"embedded-roms\")]\n+use crate::zx::roms;\n+#[cfg(feature = \"sound\")]\n+use crate::zx::sound::mixer::ZXMixer;\n+#[cfg(feature = \"precise-border\")]\n+use crate::zx::video::border::ZXBorder;\n \n \/\/\/ ZX System controller\n-pub struct ZXController<H: Host> {\n+pub(crate) struct ZXController<H: Host> {\n     \/\/ parts of ZX Spectum.\n     pub machine: ZXMachine,\n     pub memory: ZXMemory,\n-    pub canvas: ZXCanvas,\n-    pub tape: ZXTape,\n-    pub border: ZXBorder,\n+    pub screen: ZXScreen<H::FrameBuffer>,\n+    pub tape: ZXTape<H::TapeAsset>,\n+    #[cfg(feature = \"precise-border\")]\n+    pub border: ZXBorder<H::FrameBuffer>,\n     pub kempston: Option<KempstonJoy>,\n-    \/\/ pub beeper: ZXBeeper,\n+    #[cfg(feature = \"sound\")]\n     pub mixer: ZXMixer,\n     pub keyboard: [u8; 8],\n     \/\/ current border color\n-    border_color: u8,\n+    pub border_color: ZXColor,\n     \/\/ clocls count from frame start\n     frame_clocks: Clocks,\n     \/\/ frames count, which passed during emulation invokation\n     passed_frames: usize,\n-    \/\/ main event queue\n-    events: EventQueue,\n-    \/\/ flag, which signals emulator to break emulation and process last event immediately\n-    instant_event: InstantFlag,\n+    events: EmulationEvents,\n     \/\/ audio in\n     mic: bool,\n     \/\/ audio out\n     ear: bool,\n     paging_enabled: bool,\n     screen_bank: u8,\n-    \/\/ `H` will be used when components e.g. Tap type will depend on host impl\n-    _phantom: core::marker::PhantomData<H>,\n+    \/\/ Z80 module expected controller implementation without errors,\n+    \/\/ so we need to store the internal errors manually. For sake of simplicity,\n+    \/\/ Only last error is saved\n+    last_emulation_error: Option<Error>,\n }\n \n impl<H: Host> ZXController<H> {\n     \/\/\/ Returns new ZXController from settings\n-    pub fn new(settings: &RustzxSettings) -> Self {\n+    pub fn new(settings: &RustzxSettings, host_context: H::Context) -> Self {\n         let (memory, paging, screen_bank);\n         match settings.machine {\n             ZXMachine::Sinclair48K => {\n@@ -76,36 +77,60 @@ impl<H: Host> ZXController<H> {\n         } else {\n             None\n         };\n-        let mut out = ZXController {\n+\n+        let screen = ZXScreen::new(settings.machine, host_context.frame_buffer_context());\n+        #[cfg(feature = \"precise-border\")]\n+        let border = ZXBorder::new(settings.machine, host_context.frame_buffer_context());\n+\n+        #[cfg(feature = \"sound\")]\n+        let mixer = Self::create_mixer(settings);\n+\n+        let out = ZXController {\n             machine: settings.machine,\n             memory,\n-            canvas: ZXCanvas::new(settings.machine),\n-            border: ZXBorder::new(settings.machine, ZXPalette::default()),\n+            screen,\n+            #[cfg(feature = \"precise-border\")]\n+            border,\n             kempston,\n-            mixer: ZXMixer::new(settings.beeper_enabled, settings.ay_enabled),\n+            #[cfg(feature = \"sound\")]\n+            mixer,\n             keyboard: [0xFF; 8],\n-            border_color: 0x00,\n+            border_color: ZXColor::Black,\n             frame_clocks: Clocks(0),\n             passed_frames: 0,\n-            tape: Tap::default().into(),\n-            events: EventQueue::default(),\n-            instant_event: InstantFlag::new(false),\n+            tape: Default::default(),\n+            events: Default::default(),\n             mic: false,\n             ear: false,\n             paging_enabled: paging,\n             screen_bank,\n-            _phantom: core::marker::PhantomData::default(),\n+            last_emulation_error: None,\n         };\n-        out.mixer.ay.mode(settings.ay_mode);\n-        out.mixer.volume(settings.sound_volume as f64 \/ 200.0);\n \n+        #[cfg(feature = \"embedded-roms\")]\n         if settings.load_default_rom {\n+            let mut out = out;\n             out.load_default_rom();\n+            return out;\n         }\n \n         out\n     }\n \n+    #[cfg(feature = \"sound\")]\n+    fn create_mixer(settings: &RustzxSettings) -> ZXMixer {\n+        let mut mixer = ZXMixer::new(\n+            settings.beeper_enabled,\n+            #[cfg(feature = \"ay\")]\n+            settings.ay_enabled,\n+            settings.sound_sample_rate,\n+        );\n+        #[cfg(feature = \"ay\")]\n+        mixer.ay.mode(settings.ay_mode);\n+        mixer.volume(settings.sound_volume as f64 \/ 200.0);\n+        mixer\n+    }\n+\n     \/\/\/ returns current frame emulation pos in percents\n     fn frame_pos(&self) -> f64 {\n         let val = self.frame_clocks.count() as f64 \/ self.machine.specs().clocks_frame as f64;\n@@ -117,40 +142,28 @@ impl<H: Host> ZXController<H> {\n     }\n \n     \/\/\/ loads builted-in ROM\n+    #[cfg(feature = \"embedded-roms\")]\n     fn load_default_rom(&mut self) {\n         match self.machine {\n             ZXMachine::Sinclair48K => {\n                 let page = self.memory.rom_page_data_mut(0);\n-                page.copy_from_slice(ROM_48K);\n+                page.copy_from_slice(roms::ROM_48K);\n             }\n             ZXMachine::Sinclair128K => {\n                 let page = self.memory.rom_page_data_mut(0);\n-                page.copy_from_slice(ROM_128K_0);\n+                page.copy_from_slice(roms::ROM_128K_0);\n                 let page = self.memory.rom_page_data_mut(1);\n-                page.copy_from_slice(ROM_128K_1);\n+                page.copy_from_slice(roms::ROM_128K_1);\n             }\n         }\n     }\n \n     \/\/\/ Changes key state in controller\n     pub fn send_key(&mut self, key: ZXKey, pressed: bool) {\n-        \/\/ TODO(#49): Move row detection to ZXKey type\n-        let rownum = match key.half_port {\n-            0xFE => Some(0),\n-            0xFD => Some(1),\n-            0xFB => Some(2),\n-            0xF7 => Some(3),\n-            0xEF => Some(4),\n-            0xDF => Some(5),\n-            0xBF => Some(6),\n-            0x7F => Some(7),\n-            _ => None,\n-        };\n-        if let Some(rownum) = rownum {\n-            self.keyboard[rownum] &= !key.mask;\n-            if !pressed {\n-                self.keyboard[rownum] |= key.mask;\n-            }\n+        let row_id = key.row_id();\n+        self.keyboard[row_id] &= !key.mask();\n+        if !pressed {\n+            self.keyboard[row_id] |= key.mask();\n         }\n     }\n \n@@ -224,24 +237,21 @@ impl<H: Host> ZXController<H> {\n     \/\/\/ Starts a new frame\n     fn new_frame(&mut self) {\n         self.frame_clocks -= self.machine.specs().clocks_frame;\n-        self.canvas.new_frame();\n+        self.screen.new_frame();\n+        #[cfg(feature = \"precise-border\")]\n         self.border.new_frame();\n+        #[cfg(feature = \"sound\")]\n         self.mixer.new_frame();\n     }\n \n-    \/\/\/ force clears all events\n+    \/\/\/ Clears all detected\n     pub fn clear_events(&mut self) {\n         self.events.clear();\n     }\n \n-    \/\/\/ check events count\n-    pub fn no_events(&self) -> bool {\n-        self.events.is_empty()\n-    }\n-\n-    \/\/\/ Returns last event\n-    pub fn pop_event(&mut self) -> Option<Event> {\n-        self.events.receive_event()\n+    \/\/\/ Returns last events\n+    pub fn events(&self) -> EmulationEvents {\n+        self.events\n     }\n \n     \/\/\/ Returns true if all frame clocks has been passed\n@@ -267,7 +277,7 @@ impl<H: Host> ZXController<H> {\n         \/\/ third block is not pageable\n         \/\/ second block is screen buffer, not pageable. but we need to change active buffer\n         let new_screen_bank = if val & 0x08 == 0 { 5 } else { 7 };\n-        self.canvas.switch_bank(new_screen_bank as usize);\n+        self.screen.switch_bank(new_screen_bank as usize);\n         self.screen_bank = new_screen_bank;\n         \/\/ remap ROM\n         self.memory.remap(0, Page::Rom((val >> 4) & 0x01));\n@@ -276,6 +286,46 @@ impl<H: Host> ZXController<H> {\n             self.paging_enabled = false;\n         }\n     }\n+\n+    #[cfg(all(feature = \"sound\", feature = \"ay\"))]\n+    fn read_ay_port(&mut self) -> u8 {\n+        self.mixer.ay.read()\n+    }\n+\n+    #[cfg(not(all(feature = \"sound\", feature = \"ay\")))]\n+    fn read_ay_port(&mut self) -> u8 {\n+        self.floating_bus_value()\n+    }\n+\n+    #[cfg(all(feature = \"sound\", feature = \"ay\"))]\n+    fn write_ay_port(&mut self, value: u8) {\n+        self.mixer.ay.write(value);\n+    }\n+\n+    #[cfg(not(all(feature = \"sound\", feature = \"ay\")))]\n+    fn write_ay_port(&mut self, _: u8) {}\n+\n+    #[cfg(all(feature = \"sound\", feature = \"ay\"))]\n+    fn select_ay_reg(&mut self, value: u8) {\n+        self.mixer.ay.select_reg(value)\n+    }\n+\n+    #[cfg(not(all(feature = \"sound\", feature = \"ay\")))]\n+    fn select_ay_reg(&mut self, _: u8) {}\n+\n+    pub(crate) fn set_border_color(\n+        &mut self,\n+        #[allow(unused_variables)] clocks: Clocks,\n+        color: ZXColor,\n+    ) {\n+        self.border_color = color;\n+        #[cfg(feature = \"precise-border\")]\n+        self.border.set_border(clocks, color);\n+    }\n+\n+    pub(crate) fn take_last_emulation_error(&mut self) -> Option<Error> {\n+        self.last_emulation_error.take()\n+    }\n }\n \n impl<H: Host> Z80Bus for ZXController<H> {\n@@ -293,9 +343,7 @@ impl<H: Host> Z80Bus for ZXController<H> {\n             if addr == ADDR_LD_BREAK {\n                 \/\/ Add event (Fast tape loading request) it must be executed\n                 \/\/ by emulator immediately\n-                self.events\n-                    .send_event(Event::new(EventKind::FastTapeLoad, self.frame_clocks));\n-                self.instant_event.set();\n+                self.events |= EmulationEvents::TAPE_FAST_LOAD_TRIGGER_DETECTED;\n             }\n         }\n     }\n@@ -310,7 +358,7 @@ impl<H: Host> Z80Bus for ZXController<H> {\n         self.memory.write(addr, data);\n         \/\/ if ram then compare bank to screen bank\n         if let Page::Ram(bank) = self.memory.get_page(addr) {\n-            self.canvas\n+            self.screen\n                 .update(addr % PAGE_SIZE as u16, bank as usize, data);\n         }\n     }\n@@ -318,13 +366,18 @@ impl<H: Host> Z80Bus for ZXController<H> {\n     \/\/\/ Cahnges internal state on clocks count change (emualtion processing)\n     fn wait_internal(&mut self, clk: Clocks) {\n         self.frame_clocks += clk;\n-        self.tape.process_clocks(clk);\n+        if let Err(e) = self.tape.process_clocks(clk) {\n+            self.last_emulation_error = Some(e);\n+        }\n         let mic = self.tape.current_bit();\n         self.mic = mic;\n-        let pos = self.frame_pos();\n-        self.mixer.beeper.change_bit(self.mic | self.ear);\n-        self.mixer.process(pos);\n-        self.canvas.process_clocks(self.frame_clocks);\n+        #[cfg(feature = \"sound\")]\n+        {\n+            let pos = self.frame_pos();\n+            self.mixer.beeper.change_bit(self.mic | self.ear);\n+            self.mixer.process(pos);\n+        }\n+        self.screen.process_clocks(self.frame_clocks);\n         if self.frame_clocks.count() >= self.machine.specs().clocks_frame {\n             self.new_frame();\n             self.passed_frames += 1;\n@@ -373,8 +426,7 @@ impl<H: Host> Z80Bus for ZXController<H> {\n             \/\/ 5 and 7 unused\n             tmp\n         } else if port & 0xC002 == 0xC000 {\n-            \/\/ AY regs\n-            self.mixer.ay.read()\n+            self.read_ay_port()\n         } else if self.kempston.is_some() && (port & 0x0020 == 0) {\n             if let Some(ref joy) = self.kempston {\n                 joy.read()\n@@ -395,15 +447,14 @@ impl<H: Host> Z80Bus for ZXController<H> {\n         self.io_contention_first(port);\n         \/\/ find active port\n         if port & 0xC002 == 0xC000 {\n-            self.mixer.ay.select_reg(data);\n+            self.select_ay_reg(data);\n         } else if port & 0xC002 == 0x8000 {\n-            self.mixer.ay.write(data);\n+            self.write_ay_port(data);\n         } else if port & 0x0001 == 0 {\n-            self.border_color = data & 0x07;\n-            self.border\n-                .set_border(self.frame_clocks, ZXColor::from_bits(data & 0x07));\n+            self.set_border_color(self.frame_clocks, ZXColor::from_bits(data & 0x07));\n             self.mic = data & 0x08 != 0;\n             self.ear = data & 0x10 != 0;\n+            #[cfg(feature = \"sound\")]\n             self.mixer.beeper.change_bit(self.mic | self.ear);\n         } else if (port & 0x8002 == 0) && (self.machine == ZXMachine::Sinclair128K) {\n             self.write_7ffd(data);\n@@ -435,9 +486,4 @@ impl<H: Host> Z80Bus for ZXController<H> {\n \n     \/\/\/ CPU calls when was being halted\n     fn halt(&mut self, _: bool) {}\n-\n-    \/\/\/ checks instant events\n-    fn instant_event(&self) -> bool {\n-        self.instant_event.pick()\n-    }\n }\ndiff --git a\/rustzx-core\/src\/zx\/events.rs b\/rustzx-core\/src\/zx\/events.rs\nnew file mode 100644\nindex 0000000..7a5951b\n--- \/dev\/null\n+++ b\/rustzx-core\/src\/zx\/events.rs\n@@ -0,0 +1,14 @@\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    #[derive(Default)]\n+    pub struct EmulationEvents: u8 {\n+        const TAPE_FAST_LOAD_TRIGGER_DETECTED = 0b00000001;\n+    }\n+}\n+\n+impl EmulationEvents {\n+    pub fn clear(&mut self) {\n+        self.bits = 0;\n+    }\n+}\ndiff --git a\/rustzx-core\/src\/zx\/joy\/kempston.rs b\/rustzx-core\/src\/zx\/joy\/kempston.rs\nindex 27a025a..585bb50 100644\n--- a\/rustzx-core\/src\/zx\/joy\/kempston.rs\n+++ b\/rustzx-core\/src\/zx\/joy\/kempston.rs\n@@ -9,7 +9,7 @@ pub enum KempstonKey {\n \n \/\/\/ Kempston Joystick\n #[derive(Default)]\n-pub struct KempstonJoy {\n+pub(crate) struct KempstonJoy {\n     state: u8,\n }\n \ndiff --git a\/rustzx-core\/src\/zx\/keys.rs b\/rustzx-core\/src\/zx\/keys.rs\nindex 4e3950b..1919c6d 100644\n--- a\/rustzx-core\/src\/zx\/keys.rs\n+++ b\/rustzx-core\/src\/zx\/keys.rs\n@@ -1,55 +1,64 @@\n \/\/! Module with hardware key port\\masks\n \n \/\/\/ Struct, which contains mast and port of key\n-pub struct ZXKey {\n-    pub half_port: u8,\n-    pub mask: u8,\n+#[rustfmt::skip]\n+#[derive(Clone, Copy)]\n+pub enum ZXKey {\n+    \/\/ Port 0xFEFE\n+    Shift, Z, X, C, V,\n+    \/\/ Port 0xFDFE\n+    A, S, D, F, G,\n+    \/\/ Port 0xFBFE\n+    Q, W, E, R, T,\n+    \/\/ Port 0xF7FE\n+    N1, N2, N3, N4, N5,\n+    \/\/ Port 0xEFFE\n+    N0, N9, N8, N7, N6,\n+    \/\/ Port 0xDFFE\n+    P, O, I, U, Y,\n+    \/\/ Port 0xBFFE\n+    Enter, L, K, J, H,\n+    \/\/ Port 0x7FFE\n+    Space, SymShift, M, N, B,\n+}\n+\n+impl ZXKey {\n+    pub(crate) fn row_id(self) -> usize {\n+        match self.half_port() {\n+            0xFE => 0,\n+            0xFD => 1,\n+            0xFB => 2,\n+            0xF7 => 3,\n+            0xEF => 4,\n+            0xDF => 5,\n+            0xBF => 6,\n+            0x7F => 7,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    pub(crate) fn mask(&self) -> u8 {\n+        use ZXKey::*;\n+        match self {\n+            Shift | A | Q | N1 | N0 | P | Enter | Space => 0x01,\n+            Z | S | W | N2 | N9 | O | L | SymShift => 0x02,\n+            X | D | E | N3 | N8 | I | K | M => 0x04,\n+            C | F | R | N4 | N7 | U | J | N => 0x08,\n+            V | G | T | N5 | N6 | Y | H | B => 0x10,\n+        }\n+    }\n+\n+    fn half_port(self) -> u8 {\n+        use ZXKey::*;\n+        match self {\n+            Shift | Z | X | C | V => 0xFE,\n+            A | S | D | F | G => 0xFD,\n+            Q | W | E | R | T => 0xFB,\n+            N1 | N2 | N3 | N4 | N5 => 0xF7,\n+            N0 | N9 | N8 | N7 | N6 => 0xEF,\n+            P | O | I | U | Y => 0xDF,\n+            Enter | L | K | J | H => 0xBF,\n+            Space | SymShift | M | N | B => 0x7F,\n+        }\n+    }\n }\n-\/\/ 0xFEFE\n-pub const ZX_KEY_SHIFT: ZXKey = ZXKey { half_port: 0xFE, mask: 0x01 };\n-pub const ZX_KEY_Z: ZXKey = ZXKey { half_port: 0xFE, mask: 0x02 };\n-pub const ZX_KEY_X: ZXKey = ZXKey { half_port: 0xFE, mask: 0x04 };\n-pub const ZX_KEY_C: ZXKey = ZXKey { half_port: 0xFE, mask: 0x08 };\n-pub const ZX_KEY_V: ZXKey = ZXKey { half_port: 0xFE, mask: 0x10 };\n-\/\/ FDFE\n-pub const ZX_KEY_A: ZXKey = ZXKey { half_port: 0xFD, mask: 0x01 };\n-pub const ZX_KEY_S: ZXKey = ZXKey { half_port: 0xFD, mask: 0x02 };\n-pub const ZX_KEY_D: ZXKey = ZXKey { half_port: 0xFD, mask: 0x04 };\n-pub const ZX_KEY_F: ZXKey = ZXKey { half_port: 0xFD, mask: 0x08 };\n-pub const ZX_KEY_G: ZXKey = ZXKey { half_port: 0xFD, mask: 0x10 };\n-\/\/ FBFE\n-pub const ZX_KEY_Q: ZXKey = ZXKey { half_port: 0xFB, mask: 0x01 };\n-pub const ZX_KEY_W: ZXKey = ZXKey { half_port: 0xFB, mask: 0x02 };\n-pub const ZX_KEY_E: ZXKey = ZXKey { half_port: 0xFB, mask: 0x04 };\n-pub const ZX_KEY_R: ZXKey = ZXKey { half_port: 0xFB, mask: 0x08 };\n-pub const ZX_KEY_T: ZXKey = ZXKey { half_port: 0xFB, mask: 0x10 };\n-\/\/ F7FE\n-pub const ZX_KEY_1: ZXKey = ZXKey { half_port: 0xF7, mask: 0x01 };\n-pub const ZX_KEY_2: ZXKey = ZXKey { half_port: 0xF7, mask: 0x02 };\n-pub const ZX_KEY_3: ZXKey = ZXKey { half_port: 0xF7, mask: 0x04 };\n-pub const ZX_KEY_4: ZXKey = ZXKey { half_port: 0xF7, mask: 0x08 };\n-pub const ZX_KEY_5: ZXKey = ZXKey { half_port: 0xF7, mask: 0x10 };\n-\/\/ EFFE\n-pub const ZX_KEY_0: ZXKey = ZXKey { half_port: 0xEF, mask: 0x01 };\n-pub const ZX_KEY_9: ZXKey = ZXKey { half_port: 0xEF, mask: 0x02 };\n-pub const ZX_KEY_8: ZXKey = ZXKey { half_port: 0xEF, mask: 0x04 };\n-pub const ZX_KEY_7: ZXKey = ZXKey { half_port: 0xEF, mask: 0x08 };\n-pub const ZX_KEY_6: ZXKey = ZXKey { half_port: 0xEF, mask: 0x10 };\n-\/\/DFFE\n-pub const ZX_KEY_P: ZXKey = ZXKey { half_port: 0xDF, mask: 0x01 };\n-pub const ZX_KEY_O: ZXKey = ZXKey { half_port: 0xDF, mask: 0x02 };\n-pub const ZX_KEY_I: ZXKey = ZXKey { half_port: 0xDF, mask: 0x04 };\n-pub const ZX_KEY_U: ZXKey = ZXKey { half_port: 0xDF, mask: 0x08 };\n-pub const ZX_KEY_Y: ZXKey = ZXKey { half_port: 0xDF, mask: 0x10 };\n-\/\/ BFFE\n-pub const ZX_KEY_ENTER: ZXKey = ZXKey { half_port: 0xBF, mask: 0x01 };\n-pub const ZX_KEY_L: ZXKey = ZXKey { half_port: 0xBF, mask: 0x02 };\n-pub const ZX_KEY_K: ZXKey = ZXKey { half_port: 0xBF, mask: 0x04 };\n-pub const ZX_KEY_J: ZXKey = ZXKey { half_port: 0xBF, mask: 0x08 };\n-pub const ZX_KEY_H: ZXKey = ZXKey { half_port: 0xBF, mask: 0x10 };\n-\/\/ 7FFE\n-pub const ZX_KEY_SPACE: ZXKey = ZXKey { half_port: 0x7F, mask: 0x01 };\n-pub const ZX_KEY_SYM_SHIFT: ZXKey = ZXKey { half_port: 0x7F, mask: 0x02 };\n-pub const ZX_KEY_M: ZXKey = ZXKey { half_port: 0x7F, mask: 0x04 };\n-pub const ZX_KEY_N: ZXKey = ZXKey { half_port: 0x7F, mask: 0x08 };\n-pub const ZX_KEY_B: ZXKey = ZXKey { half_port: 0x7F, mask: 0x10 };\ndiff --git a\/rustzx-core\/src\/zx\/machine\/mod.rs b\/rustzx-core\/src\/zx\/machine\/mod.rs\nindex 16c666c..2043525 100644\n--- a\/rustzx-core\/src\/zx\/machine\/mod.rs\n+++ b\/rustzx-core\/src\/zx\/machine\/mod.rs\n@@ -2,14 +2,16 @@\n \n \/\/ Allow outer modules to use ZXSpecs struct, but not construct\n mod specs;\n-pub use self::specs::ZXSpecs;\n-use self::specs::ZXSpecsBuilder;\n+\n use crate::utils::Clocks;\n use lazy_static::lazy_static;\n+use specs::ZXSpecsBuilder;\n+\n+pub(crate) use specs::ZXSpecs;\n \n lazy_static! {\n     \/\/\/ ZX Spectrum 48K Specs\n-    pub static ref SPECS_48K: ZXSpecs = {\n+    pub(crate) static ref SPECS_48K: ZXSpecs = {\n         ZXSpecsBuilder::new()\n             .freq_cpu(3_500_000)\n             .clocks_first_pixel(14336)\ndiff --git a\/rustzx-core\/src\/zx\/machine\/specs.rs b\/rustzx-core\/src\/zx\/machine\/specs.rs\nindex 350bb77..6ff7561 100644\n--- a\/rustzx-core\/src\/zx\/machine\/specs.rs\n+++ b\/rustzx-core\/src\/zx\/machine\/specs.rs\n@@ -1,7 +1,3 @@\n-use crate::zx::constants::BORDER_COLS;\n-use alloc::{vec, vec::Vec};\n-\n-\/\/\/ Immutable type (Builder is not public in outer module)\n pub struct ZXSpecs {\n     \/\/ frequencies\n     pub freq_cpu: usize,\n@@ -13,7 +9,6 @@ pub struct ZXSpecs {\n     pub clocks_right_border: usize,\n     pub clocks_retrace: usize,\n     pub clocks_line: usize,\n-    pub clocks_line_base: Vec<usize>,\n     \/\/ some ula clocks\n     pub clocks_ula_read_shift: usize,\n     pub clocks_ula_read_origin: usize,\n@@ -54,7 +49,6 @@ impl ZXSpecsBuilder {\n                 clocks_right_border: 0,\n                 clocks_retrace: 0,\n                 clocks_line: 0,\n-                clocks_line_base: vec![],\n                 \/\/ some ula clocks\n                 clocks_ula_read_shift: 0,\n                 clocks_ula_read_origin: 0,\n@@ -83,19 +77,6 @@ impl ZXSpecsBuilder {\n     pub fn build(mut self) -> ZXSpecs {\n         self.specs.clocks_frame =\n             (self.specs.lines_all + self.specs.lines_vsync) * self.specs.clocks_line;\n-        \/\/ 4*4 is 4 border columns * 4 clocks per column\n-        self.specs.clocks_line_base.push(\n-            self.specs.clocks_first_pixel\n-                - self.specs.lines_top_border * self.specs.clocks_line\n-                - BORDER_COLS * 4,\n-        );\n-        \/\/ + 1 because TStates in calculations may be > frame length (CHECK)\n-        let lines_count = self.specs.lines_all + 1;\n-        for _ in 1..lines_count {\n-            let last = *self.specs.clocks_line_base.last().unwrap();\n-            let line_clocks = self.specs.clocks_line;\n-            self.specs.clocks_line_base.push(last + line_clocks);\n-        }\n         self.specs.clocks_ula_read_origin =\n             self.specs.clocks_first_pixel + self.specs.clocks_ula_read_shift;\n         self.specs.clocks_ula_contention_origin =\ndiff --git a\/rustzx-core\/src\/zx\/mod.rs b\/rustzx-core\/src\/zx\/mod.rs\nindex b3de060..f591012 100644\n--- a\/rustzx-core\/src\/zx\/mod.rs\n+++ b\/rustzx-core\/src\/zx\/mod.rs\n@@ -1,24 +1,16 @@\n \/\/! Module with ZX Spectrum related things\n \/\/! One of core platform-independent modules\n+pub(crate) mod controller;\n+pub(crate) mod events;\n+pub(crate) mod memory;\n+#[cfg(feature = \"embedded-roms\")]\n+pub(crate) mod roms;\n+pub(crate) mod tape;\n+\n pub mod constants;\n-pub mod controller;\n pub mod joy;\n-#[rustfmt::skip]\n pub mod keys;\n pub mod machine;\n-pub mod memory;\n-pub mod roms;\n-pub mod screen;\n+#[cfg(feature = \"sound\")]\n pub mod sound;\n-pub mod tape;\n-\n-\/\/ re-export most of things\n-\/\/ TODO(#48): Reorganize imports\n-pub use self::{\n-    controller::ZXController,\n-    keys::*,\n-    machine::{ZXMachine, ZXSpecs},\n-    memory::{RamType, RomType, ZXMemory},\n-    screen::*,\n-    tape::ZXTape,\n-};\n+pub mod video;\ndiff --git a\/rustzx-core\/src\/zx\/screen\/colors.rs b\/rustzx-core\/src\/zx\/screen\/colors.rs\ndeleted file mode 100644\nindex b40deca..0000000\n--- a\/rustzx-core\/src\/zx\/screen\/colors.rs\n+++ \/dev\/null\n@@ -1,163 +0,0 @@\n-\/\/! Contains Color generation related types\n-use crate::zx::constants::BYTES_PER_PIXEL;\n-\n-\/\/\/ struct represents single pixel color as array of bytes\n-pub type ColorArray = [u8; BYTES_PER_PIXEL];\n-\n-\/\/\/ splits usize value to 4 bytes\n-#[rustfmt::skip]\n-fn split_in_bytes(val: usize) -> ColorArray {\n-    [\n-        ((val >> 24) & 0xFF) as u8,\n-        ((val >> 16) & 0xFF) as u8,\n-        ((val >>  8) & 0xFF) as u8,\n-        (val & 0xFF) as u8\n-    ]\n-}\n-\n-\/\/\/ Represents color brightness\n-#[derive(Clone, Copy)]\n-pub enum ZXBrightness {\n-    Normal,\n-    Bright,\n-}\n-\n-\/\/\/ ZX Spectrum color enum\n-\/\/\/ Constructs self from 3-bit value\n-#[derive(Clone, Copy)]\n-pub enum ZXColor {\n-    Black,\n-    Blue,\n-    Red,\n-    Purple,\n-    Green,\n-    Cyan,\n-    Yellow,\n-    White,\n-}\n-\n-impl ZXColor {\n-    \/\/\/ Returns ZXColor from 3 bits\n-    \/\/\/ # Panics\n-    \/\/\/ Panics when input color is bigger than 7\n-    pub fn from_bits(bits: u8) -> ZXColor {\n-        assert!(bits <= 7);\n-        match bits {\n-            0 => ZXColor::Black,\n-            1 => ZXColor::Blue,\n-            2 => ZXColor::Red,\n-            3 => ZXColor::Purple,\n-            4 => ZXColor::Green,\n-            5 => ZXColor::Cyan,\n-            6 => ZXColor::Yellow,\n-            7 => ZXColor::White,\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n-\/\/\/ ZX Spectrum attribute structure\n-\/\/\/ It contains information about ink, paper color,\n-\/\/\/ flash attribute and brightness\n-#[derive(Clone, Copy)]\n-pub struct ZXAttribute {\n-    pub ink: ZXColor,\n-    pub paper: ZXColor,\n-    pub brightness: ZXBrightness,\n-    pub flash: bool,\n-}\n-\n-impl ZXAttribute {\n-    \/\/\/ Constructs self from byte\n-    pub fn from_byte(data: u8) -> ZXAttribute {\n-        ZXAttribute {\n-            ink: ZXColor::from_bits(data & 0x07),\n-            paper: ZXColor::from_bits((data >> 3) & 0x07),\n-            flash: (data & 0x80) != 0,\n-            brightness: if (data & 0x40) != 0 {\n-                ZXBrightness::Bright\n-            } else {\n-                ZXBrightness::Normal\n-            },\n-        }\n-    }\n-\n-    \/\/\/ Returns active color of pixel in current attribute\n-    pub fn active_color(&self, state: bool, enable_flash: bool) -> ZXColor {\n-        if state ^ (self.flash && enable_flash) {\n-            self.ink\n-        } else {\n-            self.paper\n-        }\n-    }\n-}\n-\n-\/\/\/ represents set of colors\n-struct ColorSet {\n-    black: ColorArray,\n-    blue: ColorArray,\n-    red: ColorArray,\n-    purple: ColorArray,\n-    green: ColorArray,\n-    cyan: ColorArray,\n-    yellow: ColorArray,\n-    white: ColorArray,\n-}\n-\/\/\/ Structure, that holds palette information.\n-\/\/\/ It have method to transform ZX Spectrum screen data\n-\/\/\/ to 4-byte rgba bixel\n-pub struct ZXPalette {\n-    transparent: ColorArray,\n-    \/\/ 2 color sets\n-    bright: ColorSet,\n-    normal: ColorSet,\n-}\n-\n-impl ZXPalette {\n-    \/\/\/ Returns default palette\n-    #[rustfmt::skip]\n-    pub fn default() -> ZXPalette {\n-        ZXPalette {\n-            transparent: split_in_bytes(0x00000000),\n-            normal: ColorSet {\n-                black:   split_in_bytes(0x000000FF),\n-                blue:    split_in_bytes(0x0000CDFF),\n-                red:     split_in_bytes(0xCD0000FF),\n-                purple:  split_in_bytes(0xCD00CDFF),\n-                green:   split_in_bytes(0x00CD00FF),\n-                cyan:    split_in_bytes(0x00CDCDFF),\n-                yellow:  split_in_bytes(0xCDCD00FF),\n-                white:   split_in_bytes(0xCDCDCDFF),\n-            },\n-            bright: ColorSet {\n-                black:   split_in_bytes(0x000000FF),\n-                blue:    split_in_bytes(0x0000FFFF),\n-                red:     split_in_bytes(0xFF0000FF),\n-                purple:  split_in_bytes(0xFF00FFFF),\n-                green:   split_in_bytes(0x00FF00FF),\n-                cyan:    split_in_bytes(0x00FFFFFF),\n-                yellow:  split_in_bytes(0xFFFF00FF),\n-                white:   split_in_bytes(0xFFFFFFFF),\n-            }\n-        }\n-    }\n-\n-    \/\/\/ Returns rgba pixel from screen data\n-    pub fn get_rgba(&self, color: ZXColor, brightness: ZXBrightness) -> &ColorArray {\n-        \/\/ select palette\n-        let set = match brightness {\n-            ZXBrightness::Normal => &self.normal,\n-            ZXBrightness::Bright => &self.bright,\n-        };\n-        match color {\n-            ZXColor::Black => &set.black,\n-            ZXColor::Blue => &set.blue,\n-            ZXColor::Red => &set.red,\n-            ZXColor::Purple => &set.purple,\n-            ZXColor::Green => &set.green,\n-            ZXColor::Cyan => &set.cyan,\n-            ZXColor::Yellow => &set.yellow,\n-            ZXColor::White => &set.white,\n-        }\n-    }\n-}\ndiff --git a\/rustzx-core\/src\/zx\/sound\/ay.rs b\/rustzx-core\/src\/zx\/sound\/ay.rs\nindex b2ed3ec..3dc166d 100644\n--- a\/rustzx-core\/src\/zx\/sound\/ay.rs\n+++ b\/rustzx-core\/src\/zx\/sound\/ay.rs\n@@ -1,9 +1,6 @@\n use crate::{\n     utils::make_word,\n-    zx::sound::{\n-        sample::{SampleGenerator, SoundSample},\n-        SAMPLE_RATE,\n-    },\n+    zx::sound::sample::{SampleGenerator, SoundSample},\n };\n use ayumi::{Ayumi, ChipType, ToneChannel};\n \n@@ -20,7 +17,7 @@ pub enum ZXAYMode {\n }\n \n \/\/\/ AY Chip implementation using Ayumi lib\n-pub struct ZXAyChip {\n+pub(crate) struct ZXAyChip {\n     ay: Ayumi,\n     current_reg: usize,\n     regs: [u8; 16],\n@@ -28,10 +25,10 @@ pub struct ZXAyChip {\n \n impl ZXAyChip {\n     \/\/\/ Constructs new AY Chip\n-    pub fn new(mode: ZXAYMode) -> ZXAyChip {\n+    pub fn new(sample_rate: usize, mode: ZXAYMode) -> ZXAyChip {\n         \/\/ configure ayumi\n         let mut out = ZXAyChip {\n-            ay: Ayumi::new(ChipType::AY, AY_FREQ, SAMPLE_RATE as i32),\n+            ay: Ayumi::new(ChipType::AY, AY_FREQ, sample_rate as i32),\n             current_reg: 0,\n             regs: [0; 16],\n         };\ndiff --git a\/rustzx-core\/src\/zx\/sound\/beeper.rs b\/rustzx-core\/src\/zx\/sound\/beeper.rs\nindex b2419ff..6b25ab4 100644\n--- a\/rustzx-core\/src\/zx\/sound\/beeper.rs\n+++ b\/rustzx-core\/src\/zx\/sound\/beeper.rs\n@@ -2,7 +2,7 @@ use crate::zx::sound::sample::{SampleGenerator, SoundSample};\n \n \/\/\/ Simple beeper implementation\n #[derive(Default)]\n-pub struct ZXBeeper {\n+pub(crate) struct ZXBeeper {\n     curr_bit: bool,\n     next_bit: bool,\n }\ndiff --git a\/rustzx-core\/src\/zx\/sound\/mixer.rs b\/rustzx-core\/src\/zx\/sound\/mixer.rs\nindex 51df281..4cd384b 100644\n--- a\/rustzx-core\/src\/zx\/sound\/mixer.rs\n+++ b\/rustzx-core\/src\/zx\/sound\/mixer.rs\n@@ -1,26 +1,35 @@\n \/\/! Module implemets zx spectrum audio devices mixer\n-use crate::zx::sound::{\n-    ay::{ZXAYMode, ZXAyChip},\n-    beeper::ZXBeeper,\n-    sample::{SampleGenerator, SoundSample},\n-    samples_from_time, SAMPLES,\n+use crate::zx::{\n+    constants::FPS,\n+    sound::{\n+        beeper::ZXBeeper,\n+        sample::{SampleGenerator, SoundSample},\n+    },\n };\n+\n+#[cfg(feature = \"ay\")]\n+use crate::zx::sound::ay::{ZXAYMode, ZXAyChip};\n+\n use alloc::collections::VecDeque;\n \n \/\/\/ Main sound mixer.\n-pub struct ZXMixer {\n+pub(crate) struct ZXMixer {\n     \/\/\/ direct access to beeper device\n     pub beeper: ZXBeeper,\n     \/\/\/ direct access to AY device\n+    #[cfg(feature = \"ay\")]\n     pub ay: ZXAyChip,\n     ring_buffer: VecDeque<SoundSample<f32>>,\n     last_pos: usize,\n     last_sample: SoundSample<f32>,\n     master_volume: f64,\n     beeper_volume: f64,\n+    #[cfg(feature = \"ay\")]\n     ay_volume: f64,\n+    #[cfg(feature = \"ay\")]\n     use_ay: bool,\n     use_beeper: bool,\n+    sample_rate: usize,\n }\n \n impl ZXMixer {\n@@ -28,18 +37,26 @@ impl ZXMixer {\n     \/\/\/ # Arguments\n     \/\/\/ - `use_beeper` - process beeper or not\n     \/\/\/ - `use_ay` - process ay chip or not\n-    pub fn new(use_beeper: bool, use_ay: bool) -> ZXMixer {\n+    pub fn new(\n+        use_beeper: bool,\n+        #[cfg(feature = \"ay\")] use_ay: bool,\n+        sample_rate: usize,\n+    ) -> ZXMixer {\n         ZXMixer {\n             beeper: ZXBeeper::default(),\n-            ay: ZXAyChip::new(ZXAYMode::Mono),\n-            ring_buffer: VecDeque::with_capacity(SAMPLES),\n+            #[cfg(feature = \"ay\")]\n+            ay: ZXAyChip::new(sample_rate, ZXAYMode::Mono),\n+            ring_buffer: VecDeque::with_capacity(sample_rate),\n             last_pos: 0,\n             last_sample: SoundSample::new(0.0, 0.0),\n             master_volume: 0.5,\n             beeper_volume: 1.0,\n+            #[cfg(feature = \"ay\")]\n             ay_volume: 1.0,\n+            #[cfg(feature = \"ay\")]\n             use_ay,\n             use_beeper,\n+            sample_rate,\n         }\n     }\n \n@@ -53,11 +70,11 @@ impl ZXMixer {\n     \/\/\/ Updates internal buffer of mixer and fills it with new samples\n     pub fn process(&mut self, current_time: f64) {\n         \/\/ buffer overflow\n-        if self.ring_buffer.len() >= SAMPLES {\n+        if self.ring_buffer.len() >= self.samples_per_frame() {\n             return;\n         }\n         \/\/ so at this moment we need to get new samples from devices\n-        let curr_pos = samples_from_time(current_time);\n+        let curr_pos = self.sample_count_for_frame_fraction(current_time);\n         \/\/ if we on same pos or frame passed then no new samples\n         if curr_pos <= self.last_pos {\n             return;\n@@ -73,8 +90,8 @@ impl ZXMixer {\n \n     \/\/\/ fills buffer to eng on new frame\n     pub fn new_frame(&mut self) {\n-        if self.ring_buffer.len() < SAMPLES {\n-            for _ in self.ring_buffer.len()..SAMPLES {\n+        if self.ring_buffer.len() < self.samples_per_frame() {\n+            for _ in self.ring_buffer.len()..self.samples_per_frame() {\n                 self.ring_buffer.push_back(self.last_sample);\n             }\n         }\n@@ -92,6 +109,7 @@ impl ZXMixer {\n             SoundSample::new(0.0, 0.0)\n         };\n         \/\/ prevent AY sound generation if disabled [it is pretty long process]\n+        #[cfg(feature = \"ay\")]\n         if self.use_ay {\n             master_float.mix(&self.ay.gen_sample());\n         }\n@@ -99,4 +117,15 @@ impl ZXMixer {\n         self.last_sample = master;\n         master\n     }\n+\n+    fn samples_per_frame(&self) -> usize {\n+        self.sample_rate \/ FPS\n+    }\n+\n+    fn sample_count_for_frame_fraction(&self, fraction: f64) -> usize {\n+        if fraction >= 1f64 {\n+            return self.samples_per_frame();\n+        }\n+        (self.samples_per_frame() as f64 * fraction) as usize\n+    }\n }\ndiff --git a\/rustzx-core\/src\/zx\/sound\/mod.rs b\/rustzx-core\/src\/zx\/sound\/mod.rs\nindex dbd6782..acd95bc 100644\n--- a\/rustzx-core\/src\/zx\/sound\/mod.rs\n+++ b\/rustzx-core\/src\/zx\/sound\/mod.rs\n@@ -1,23 +1,7 @@\n \/\/! Module implements emulation of sound chip AY, Spectrum Beeper and Mixer\n+#[cfg(feature = \"ay\")]\n pub mod ay;\n-pub mod beeper;\n-pub mod mixer;\n pub mod sample;\n \n-use crate::zx::constants::FPS;\n-\n-pub const SAMPLE_RATE: usize = 44100;\n-\/\/\/ samples per frame\n-pub const SAMPLES: usize = SAMPLE_RATE \/ FPS;\n-pub const CHANNELS: usize = 2;\n-\n-\/\/\/ Returns, which must be already processed at this time\n-pub fn samples_from_time(time: f64) -> usize {\n-    if time >= 1.0 {\n-        SAMPLES\n-    } else if time <= 0.0 {\n-        0\n-    } else {\n-        (SAMPLES as f64 * time) as usize\n-    }\n-}\n+pub(crate) mod beeper;\n+pub(crate) mod mixer;\ndiff --git a\/rustzx-core\/src\/zx\/sound\/sample.rs b\/rustzx-core\/src\/zx\/sound\/sample.rs\nindex c83e339..8a3d141 100644\n--- a\/rustzx-core\/src\/zx\/sound\/sample.rs\n+++ b\/rustzx-core\/src\/zx\/sound\/sample.rs\n@@ -2,6 +2,7 @@ use core::{\n     i16,\n     ops::{Add, Mul, MulAssign, Sub},\n };\n+\n \/\/\/ Raw Sample can be only f64 or i16\n pub trait RawSample: Clone + Copy + MulAssign + Mul + Add + Sub {}\n impl RawSample for f64 {}\n@@ -58,30 +59,6 @@ impl SoundSample<f64> {\n         self\n     }\n \n-    \/\/\/ Transforms normalized float sample to i16 sample\n-    pub fn into_i16(self) -> SoundSample<i16> {\n-        \/\/ here is some thick hack :D\n-        \/\/ we have value in 0.0..1.0. We need value in min_i16...max_i16 (signed)\n-        \/\/ so we unly need one float multiplication, one floor and one XOR with highest bit\n-        \/\/ multiplication + floor => 0...max_u16\n-        \/\/ XOR =>  4 bit example {\n-        \/\/      0b0000 [0] => 0b1000 [-8]\n-        \/\/      0b0001 [1] => 0b1000 [-7]\n-        \/\/      ...\n-        \/\/      0b0111 [7] => 0b1111 [-1]\n-        \/\/      0b1000 [8] => 0b0000 [0]\n-        \/\/      0b1000 [9] => 0b0001 [1]\n-        \/\/      ...\n-        \/\/      0b1111 [15] => 0b0111 [7]\n-        \/\/ }\n-        \/\/ So we can easily get range expansion only with XOR operation in MSb\n-        \/\/ NOTE: `i16 as u16` and `u16 as i16` have no cost\n-        SoundSample {\n-            left: ((self.left * (u16::max_value() - ERROR_SIZE) as f64) as u16 ^ 0x8000) as i16,\n-            right: ((self.right * (u16::max_value() - ERROR_SIZE) as f64) as u16 ^ 0x8000) as i16,\n-        }\n-    }\n-\n     \/\/\/ transform into f32\n     pub fn into_f32(self) -> SoundSample<f32> {\n         SoundSample {\n@@ -105,7 +82,7 @@ impl SoundSample<f64> {\n }\n \n \/\/\/ Trait which signals that structure can generate SoundSamples\n-pub trait SampleGenerator<T>\n+pub(crate) trait SampleGenerator<T>\n where\n     T: RawSample,\n {\ndiff --git a\/rustzx-core\/src\/zx\/tape\/empty.rs b\/rustzx-core\/src\/zx\/tape\/empty.rs\nnew file mode 100644\nindex 0000000..205d94e\n--- \/dev\/null\n+++ b\/rustzx-core\/src\/zx\/tape\/empty.rs\n@@ -0,0 +1,33 @@\n+use crate::{utils::Clocks, zx::tape::TapeImpl, Result};\n+\n+pub struct Empty;\n+\n+impl TapeImpl for Empty {\n+    fn can_fast_load(&self) -> bool {\n+        false\n+    }\n+\n+    fn next_block_byte(&mut self) -> Result<Option<u8>> {\n+        Ok(None)\n+    }\n+\n+    fn next_block(&mut self) -> Result<bool> {\n+        Ok(false)\n+    }\n+\n+    fn current_bit(&self) -> bool {\n+        false\n+    }\n+\n+    fn process_clocks(&mut self, _clocks: Clocks) -> Result<()> {\n+        Ok(())\n+    }\n+\n+    fn stop(&mut self) {}\n+\n+    fn play(&mut self) {}\n+\n+    fn rewind(&mut self) -> Result<()> {\n+        Ok(())\n+    }\n+}\ndiff --git a\/rustzx-core\/src\/zx\/tape\/mod.rs b\/rustzx-core\/src\/zx\/tape\/mod.rs\nindex 847022b..1188910 100644\n--- a\/rustzx-core\/src\/zx\/tape\/mod.rs\n+++ b\/rustzx-core\/src\/zx\/tape\/mod.rs\n@@ -1,42 +1,37 @@\n-\/\/! Contains Tape handling type and functions\n-\n+mod empty;\n mod tap;\n-\/\/ reexport Tap Tape player\n-pub use self::tap::Tap;\n \n-use crate::utils::Clocks;\n+pub use self::{empty::Empty, tap::Tap};\n+\n+use crate::{host::LoadableAsset, utils::Clocks, Result};\n \n use enum_dispatch::enum_dispatch;\n \n #[enum_dispatch(TapeImpl)]\n-pub enum ZXTape {\n-    Tap(Tap),\n+pub enum ZXTape<A: LoadableAsset> {\n+    Tap(Tap<A>),\n+    Empty(Empty),\n+}\n+\n+impl<A: LoadableAsset> Default for ZXTape<A> {\n+    fn default() -> Self {\n+        Self::Empty(Empty)\n+    }\n }\n \n #[enum_dispatch]\n pub trait TapeImpl {\n-    \/\/ -----------------\n-    \/\/ FAST LOAD SECTION\n-    \/\/ -----------------\n-    \/\/\/ is this type of tape is allowed to fast load blocks?\n     fn can_fast_load(&self) -> bool;\n-    \/\/\/ Returns byte of current block or `None` if offset exceeds block Size\n-    fn block_byte(&self, offset: usize) -> Option<u8>;\n-    \/\/\/ Moves tape pointer to next block\n-    fn next_block(&mut self);\n-    \/\/\/ Resets relative position in block to zero\n-    fn reset_pos_in_block(&mut self);\n-    \/\/ -----------------\n-    \/\/  GENERAL SECTION\n-    \/\/ -----------------\n-    \/\/\/ Returns current ear bit\n+    \/\/\/ Returns byte of current block or `None` if block has ended\n+    fn next_block_byte(&mut self) -> Result<Option<u8>>;\n+    \/\/\/ Loads next block. Retruns false if end of the tape is reached\n+    fn next_block(&mut self) -> Result<bool>;\n+    \/\/\/ Returns current tape (`ear`) bit\n     fn current_bit(&self) -> bool;\n-    \/\/\/ Makes procession of type in definite time\n-    fn process_clocks(&mut self, clocks: Clocks);\n-    \/\/\/ stops tape\n+    \/\/\/ Perform tape processing emulation within `clocks` time limit\n+    fn process_clocks(&mut self, clocks: Clocks) -> Result<()>;\n     fn stop(&mut self);\n-    \/\/\/ plays tape\n     fn play(&mut self);\n-    \/\/\/ rewinds tape\n-    fn rewind(&mut self);\n+    \/\/\/ Rewinds tape content to the beginning\n+    fn rewind(&mut self) -> Result<()>;\n }\ndiff --git a\/rustzx-core\/src\/zx\/tape\/tap.rs b\/rustzx-core\/src\/zx\/tape\/tap.rs\nindex feaa5e7..ca66c9e 100644\n--- a\/rustzx-core\/src\/zx\/tape\/tap.rs\n+++ b\/rustzx-core\/src\/zx\/tape\/tap.rs\n@@ -1,9 +1,11 @@\n-\/\/! TAP file tape player\n+use crate::{\n+    error::TapeLoadError,\n+    host::{LoadableAsset, SeekFrom},\n+    utils::{make_word, Clocks},\n+    zx::tape::TapeImpl,\n+    Result,\n+};\n \n-use crate::{host::LoadableAsset, utils::Clocks, zx::tape::TapeImpl, Result};\n-use alloc::vec::Vec;\n-\n-\/\/ main constants\n const PILOT_LENGTH: usize = 2168;\n const PILOT_PULSES_HEADER: usize = 8063;\n const PILOT_PULSES_DATA: usize = 3223;\n@@ -12,335 +14,263 @@ const SYNC2_LENGTH: usize = 735;\n const BIT_ONE_LENGTH: usize = 1710;\n const BIT_ZERO_LENGTH: usize = 855;\n const PAUSE_LENGTH: usize = 3_500_000;\n+const BUFFER_SIZE: usize = 128;\n \n-\/\/\/ state of tape player\n #[derive(PartialEq, Eq, Clone, Copy)]\n enum TapeState {\n     Stop,\n     Play,\n-    Pilot,\n+    Pilot { pulses_left: usize },\n     Sync,\n     NextByte,\n-    NextBit,\n-    BitHalf(usize),\n+    NextBit { mask: u8 },\n+    BitHalf { half_bit_delay: usize, mask: u8 },\n     Pause,\n }\n \n-\/\/\/ information about block of tape\n-#[derive(Clone, Copy)]\n-struct BlockInfo {\n-    length: usize,\n-    pos: usize,\n-    end: usize,\n-}\n-\n-\/\/ TODO(#53): Eliminate loading a whole file to vector in tap loader\n-\n-pub struct Tap {\n-    \/\/\/ state of tape\n+pub struct Tap<A: LoadableAsset> {\n+    asset: A,\n     state: TapeState,\n-    \/\/\/ previous state\n     prev_state: TapeState,\n-    \/\/\/ data of tape\n-    data: Vec<u8>,\n-    \/\/\/ fields for pulse making from byte\n+    buffer: [u8; BUFFER_SIZE],\n+    bufer_offset: usize,\n+    block_bytes_read: usize,\n+    current_block_size: Option<usize>,\n+    tape_ended: bool,\n+    \/\/ Non-fastload related fields\n     curr_bit: bool,\n     curr_byte: u8,\n-    curr_mask: u8,\n-    \/\/ pulses left to next state\n-    pulse_counter: usize,\n-    \/\/\/ block info\n-    block_info: Vec<BlockInfo>,\n-    block: usize,\n-    pos_in_block: usize,\n-    \/\/\/ between-state timings\n     delay: Clocks,\n-    acc_clocks: Clocks,\n }\n \n-impl Default for Tap {\n-    fn default() -> Self {\n-        Self {\n+impl<A: LoadableAsset> Tap<A> {\n+    pub fn from_asset(asset: A) -> Result<Self> {\n+        let tap = Self {\n             prev_state: TapeState::Stop,\n             state: TapeState::Stop,\n-            data: Vec::new(),\n             curr_bit: false,\n             curr_byte: 0x00,\n-            curr_mask: 0x80,\n-            pulse_counter: 0,\n-            block_info: Vec::new(),\n-            block: 0,\n-            pos_in_block: 0,\n+            buffer: [0u8; BUFFER_SIZE],\n+            bufer_offset: 0,\n+            block_bytes_read: 0,\n+            current_block_size: None,\n             delay: Clocks(0),\n-            acc_clocks: Clocks(0),\n-        }\n+            asset,\n+            tape_ended: false,\n+        };\n+        Ok(tap)\n     }\n }\n \n-impl Tap {\n-    \/\/\/ updates internal structure according new tape file\n-    pub fn from_asset(mut asset: impl LoadableAsset) -> Result<Self> {\n-        use crate::utils::make_word;\n-\n-        let mut tap = Self::default();\n+impl<A: LoadableAsset> TapeImpl for Tap<A> {\n+    fn can_fast_load(&self) -> bool {\n+        self.state == TapeState::Stop\n+    }\n \n-        let mut buffer = [0u8; 1024];\n-        let mut read_bytes = asset.read(&mut buffer)?;\n-        while read_bytes != 0 {\n-            tap.data.extend_from_slice(&buffer[0..read_bytes]);\n-            read_bytes = asset.read(&mut buffer)?;\n+    fn next_block_byte(&mut self) -> Result<Option<u8>> {\n+        if self.tape_ended {\n+            return Ok(None);\n         }\n \n-        tap.block_info.clear();\n-        \/\/ get all blocks data\n-        let mut p = 0;\n-        'blocks: loop {\n-            \/\/ get length of the block\n-            let len = make_word(tap.data[p + 1], tap.data[p]) as usize;\n-            \/\/ push to vector of blocks\n-            tap.block_info.push(BlockInfo {\n-                length: len,\n-                pos: p + 2,\n-                end: p + 2 + len - 1,\n-            });\n-            \/\/ shift pos\n-            p += 2 + len;\n-            \/\/ check bounds\n-            if p >= tap.data.len() {\n-                break 'blocks;\n+        if let Some(block_size) = self.current_block_size {\n+            if self.block_bytes_read >= block_size {\n+                return Ok(None);\n             }\n-        }\n-        tap.reset_state();\n \n-        Ok(tap)\n-    }\n+            let mut buffer_read_pos = self.block_bytes_read - self.bufer_offset;\n \n-    \/\/\/ resets internal tape state\n-    fn reset_state(&mut self) {\n-        self.state = TapeState::Stop;\n-        self.curr_bit = false;\n-        self.curr_byte = 0x00;\n-        self.curr_mask = 0x80;\n-        self.block = 0;\n-        self.pos_in_block = 0;\n-        self.delay = Clocks(0);\n-        self.acc_clocks = Clocks(0);\n-    }\n-}\n+            \/\/ Read new buffer if required\n+            if buffer_read_pos >= BUFFER_SIZE {\n+                let bytes_to_read = (block_size - self.bufer_offset - BUFFER_SIZE).min(BUFFER_SIZE);\n+                self.asset.read_exact(&mut self.buffer[0..bytes_to_read])?;\n+                self.bufer_offset += BUFFER_SIZE;\n+                buffer_read_pos = 0;\n+            }\n \n-impl TapeImpl for Tap {\n-    \/\/\/ can autoload only if tape stopped\n-    fn can_fast_load(&self) -> bool {\n-        self.state == TapeState::Stop\n-    }\n+            \/\/ Check last byte in block\n+            if self.block_bytes_read >= block_size {\n+                self.current_block_size = None;\n+                self.block_bytes_read = 0;\n+                return Ok(None);\n+            }\n \n-    \/\/\/ returns byte of block\n-    fn block_byte(&self, offset: usize) -> Option<u8> {\n-        if self.block_info.is_empty() {\n-            return None;\n-        };\n-        let block = self.block_info[self.block];\n-        if offset < block.length {\n-            Some(self.data[block.pos + offset])\n-        } else {\n-            None\n+            \/\/ Perform actual read and advance position\n+            let result = self.buffer[buffer_read_pos];\n+            self.block_bytes_read += 1;\n+            return Ok(Some(result));\n         }\n+\n+        Ok(None)\n     }\n \n-    \/\/\/ switches tape player to next block\n-    fn next_block(&mut self) {\n-        self.block += 1;\n-        \/\/ make loop\n-        if self.block >= self.block_info.len() {\n-            self.block = 0;\n+    fn next_block(&mut self) -> Result<bool> {\n+        if self.tape_ended {\n+            return Ok(false);\n         }\n-        self.state = TapeState::Stop;\n-    }\n \n-    \/\/\/ resets position in block to 0\n-    fn reset_pos_in_block(&mut self) {\n-        self.pos_in_block = 0;\n+        \/\/ Skip leftovers from the previous block\n+        while self.next_block_byte()?.is_some() {}\n+\n+        let mut block_size_buffer = [0u8; 2];\n+        if self.asset.read_exact(&mut block_size_buffer).is_err() {\n+            self.tape_ended = true;\n+            return Ok(false);\n+        }\n+        let block_size = make_word(block_size_buffer[1], block_size_buffer[0]) as usize;\n+        let block_bytes_to_read = block_size.min(BUFFER_SIZE);\n+        self.asset\n+            .read_exact(&mut self.buffer[0..block_bytes_to_read])?;\n+\n+        self.bufer_offset = 0;\n+        self.block_bytes_read = 0;\n+        self.current_block_size = Some(block_size);\n+\n+        Ok(true)\n     }\n \n-    \/\/\/ returns current bit\n     fn current_bit(&self) -> bool {\n         self.curr_bit\n     }\n \n-    \/\/\/ makes internal state change based on clocks count\n-    fn process_clocks(&mut self, clocks: Clocks) {\n-        \/\/ if there are no blocks\n-        if self.block_info.is_empty() {\n-            return;\n-        }\n-        \/\/ get block info, check bunds\n-        let block = if self.block >= self.block_info.len() {\n-            self.block_info[0]\n-        } else {\n-            self.block_info[self.block]\n-        };\n-        \/\/ clocks\n-        let clocks = clocks.count();\n+    fn process_clocks(&mut self, clocks: Clocks) -> Result<()> {\n         if self.state == TapeState::Stop {\n-            return;\n+            return Ok(());\n         }\n-        \/\/ check delay\n+\n         if self.delay.count() > 0 {\n-            \/\/ accumulate clocks for delay\n-            self.acc_clocks += clocks;\n-            \/\/ if enough accumulated clocks then clear delay and drop some accumulated clocks\n-            if self.acc_clocks.count() >= self.delay.count() {\n-                self.acc_clocks -= self.delay;\n+            if clocks > self.delay {\n                 self.delay = Clocks(0);\n+            } else {\n+                self.delay -= clocks;\n             }\n-            \/\/ return anyway, it is delay!\n-            return;\n-        } else {\n-            \/\/ clear accumulated clocks\n-            self.acc_clocks = Clocks(0);\n+            return Ok(());\n         }\n-        \/\/ state machine. Wrapped into the loop for sequental non-clock-consuming state execution\n+\n         'state_machine: loop {\n             match self.state {\n-                \/\/ Stop state.\n                 TapeState::Stop => {\n-                    \/\/ Tape stopped, return HI bit, set current block pos to zero\n-                    self.curr_bit = false;\n-                    self.pos_in_block = 0;\n-                    \/\/ action maked, break state machine\n+                    \/\/ Reset tape but leave in Stopped state\n+                    self.rewind()?;\n+                    self.state = TapeState::Stop;\n                     break 'state_machine;\n                 }\n-                \/\/ Play state. Starts the tape\n                 TapeState::Play => {\n-                    \/\/ out of range play\n-                    if self.block >= self.block_info.len() {\n-                        \/\/ if play state happened when position is out of range,\n-                        \/\/ loop will be breaked on next iteration and next block will be with\n-                        \/\/ number zero\n-                        self.block = 0;\n+                    if !self.next_block()? {\n                         self.state = TapeState::Stop;\n                     } else {\n-                        \/\/ select appropriate pulse count for Pilot sequence\n-                        self.pulse_counter = if self.data[block.pos] < 128 {\n+                        let first_byte = self\n+                            .next_block_byte()?\n+                            .ok_or(TapeLoadError::InvalidTapFile)?;\n+\n+                        \/\/ Select appropriate pulse count for Pilot sequence\n+                        let pulses_left = if first_byte == 0x00 {\n                             PILOT_PULSES_HEADER\n                         } else {\n                             PILOT_PULSES_DATA\n                         };\n-                        \/\/ so, ok seems to be ok, we can make output bit low\n+                        self.curr_byte = first_byte;\n                         self.curr_bit = true;\n-                        \/\/ set delay before next state to one pilot pulse\n                         self.delay = Clocks(PILOT_LENGTH);\n-                        self.state = TapeState::Pilot;\n-                        \/\/ break state machine, delay must be emulated\n+                        self.state = TapeState::Pilot { pulses_left };\n                         break 'state_machine;\n                     }\n                 }\n-                \/\/ Pilot pulses\n-                TapeState::Pilot => {\n-                    \/\/ invert bit;\n+                TapeState::Pilot { mut pulses_left } => {\n                     self.curr_bit = !self.curr_bit;\n-                    \/\/ one pulse passed\n-                    self.pulse_counter -= 1;\n-                    if self.pulse_counter > 0 {\n-                        \/\/ add new delay and break\n-                        self.delay = Clocks(PILOT_LENGTH);\n-                    } else {\n-                        \/\/ change state to first sync\n-                        self.state = TapeState::Sync;\n+                    pulses_left -= 1;\n+                    if pulses_left == 0 {\n                         self.delay = Clocks(SYNC1_LENGTH);\n+                        self.state = TapeState::Sync;\n+                    } else {\n+                        self.delay = Clocks(PILOT_LENGTH);\n+                        self.state = TapeState::Pilot { pulses_left };\n                     }\n-                    \/\/ break anyway for delay\n                     break 'state_machine;\n                 }\n-                \/\/ sync pulse\n                 TapeState::Sync => {\n                     self.curr_bit = !self.curr_bit;\n                     self.delay = Clocks(SYNC2_LENGTH);\n-                    self.state = TapeState::NextByte;\n+                    self.state = TapeState::NextBit { mask: 0x80 };\n                     break 'state_machine;\n                 }\n-                \/\/ read next byte\n                 TapeState::NextByte => {\n-                    \/\/ read from most singificant bit\n-                    self.curr_mask = 0x80;\n-                    self.curr_byte = 0x00;\n-                    \/\/ break not needed, state doesn't require any time\n-                    self.state = TapeState::NextBit;\n+                    self.state = if let Some(byte) = self.next_block_byte()? {\n+                        self.curr_byte = byte;\n+                        TapeState::NextBit { mask: 0x80 }\n+                    } else {\n+                        TapeState::Pause\n+                    }\n                 }\n-                \/\/ next bit\n-                TapeState::NextBit => {\n-                    \/\/ invert bit\n+                TapeState::NextBit { mask } => {\n                     self.curr_bit = !self.curr_bit;\n-                    \/\/ depending on bit state select timing and switch to new state\n-                    if (self.data[block.pos + self.pos_in_block] & self.curr_mask) == 0 {\n+                    if (self.curr_byte & mask) == 0 {\n                         self.delay = Clocks(BIT_ZERO_LENGTH);\n-                        self.state = TapeState::BitHalf(BIT_ZERO_LENGTH);\n+                        self.state = TapeState::BitHalf {\n+                            half_bit_delay: BIT_ZERO_LENGTH,\n+                            mask,\n+                        };\n                     } else {\n                         self.delay = Clocks(BIT_ONE_LENGTH);\n-                        self.state = TapeState::BitHalf(BIT_ONE_LENGTH);\n-                        self.curr_byte |= self.curr_mask;\n+                        self.state = TapeState::BitHalf {\n+                            half_bit_delay: BIT_ONE_LENGTH,\n+                            mask,\n+                        };\n                     };\n                     break 'state_machine;\n                 }\n-                \/\/ half of a bit\n-                TapeState::BitHalf(pulse_length) => {\n-                    \/\/ invert bit\n+                TapeState::BitHalf {\n+                    half_bit_delay,\n+                    mut mask,\n+                } => {\n                     self.curr_bit = !self.curr_bit;\n-                    \/\/ set timeout same as before\n-                    self.delay = Clocks(pulse_length);\n-                    \/\/ shift right, to the next bit\n-                    self.curr_mask >>= 1;\n-                    if self.curr_mask == 0 {\n-                        self.pos_in_block += 1;\n-                        \/\/ check if we heve next byte in block\n-                        self.state = if self.pos_in_block < block.length {\n-                            TapeState::NextByte\n-                        } else {\n-                            TapeState::Pause\n-                        };\n+                    self.delay = Clocks(half_bit_delay);\n+                    mask >>= 1;\n+                    self.state = if mask == 0 {\n+                        TapeState::NextByte\n                     } else {\n-                        \/\/ fetch next bit\n-                        self.state = TapeState::NextBit;\n-                    }\n+                        TapeState::NextBit { mask }\n+                    };\n                     break 'state_machine;\n                 }\n-                \/\/ pause after block\n                 TapeState::Pause => {\n                     self.curr_bit = !self.curr_bit;\n-                    \/\/ make delay and go to another block. `Play` state can datermine\n-                    \/\/ the end of tape\n                     self.delay = Clocks(PAUSE_LENGTH);\n-                    self.block += 1;\n-                    self.pos_in_block = 0;\n+                    \/\/ Next block or end of the tape\n                     self.state = TapeState::Play;\n-                    \/\/ break directly for delay\n                     break 'state_machine;\n                 }\n             }\n         }\n+\n+        Ok(())\n     }\n \n-    \/\/\/ stops tape playback, sets `Stop` state\n     fn stop(&mut self) {\n         let state = self.state;\n         self.prev_state = state;\n         self.state = TapeState::Stop;\n     }\n \n-    \/\/\/ starts playback\n     fn play(&mut self) {\n         if self.state == TapeState::Stop {\n             if self.prev_state == TapeState::Stop {\n                 self.state = TapeState::Play;\n             } else {\n-                let prev_state = self.prev_state;\n-                self.state = prev_state;\n+                self.state = self.prev_state;\n             }\n         }\n     }\n \n-    \/\/\/ rewinds tape to start\n-    fn rewind(&mut self) {\n-        self.reset_state();\n+    fn rewind(&mut self) -> Result<()> {\n+        self.state = TapeState::Stop;\n+        self.curr_bit = false;\n+        self.curr_byte = 0x00;\n+        self.block_bytes_read = 0;\n+        self.bufer_offset = 0;\n+        self.current_block_size = None;\n+        self.delay = Clocks(0);\n+        self.asset.seek(SeekFrom::Start(0))?;\n+        self.tape_ended = false;\n+        Ok(())\n     }\n }\ndiff --git a\/rustzx-core\/src\/zx\/screen\/border.rs b\/rustzx-core\/src\/zx\/video\/border.rs\nsimilarity index 82%\nrename from rustzx-core\/src\/zx\/screen\/border.rs\nrename to rustzx-core\/src\/zx\/video\/border.rs\nindex 28828a1..94bc9d0 100644\n--- a\/rustzx-core\/src\/zx\/screen\/border.rs\n+++ b\/rustzx-core\/src\/zx\/video\/border.rs\n@@ -1,10 +1,15 @@\n \/\/! Contains ZXSpectrum border implementation\n-use super::colors::*;\n+use super::colors::{ZXBrightness, ZXColor};\n use crate::{\n+    host::{FrameBuffer, FrameBufferSource},\n     utils::Clocks,\n-    zx::{constants::*, machine::*},\n+    zx::{\n+        constants::{\n+            BORDER_COLS, BORDER_ROWS, CLOCKS_PER_COL, PIXELS_PER_CLOCK, SCREEN_HEIGHT, SCREEN_WIDTH,\n+        },\n+        machine::ZXMachine,\n+    },\n };\n-use alloc::boxed::Box;\n \n \/\/\/ Internal struct, which contains information about beam position and color\n #[derive(Clone, Copy)]\n@@ -37,21 +42,24 @@ impl BeamInfo {\n }\n \n \/\/\/ ZX Spectrum Border Device\n-pub struct ZXBorder {\n+pub struct ZXBorder<FB: FrameBuffer> {\n     machine: ZXMachine,\n-    palette: ZXPalette,\n-    buffer: Box<[u8; PIXEL_COUNT * BYTES_PER_PIXEL]>,\n+    buffer: FB,\n     beam_last: BeamInfo,\n     border_changed: bool,\n     beam_block: bool,\n }\n-impl ZXBorder {\n+impl<FB: FrameBuffer> ZXBorder<FB> {\n     \/\/\/ Returns new instance of border device\n-    pub fn new(machine: ZXMachine, palette: ZXPalette) -> ZXBorder {\n+    pub fn new(machine: ZXMachine, context: FB::Context) -> Self {\n         ZXBorder {\n             machine,\n-            palette,\n-            buffer: Box::new([0; PIXEL_COUNT * BYTES_PER_PIXEL]),\n+            buffer: FB::new(\n+                SCREEN_WIDTH,\n+                SCREEN_HEIGHT,\n+                FrameBufferSource::Border,\n+                context,\n+            ),\n             beam_last: BeamInfo::first_pixel(ZXColor::White),\n             border_changed: true,\n             beam_block: false,\n@@ -96,17 +104,13 @@ impl ZXBorder {\n     \/\/\/ fills pixels from last pos to passed by arguments with\n     fn fill_to(&mut self, line: usize, pixel: usize) {\n         let last = self.beam_last;\n-        let color_array = self.palette.get_rgba(last.color, ZXBrightness::Normal);\n-        \/\/ fill pixels\n         for p in (last.line * SCREEN_WIDTH + last.pixel)..(line * SCREEN_WIDTH + pixel) {\n-            for (b, color_value) in color_array\n-                .iter()\n-                .copied()\n-                .enumerate()\n-                .take(BYTES_PER_PIXEL)\n-            {\n-                self.buffer[p * BYTES_PER_PIXEL + b] = color_value;\n-            }\n+            self.buffer.set_color(\n+                p % SCREEN_WIDTH,\n+                p \/ SCREEN_WIDTH,\n+                last.color,\n+                ZXBrightness::Normal,\n+            );\n         }\n     }\n \n@@ -143,7 +147,7 @@ impl ZXBorder {\n     }\n \n     \/\/\/ Returns reference to texture\n-    pub fn texture(&self) -> &[u8] {\n-        &(*self.buffer)\n+    pub fn frame_buffer(&self) -> &FB {\n+        &self.buffer\n     }\n }\ndiff --git a\/rustzx-core\/src\/zx\/video\/colors.rs b\/rustzx-core\/src\/zx\/video\/colors.rs\nnew file mode 100644\nindex 0000000..2248852\n--- \/dev\/null\n+++ b\/rustzx-core\/src\/zx\/video\/colors.rs\n@@ -0,0 +1,76 @@\n+\/\/\/ Represents color brightness\n+#[derive(Clone, Copy)]\n+pub enum ZXBrightness {\n+    Normal,\n+    Bright,\n+}\n+\n+\/\/\/ ZX Spectrum color enum\n+\/\/\/ Constructs self from 3-bit value\n+#[derive(Clone, Copy)]\n+pub enum ZXColor {\n+    Black,\n+    Blue,\n+    Red,\n+    Purple,\n+    Green,\n+    Cyan,\n+    Yellow,\n+    White,\n+}\n+\n+impl ZXColor {\n+    \/\/\/ Returns ZXColor from 3 bits\n+    \/\/\/ # Panics\n+    \/\/\/ Panics when input color is bigger than 7\n+    pub fn from_bits(bits: u8) -> ZXColor {\n+        assert!(bits <= 7);\n+        match bits {\n+            0 => ZXColor::Black,\n+            1 => ZXColor::Blue,\n+            2 => ZXColor::Red,\n+            3 => ZXColor::Purple,\n+            4 => ZXColor::Green,\n+            5 => ZXColor::Cyan,\n+            6 => ZXColor::Yellow,\n+            7 => ZXColor::White,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+\/\/\/ ZX Spectrum attribute structure\n+\/\/\/ It contains information about ink, paper color,\n+\/\/\/ flash attribute and brightness\n+#[derive(Clone, Copy)]\n+pub(crate) struct ZXAttribute {\n+    pub ink: ZXColor,\n+    pub paper: ZXColor,\n+    pub brightness: ZXBrightness,\n+    pub flash: bool,\n+}\n+\n+impl ZXAttribute {\n+    \/\/\/ Constructs self from byte\n+    pub fn from_byte(data: u8) -> ZXAttribute {\n+        ZXAttribute {\n+            ink: ZXColor::from_bits(data & 0x07),\n+            paper: ZXColor::from_bits((data >> 3) & 0x07),\n+            flash: (data & 0x80) != 0,\n+            brightness: if (data & 0x40) != 0 {\n+                ZXBrightness::Bright\n+            } else {\n+                ZXBrightness::Normal\n+            },\n+        }\n+    }\n+\n+    \/\/\/ Returns active color of pixel in current attribute\n+    pub fn active_color(&self, state: bool, enable_flash: bool) -> ZXColor {\n+        if state ^ (self.flash && enable_flash) {\n+            self.ink\n+        } else {\n+            self.paper\n+        }\n+    }\n+}\ndiff --git a\/rustzx-core\/src\/zx\/screen\/mod.rs b\/rustzx-core\/src\/zx\/video\/mod.rs\nsimilarity index 55%\nrename from rustzx-core\/src\/zx\/screen\/mod.rs\nrename to rustzx-core\/src\/zx\/video\/mod.rs\nindex 9ed21ec..36a3026 100644\n--- a\/rustzx-core\/src\/zx\/screen\/mod.rs\n+++ b\/rustzx-core\/src\/zx\/video\/mod.rs\n@@ -1,5 +1,7 @@\n \/\/! Module contains all screen-rendering platform-independent\n \/\/! types and functions\n-pub mod border;\n-pub mod canvas;\n+#[cfg(feature = \"precise-border\")]\n+pub(crate) mod border;\n+pub(crate) mod screen;\n+\n pub mod colors;\ndiff --git a\/rustzx-core\/src\/zx\/screen\/canvas.rs b\/rustzx-core\/src\/zx\/video\/screen.rs\nsimilarity index 80%\nrename from rustzx-core\/src\/zx\/screen\/canvas.rs\nrename to rustzx-core\/src\/zx\/video\/screen.rs\nindex 75e976f..30081e0 100644\n--- a\/rustzx-core\/src\/zx\/screen\/canvas.rs\n+++ b\/rustzx-core\/src\/zx\/video\/screen.rs\n@@ -1,15 +1,23 @@\n \/\/! Module describes ZX Spectrum screen\n \/\/! *block* - is 8x1 pxels stripe.\n use crate::{\n-    utils::{screen::*, *},\n-    zx::{constants::*, machine::ZXMachine, screen::colors::*},\n+    host::{FrameBuffer, FrameBufferSource},\n+    utils::{\n+        screen::{attr_col_rel, attr_row_rel, bitmap_col_rel, bitmap_line_rel},\n+        Clocks,\n+    },\n+    zx::{\n+        constants::{\n+            ATTR_BASE_REL, ATTR_COLS, ATTR_MAX_REL, ATTR_ROWS, BITMAP_MAX_REL, CANVAS_HEIGHT,\n+            CANVAS_WIDTH, CLOCKS_PER_COL,\n+        },\n+        machine::ZXMachine,\n+        video::colors::ZXAttribute,\n+    },\n };\n use alloc::boxed::Box;\n \n-\/\/ size of screen buffer in bytes\n-const BUFFER_LENGTH: usize = CANVAS_HEIGHT * CANVAS_WIDTH * BYTES_PER_PIXEL;\n-\n-\/\/\/ Represents how much 8x1 have been **passed**.\n+\/\/\/ Represents how much 8x1 have been already **rendered**.\n #[derive(PartialEq, Eq, Debug)]\n pub struct BlocksCount {\n     pub lines: usize,\n@@ -76,32 +84,38 @@ struct ScreenBank {\n }\n \n \/\/\/ Represents ZXSpectrum emulated mid part of screen (canvas)\n-pub struct ZXCanvas {\n+pub struct ZXScreen<FB: FrameBuffer> {\n     machine: ZXMachine,\n-    palette: ZXPalette,\n     last_blocks: BlocksCount,\n     flash: bool,\n     frame_counter: usize,\n-    \/\/ bitmap buffers\n-    buffer: Box<[u8; BUFFER_LENGTH]>,\n-    back_buffer: Box<[u8; BUFFER_LENGTH]>,\n-    \/\/ memory\n+    buffer: FB,\n+    back_buffer: FB,\n     banks: [ScreenBank; 2],\n     active_bank: usize,\n     next_bank: usize,\n }\n \n-impl ZXCanvas {\n+impl<FB: FrameBuffer> ZXScreen<FB> {\n     \/\/\/ Constructs new canvas of `machine`\n-    pub fn new(machine: ZXMachine) -> ZXCanvas {\n-        ZXCanvas {\n+    pub fn new(machine: ZXMachine, context: FB::Context) -> Self {\n+        Self {\n             machine,\n-            palette: ZXPalette::default(),\n             last_blocks: BlocksCount::new(0, 0),\n             flash: false,\n             frame_counter: 0,\n-            buffer: Box::new([0; BUFFER_LENGTH]),\n-            back_buffer: Box::new([0; BUFFER_LENGTH]),\n+            buffer: FB::new(\n+                CANVAS_WIDTH,\n+                CANVAS_HEIGHT,\n+                FrameBufferSource::Screen,\n+                context.clone(),\n+            ),\n+            back_buffer: FB::new(\n+                CANVAS_WIDTH,\n+                CANVAS_HEIGHT,\n+                FrameBufferSource::Screen,\n+                context,\n+            ),\n             banks: [\n                 ScreenBank {\n                     attributes: Box::new([ZXAttribute::from_byte(0); ATTR_COLS * ATTR_ROWS]),\n@@ -161,11 +175,12 @@ impl ZXCanvas {\n                 for pixel in 0..8 {\n                     \/\/ from most significant bit\n                     let state = ((bitmap << pixel) & 0x80) != 0;\n-                    let color = self\n-                        .palette\n-                        .get_rgba(attr.active_color(state, self.flash), attr.brightness);\n-                    let index = (block * 8 + pixel) * BYTES_PER_PIXEL;\n-                    self.back_buffer[index..index + BYTES_PER_PIXEL].clone_from_slice(color);\n+                    self.back_buffer.set_color(\n+                        (block % ATTR_COLS) * 8 + pixel,\n+                        block \/ ATTR_COLS,\n+                        attr.active_color(state, self.flash),\n+                        attr.brightness,\n+                    );\n                 }\n             }\n             \/\/ cahnge last block to current\n@@ -176,7 +191,14 @@ impl ZXCanvas {\n     \/\/\/ starts new frame\n     pub fn new_frame(&mut self) {\n         \/\/ post finished bitmap to second buffer (all not-rendered part will be updated)\n-        self.buffer.clone_from_slice(&(*self.back_buffer));\n+        {\n+            let Self {\n+                buffer,\n+                back_buffer,\n+                ..\n+            } = self;\n+            core::mem::swap(buffer, back_buffer);\n+        }\n         self.last_blocks = BlocksCount::new(0, 0);\n         if self.frame_counter % 16 == 0 {\n             self.switch_flash();\n@@ -207,9 +229,7 @@ impl ZXCanvas {\n         }\n     }\n \n-    \/\/\/ Returns reference to canvas main texture\n-    pub fn texture(&self) -> &[u8] {\n-        \/\/ TODO(#51): Perform texture generation and color mapping on the host implementation side\n-        &(*self.buffer)\n+    pub fn frame_buffer(&self) -> &FB {\n+        &self.buffer\n     }\n }\ndiff --git a\/rustzx\/Cargo.toml b\/rustzx\/Cargo.toml\nindex 6986387..5ea006e 100644\n--- a\/rustzx\/Cargo.toml\n+++ b\/rustzx\/Cargo.toml\n@@ -1,9 +1,8 @@\n [package]\n name = \"rustzx\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n authors = [\"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n-publish = false\n-description = \"ZX Spectum emulator application\"\n+description = \"ZX Spectum emulator\"\n repository = \"https:\/\/github.com\/pacmancoder\/rustzx\"\n readme = \"..\/README.md\"\n keywords = [\"emulator\", \"game\", \"z80\"]\n@@ -14,8 +13,8 @@ edition = \"2018\"\n \n [dependencies]\n sdl2 = { version = \"0.34\", features = [\"unsafe_textures\", \"bundled\", \"static-link\"] }\n-rustzx-core = { path =  \"..\/rustzx-core\" }\n+rustzx-core = { path =  \"..\/rustzx-core\", features = [\"full\"] }\n log = \"0.4\"\n anyhow = \"1\"\n-clap = \"3.0.0-beta.2\"\n+structopt = \"0.3\"\n env_logger = \"0.8\"\ndiff --git a\/rustzx\/src\/app\/events\/events_sdl.rs b\/rustzx\/src\/app\/events\/events_sdl.rs\nindex fc1f261..84f4a2c 100644\n--- a\/rustzx\/src\/app\/events\/events_sdl.rs\n+++ b\/rustzx\/src\/app\/events\/events_sdl.rs\n@@ -2,8 +2,8 @@\n use super::{Event, EventDevice};\n use crate::{app::settings::Settings, backends::SDL_CONTEXT};\n use rustzx_core::{\n-    utils::EmulationSpeed,\n-    zx::{joy::kempston::KempstonKey, keys::*},\n+    zx::{joy::kempston::KempstonKey, keys::ZXKey},\n+    EmulationSpeed,\n };\n use sdl2::{event::Event as SdlEvent, keyboard::Scancode, EventPump};\n \n@@ -32,53 +32,53 @@ impl EventsSdl {\n     fn scancode_to_zxkey(&self, scancode: Option<Scancode>) -> Option<ZXKey> {\n         match scancode? {\n             \/\/ FEFE\n-            Scancode::LShift | Scancode::RShift => Some(ZX_KEY_SHIFT),\n-            Scancode::Z => Some(ZX_KEY_Z),\n-            Scancode::X => Some(ZX_KEY_X),\n-            Scancode::C => Some(ZX_KEY_C),\n-            Scancode::V => Some(ZX_KEY_V),\n+            Scancode::LShift | Scancode::RShift => Some(ZXKey::Shift),\n+            Scancode::Z => Some(ZXKey::Z),\n+            Scancode::X => Some(ZXKey::X),\n+            Scancode::C => Some(ZXKey::C),\n+            Scancode::V => Some(ZXKey::V),\n             \/\/ FDDE\n-            Scancode::A => Some(ZX_KEY_A),\n-            Scancode::S => Some(ZX_KEY_S),\n-            Scancode::D => Some(ZX_KEY_D),\n-            Scancode::F => Some(ZX_KEY_F),\n-            Scancode::G => Some(ZX_KEY_G),\n+            Scancode::A => Some(ZXKey::A),\n+            Scancode::S => Some(ZXKey::S),\n+            Scancode::D => Some(ZXKey::D),\n+            Scancode::F => Some(ZXKey::F),\n+            Scancode::G => Some(ZXKey::G),\n             \/\/ FBFE\n-            Scancode::Q => Some(ZX_KEY_Q),\n-            Scancode::W => Some(ZX_KEY_W),\n-            Scancode::E => Some(ZX_KEY_E),\n-            Scancode::R => Some(ZX_KEY_R),\n-            Scancode::T => Some(ZX_KEY_T),\n+            Scancode::Q => Some(ZXKey::Q),\n+            Scancode::W => Some(ZXKey::W),\n+            Scancode::E => Some(ZXKey::E),\n+            Scancode::R => Some(ZXKey::R),\n+            Scancode::T => Some(ZXKey::T),\n             \/\/ F7FE\n-            Scancode::Num1 => Some(ZX_KEY_1),\n-            Scancode::Num2 => Some(ZX_KEY_2),\n-            Scancode::Num3 => Some(ZX_KEY_3),\n-            Scancode::Num4 => Some(ZX_KEY_4),\n-            Scancode::Num5 => Some(ZX_KEY_5),\n+            Scancode::Num1 => Some(ZXKey::N1),\n+            Scancode::Num2 => Some(ZXKey::N2),\n+            Scancode::Num3 => Some(ZXKey::N3),\n+            Scancode::Num4 => Some(ZXKey::N4),\n+            Scancode::Num5 => Some(ZXKey::N5),\n             \/\/ EFFE\n-            Scancode::Num0 => Some(ZX_KEY_0),\n-            Scancode::Num9 => Some(ZX_KEY_9),\n-            Scancode::Num8 => Some(ZX_KEY_8),\n-            Scancode::Num7 => Some(ZX_KEY_7),\n-            Scancode::Num6 => Some(ZX_KEY_6),\n+            Scancode::Num0 => Some(ZXKey::N0),\n+            Scancode::Num9 => Some(ZXKey::N9),\n+            Scancode::Num8 => Some(ZXKey::N8),\n+            Scancode::Num7 => Some(ZXKey::N7),\n+            Scancode::Num6 => Some(ZXKey::N6),\n             \/\/ DFFE\n-            Scancode::P => Some(ZX_KEY_P),\n-            Scancode::O => Some(ZX_KEY_O),\n-            Scancode::I => Some(ZX_KEY_I),\n-            Scancode::U => Some(ZX_KEY_U),\n-            Scancode::Y => Some(ZX_KEY_Y),\n+            Scancode::P => Some(ZXKey::P),\n+            Scancode::O => Some(ZXKey::O),\n+            Scancode::I => Some(ZXKey::I),\n+            Scancode::U => Some(ZXKey::U),\n+            Scancode::Y => Some(ZXKey::Y),\n             \/\/ BFFE\n-            Scancode::Return => Some(ZX_KEY_ENTER),\n-            Scancode::L => Some(ZX_KEY_L),\n-            Scancode::K => Some(ZX_KEY_K),\n-            Scancode::J => Some(ZX_KEY_J),\n-            Scancode::H => Some(ZX_KEY_H),\n+            Scancode::Return => Some(ZXKey::Enter),\n+            Scancode::L => Some(ZXKey::L),\n+            Scancode::K => Some(ZXKey::K),\n+            Scancode::J => Some(ZXKey::J),\n+            Scancode::H => Some(ZXKey::H),\n             \/\/ 7FFE\n-            Scancode::Space => Some(ZX_KEY_SPACE),\n-            Scancode::LCtrl | Scancode::RCtrl => Some(ZX_KEY_SYM_SHIFT),\n-            Scancode::M => Some(ZX_KEY_M),\n-            Scancode::N => Some(ZX_KEY_N),\n-            Scancode::B => Some(ZX_KEY_B),\n+            Scancode::Space => Some(ZXKey::Space),\n+            Scancode::LCtrl | Scancode::RCtrl => Some(ZXKey::SymShift),\n+            Scancode::M => Some(ZXKey::M),\n+            Scancode::N => Some(ZXKey::N),\n+            Scancode::B => Some(ZXKey::B),\n             _ => None,\n         }\n     }\ndiff --git a\/rustzx\/src\/app\/events\/mod.rs b\/rustzx\/src\/app\/events\/mod.rs\nindex 9230527..75b1194 100644\n--- a\/rustzx\/src\/app\/events\/mod.rs\n+++ b\/rustzx\/src\/app\/events\/mod.rs\n@@ -3,8 +3,8 @@\n mod events_sdl;\n \n use rustzx_core::{\n-    utils::EmulationSpeed,\n-    zx::{joy::kempston::KempstonKey, keys::*},\n+    zx::{joy::kempston::KempstonKey, keys::ZXKey},\n+    EmulationSpeed,\n };\n use std::path::PathBuf;\n \ndiff --git a\/rustzx\/src\/app\/mod.rs b\/rustzx\/src\/app\/mod.rs\nindex 25f1095..48612e7 100644\n--- a\/rustzx\/src\/app\/mod.rs\n+++ b\/rustzx\/src\/app\/mod.rs\n@@ -3,7 +3,7 @@ mod events;\n mod rustzx;\n mod settings;\n mod sound;\n-mod video;\n+pub(crate) mod video;\n \n \/\/ main re-export\n pub use self::{rustzx::RustzxApp, settings::Settings};\ndiff --git a\/rustzx\/src\/app\/rustzx.rs b\/rustzx\/src\/app\/rustzx.rs\nindex cf05c3e..dadb2db 100644\n--- a\/rustzx\/src\/app\/rustzx.rs\n+++ b\/rustzx\/src\/app\/rustzx.rs\n@@ -3,12 +3,23 @@\n \/\/! and command-line interface\n \n use crate::{\n-    app::{events::*, settings::Settings, sound::*, video::*},\n-    host::{self, DetectedFileKind, GuiHost},\n+    app::{\n+        events::{Event, EventDevice, EventsSdl},\n+        settings::Settings,\n+        sound::{SoundDevice, SoundSdl},\n+        video::{Rect, TextureInfo, VideoDevice, VideoSdl},\n+    },\n+    host::{self, AppHost, AppHostContext, DetectedFileKind},\n };\n use anyhow::anyhow;\n-use rustzx_core::{emulator::*, zx::constants::*};\n+use rustzx_core::{\n+    zx::constants::{\n+        CANVAS_HEIGHT, CANVAS_WIDTH, CANVAS_X, CANVAS_Y, FPS, SCREEN_HEIGHT, SCREEN_WIDTH,\n+    },\n+    Emulator, Stopwatch,\n+};\n use std::{\n+    path::Path,\n     thread,\n     time::{Duration, Instant},\n };\n@@ -56,7 +67,7 @@ fn frame_length(fps: usize) -> Duration {\n \/\/\/ Application instance type\n pub struct RustzxApp {\n     \/\/\/ main emulator object\n-    emulator: Emulator<GuiHost>,\n+    emulator: Emulator<AppHost>,\n     \/\/\/ Sound rendering in a separate thread\n     snd: Option<Box<dyn SoundDevice>>,\n     video: Box<dyn VideoDevice>,\n@@ -69,7 +80,7 @@ pub struct RustzxApp {\n impl RustzxApp {\n     \/\/\/ Starts application itself\n     pub fn from_config(settings: Settings) -> anyhow::Result<RustzxApp> {\n-        let snd: Option<Box<dyn SoundDevice>> = if settings.sound_enabled {\n+        let snd: Option<Box<dyn SoundDevice>> = if !settings.disable_sound {\n             Some(Box::new(SoundSdl::new(&settings)))\n         } else {\n             None\n@@ -80,7 +91,7 @@ impl RustzxApp {\n         let scale = settings.scale as u32;\n         let events = Box::new(EventsSdl::new(&settings));\n \n-        let mut emulator = Emulator::new(settings.to_rustzx_settings())\n+        let mut emulator = Emulator::new(settings.to_rustzx_settings(), AppHostContext)\n             .map_err(|e| anyhow!(\"Failed to construct emulator: {}\", e))?;\n \n         if let Some(rom) = settings.rom.as_ref() {\n@@ -88,18 +99,18 @@ impl RustzxApp {\n                 .load_rom(host::load_rom(rom, settings.machine)?)\n                 .map_err(|e| anyhow!(\"Emulator failed to load rom: {}\", e))?;\n         }\n-        if let Some(snapshot) = settings.sna.as_ref() {\n+        if let Some(snapshot) = settings.snap.as_ref() {\n             emulator\n                 .load_snapshot(host::load_snapshot(snapshot)?)\n                 .map_err(|e| anyhow!(\"Emulator failed to load snapshot: {}\", e))?;\n         }\n-        if let Some(tape) = settings.tap.as_ref() {\n+        if let Some(tape) = settings.tape.as_ref() {\n             emulator\n                 .load_tape(host::load_tape(tape)?)\n                 .map_err(|e| anyhow!(\"Emulator failed to load tape: {}\", e))?;\n         }\n \n-        let app = RustzxApp {\n+        let mut app = RustzxApp {\n             emulator,\n             snd,\n             video,\n@@ -109,6 +120,10 @@ impl RustzxApp {\n             scale,\n         };\n \n+        if let Some(file) = settings.file_autodetect.as_ref() {\n+            app.load_file_autodetect(file)?;\n+        }\n+\n         Ok(app)\n     }\n \n@@ -121,7 +136,10 @@ impl RustzxApp {\n             \/\/ absolute start time\n             let frame_start = Instant::now();\n             \/\/ Emulate all requested frames\n-            let cpu_dt = self.emulator.emulate_frames(MAX_FRAME_TIME, &mut stopwatch);\n+            let cpu_dt = self\n+                .emulator\n+                .emulate_frames(MAX_FRAME_TIME, &mut stopwatch)\n+                .map_err(|e| anyhow!(\"Emulation step failed: {}\", e))?;\n             \/\/ if sound enabled sound ganeration allowed then move samples to sound thread\n             if let Some(ref mut snd) = self.snd {\n                 \/\/ if can be turned off even on speed change, so check it everytime\n@@ -131,12 +149,12 @@ impl RustzxApp {\n                     }\n                 }\n             }\n-            \/\/ load new textures to sdl\n+\n             self.video\n-                .update_texture(self.tex_border, self.emulator.controller.border.texture());\n+                .update_texture(self.tex_border, self.emulator.border_buffer().rgba_data());\n             self.video\n-                .update_texture(self.tex_canvas, self.emulator.controller.canvas.texture());\n-            \/\/ rendering block\n+                .update_texture(self.tex_canvas, self.emulator.screen_buffer().rgba_data());\n+\n             self.video.begin();\n             self.video.draw_texture_2d(\n                 self.tex_border,\n@@ -181,22 +199,7 @@ impl RustzxApp {\n                     }\n                     Event::InsertTape => self.emulator.play_tape(),\n                     Event::StopTape => self.emulator.stop_tape(),\n-                    Event::OpenFile(path) => match host::detect_file_type(&path)? {\n-                        DetectedFileKind::Snapshot => {\n-                            self.emulator\n-                                .load_snapshot(host::load_snapshot(&path)?)\n-                                .map_err(|e| {\n-                                    anyhow!(\"Emulator failed to drag-n-drop load snapshot: {}\", e)\n-                                })?;\n-                        }\n-                        DetectedFileKind::Tape => {\n-                            self.emulator\n-                                .load_tape(host::load_tape(&path)?)\n-                                .map_err(|e| {\n-                                    anyhow!(\"Emulator failed to drag-n-drop load tape: {}\", e)\n-                                })?;\n-                        }\n-                    },\n+                    Event::OpenFile(path) => self.load_file_autodetect(&path)?,\n                 }\n             }\n             \/\/ how long emulation iteration was\n@@ -219,4 +222,22 @@ impl RustzxApp {\n         }\n         Ok(())\n     }\n+\n+    fn load_file_autodetect(&mut self, path: &Path) -> anyhow::Result<()> {\n+        match host::detect_file_type(&path)? {\n+            DetectedFileKind::Snapshot => {\n+                self.emulator\n+                    .load_snapshot(host::load_snapshot(&path)?)\n+                    .map_err(|e| {\n+                        anyhow!(\"Emulator failed to load auto-detected snapshot: {}\", e)\n+                    })?;\n+            }\n+            DetectedFileKind::Tape => {\n+                self.emulator\n+                    .load_tape(host::load_tape(&path)?)\n+                    .map_err(|e| anyhow!(\"Emulator failed to load auto-detected tape: {}\", e))?;\n+            }\n+        }\n+        Ok(())\n+    }\n }\ndiff --git a\/rustzx\/src\/app\/settings.rs b\/rustzx\/src\/app\/settings.rs\nindex 398776a..a32cb2e 100644\n--- a\/rustzx\/src\/app\/settings.rs\n+++ b\/rustzx\/src\/app\/settings.rs\n@@ -1,346 +1,159 @@\n use rustzx_core::{\n-    settings::RustzxSettings,\n-    utils::EmulationSpeed,\n-    zx::{\n-        constants::{SCREEN_HEIGHT, SCREEN_WIDTH},\n-        machine::ZXMachine,\n-        sound::ay::ZXAYMode,\n-    },\n+    zx::{machine::ZXMachine, sound::ay::ZXAYMode},\n+    EmulationSpeed, RustzxSettings,\n };\n \n-use clap::{App, AppSettings, Arg};\n-use std::path::{Path, PathBuf};\n+use std::path::PathBuf;\n+\n+use structopt::StructOpt;\n \n \/\/\/ Structure to handle all emulator runtime settings\n+#[derive(StructOpt)]\n pub struct Settings {\n+    \/\/\/ Specify machine type for launch. Possible values:\n+    \/\/\/   [`48k`, `48`] - Sinclair ZX Spectrum 48K\n+    \/\/\/   [`128k`, `128`] - Sinclair ZX Spectrum 128K\n+    #[structopt(verbatim_doc_comment, short, long, default_value = \"48k\", parse(try_from_str = machine_from_str))]\n     pub machine: ZXMachine,\n+    \/\/\/ Set emulation speed at emualtor start-up. Can be specified as deciamal non-zero\n+    \/\/\/ value or as a special value `MAX` to run emulator as fast as possible\n+    #[structopt(long, default_value = \"1\", parse(try_from_str = emualtion_speed_from_str))]\n     pub speed: EmulationSpeed,\n-    pub fastload: bool,\n+    \/\/\/ Disable fast tape loading\n+    #[structopt(long = \"nofastload\")]\n+    pub disable_fastload: bool,\n+    \/\/\/ Set windows scale for emulator. Can be set as decimal non-zero value. Defaults to 2\n+    #[structopt(short, long, default_value = \"2\", parse(try_from_str = scale_from_str))]\n     pub scale: usize,\n-    pub screen_size: (usize, usize),\n-    pub kempston: bool,\n+    \/\/\/ Disable kempston joy support. In enabled, arrow and `Alt` keys are bound by default\n+    \/\/\/ to the kempston joy.\n+    #[structopt(long = \"nokempston\")]\n+    pub disable_kempston: bool,\n+    \/\/\/ Set AY-3-8910 sound chip mode. Can be set to `mono`, `abc`(stereo) or `acb`(stereo).\n+    \/\/\/ Defaults to `abc`\n+    #[structopt(long, default_value = \"abc\", parse(try_from_str = ay_mode_from_str))]\n+    \/\/\/ Disable AY-3-8910 chip support\n     pub ay_mode: ZXAYMode,\n-    pub ay_enabled: bool,\n-    pub beeper_enabled: bool,\n-    pub sound_enabled: bool,\n-    pub volume: usize,\n-    pub latency: usize,\n+    \/\/\/ Force enable AY-3-8910 chip on unsupported machines\n+    #[structopt(long = \"ay\", conflicts_with = \"force-disable-ay\")]\n+    pub force_enable_ay: bool,\n+    \/\/\/ Force disable AY-3-8910 chip on supported systems\n+    #[structopt(long = \"noay\", conflicts_with = \"force-enable-ay\")]\n+    pub force_disable_ay: bool,\n+    \/\/\/ Disable beeper\n+    #[structopt(long = \"nobeeper\")]\n+    pub disable_beeper: bool,\n+    \/\/\/ Disable sound\n+    #[structopt(long = \"nosound\")]\n+    pub disable_sound: bool,\n+    \/\/\/ Set custom sound latency. Defaults to 1024 samples\n+    #[structopt(long, default_value = \"1024\", parse(try_from_str = sound_latency_from_str))]\n+    pub sound_latency: usize,\n+    \/\/\/ Set custom sound sample rate. Defaults to 44100 samples per second\n+    #[structopt(long, default_value = \"44100\", parse(try_from_str = sound_sample_rate_from_str))]\n+    pub sound_sample_rate: usize,\n+\n+    \/\/\/ Set path to custom rom file. in case of multipart ROMs for 128k, the first part file,\n+    \/\/\/ extension of which should end with `.0`\n+    #[structopt(long, conflicts_with = \"file-autodetect\")]\n     pub rom: Option<PathBuf>,\n-    pub tap: Option<PathBuf>,\n-    pub sna: Option<PathBuf>,\n+    \/\/\/ Set tape file path. Only `.tap` files are supported currently\n+    #[structopt(long, conflicts_with = \"file-autodetect\")]\n+    pub tape: Option<PathBuf>,\n+    \/\/\/ Set snapshot file path. Only `.sna` files are supported currently\n+    #[structopt(long, conflicts_with = \"file-autodetect\")]\n+    pub snap: Option<PathBuf>,\n+\n+    \/\/\/ Load provided file to emulator. Emulator will perform autodetect of format if possible\n+    pub file_autodetect: Option<PathBuf>,\n }\n \n-impl Settings {\n-    \/\/\/ constructs new Settings\n-    pub fn new() -> Self {\n-        Self {\n-            machine: ZXMachine::Sinclair48K,\n-            speed: EmulationSpeed::Definite(1),\n-            fastload: false,\n-            scale: 2,\n-            screen_size: (SCREEN_WIDTH * 2, SCREEN_HEIGHT * 2),\n-            kempston: false,\n-            ay_mode: ZXAYMode::Mono,\n-            ay_enabled: false,\n-            beeper_enabled: true,\n-            sound_enabled: true,\n-            volume: 100,\n-            latency: 1024,\n-            rom: None,\n-            tap: None,\n-            sna: None,\n-        }\n-    }\n-\n-    pub fn from_clap() -> Self {\n-        \/\/ get defaults\n-        let mut out = Self::new();\n-        \/\/ parse cli\n-        let cmd = App::new(\"rustzx\")\n-            .setting(AppSettings::ColoredHelp)\n-            .version(env!(\"CARGO_PKG_VERSION\"))\n-            .author(\"Vladislav Nikonov <pacmancoder@gmail.com>\")\n-            .about(\"ZX Spectrum emulator written in pure Rust\")\n-            \/\/ machine settings\n-            .arg(\n-                Arg::new(\"128K\")\n-                    .long(\"128k\")\n-                    .about(\"Enables ZX Spectrum 128K mode\"),\n-            )\n-            .arg(\n-                Arg::new(\"FASTLOAD\")\n-                    .short('f')\n-                    .long(\"fastload\")\n-                    .about(\"Accelerates standard tape loaders\"),\n-            )\n-            \/\/ media files\n-            .arg(\n-                Arg::new(\"ROM\")\n-                    .long(\"rom\")\n-                    .value_name(\"ROM_PATH\")\n-                    .about(\"Selects path to rom, otherwise default will be used\"),\n-            )\n-            .arg(\n-                Arg::new(\"TAP\")\n-                    .long(\"tap\")\n-                    .value_name(\"TAP_PATH\")\n-                    .about(\"Selects path to *.tap file\"),\n-            )\n-            .arg(\n-                Arg::new(\"SNA\")\n-                    .long(\"sna\")\n-                    .value_name(\"SNA_PATH\")\n-                    .about(\"Selects path to *.sna snapshot file\"),\n-            )\n-            \/\/ devices\n-            .arg(Arg::new(\"KEMPSTON\").short('k').long(\"kempston\").about(\n-                \"Enables Kempston joystick. Controlls via arrow keys and \\\n-                 Alt buttons\",\n-            ))\n-            \/\/ emulator settings\n-            .arg(\n-                Arg::new(\"SPEED\")\n-                    .long(\"speed\")\n-                    .value_name(\"SPEED_VALUE\")\n-                    .about(\"Selects speed for emulator in integer multiplier form\"),\n-            )\n-            .arg(\n-                Arg::new(\"SCALE\")\n-                    .long(\"scale\")\n-                    .value_name(\"SCALE_VALUE\")\n-                    .about(\n-                        \"Selects default screen size. possible values are positive \\\n-                         integers. Default value is 2\",\n-                    ),\n-            )\n-            \/\/ sound\n-            .arg(Arg::new(\"NOSOUND\").long(\"nosound\").about(\n-                \"Disables sound. Use it when you have problems with audio \\\n-                 playback\",\n-            ))\n-            .arg(\n-                Arg::new(\"NOBEEPER\")\n-                    .long(\"nobeeper\")\n-                    .about(\"Disables beeper\"),\n-            )\n-            .arg(\n-                Arg::new(\"AY\")\n-                    .long(\"ay\")\n-                    .value_name(\"AY_TYPE\")\n-                    .possible_values(&[\"none\", \"mono\", \"abc\", \"acb\"])\n-                    .about(\n-                        \"Selects AY mode. Use none to disable. \\\n-                         For stereo features use abc or acb, default is mono for \\\n-                         128k and none for 48k.\",\n-                    ),\n-            )\n-            .arg(\n-                Arg::new(\"VOLUME\")\n-                    .long(\"volume\")\n-                    .value_name(\"VOLUME_VALUE\")\n-                    .about(\n-                        \"Selects volume - value in range 0..200. Volume over 100 \\\n-                         can cause sound artifacts\",\n-                    ),\n-            )\n-            .arg(\n-                Arg::new(\"LATENCY\")\n-                    .long(\"latency\")\n-                    .short('l')\n-                    .value_name(\"SAMPLES\")\n-                    .about(\n-                        \"Selects audio latency. Default is 1024 samples. Set higher \\\n-                         latency if emulator have sound glitches. Or if your \\\n-                         machine can handle this - try to set it lower. Must be \\\n-                         power of two.\",\n-                    ),\n-            )\n-            .get_matches();\n-        \/\/ machine type\n-        if cmd.is_present(\"128K\") {\n-            out.machine(ZXMachine::Sinclair128K);\n-        }\n-        if let Some(speed_str) = cmd.value_of(\"SPEED\") {\n-            if let Ok(speed) = speed_str.parse::<usize>() {\n-                out.speed(EmulationSpeed::Definite(speed));\n-            }\n-        };\n-        if let Some(scale_str) = cmd.value_of(\"SCALE\") {\n-            if let Ok(scale) = scale_str.parse::<usize>() {\n-                out.scale(scale);\n-            } else {\n-                println!(\"[Warning] Invalid scale factor\");\n-            };\n-        }\n-        out.fastload(cmd.is_present(\"FASTLOAD\"))\n-            .beeper(!cmd.is_present(\"NOBEEPER\"))\n-            .sound(!cmd.is_present(\"NOSOUND\"))\n-            .kempston(cmd.is_present(\"KEMPSTON\"));\n-        if let Some(path) = cmd.value_of_os(\"ROM\") {\n-            if Path::new(path).is_file() {\n-                out.rom(path);\n-            } else {\n-                println!(\n-                    \"[Warning] ROM file \\\"{}\\\" not found\",\n-                    path.to_string_lossy()\n-                );\n-            }\n-        }\n-        if let Some(path) = cmd.value_of_os(\"TAP\") {\n-            if Path::new(path).is_file() {\n-                out.tap(path);\n-            } else {\n-                println!(\n-                    \"[Warning] Tape file \\\"{}\\\" not found\",\n-                    path.to_string_lossy()\n-                );\n-            }\n-        }\n-        if let Some(path) = cmd.value_of_os(\"SNA\") {\n-            if out.machine == ZXMachine::Sinclair48K {\n-                if Path::new(path).is_file() {\n-                    out.sna(path);\n-                } else {\n-                    println!(\n-                        \"[Warning] Snapshot file \\\"{}\\\" not found\",\n-                        path.to_string_lossy()\n-                    );\n-                }\n-            } else {\n-                println!(\"[Warning] 128K SNA is not supported!\");\n-            }\n-        }\n-        if let Some(value) = cmd.value_of(\"AY\") {\n-            match value {\n-                \"none\" => out.ay(false),\n-                \"mono\" => out.ay_mode(ZXAYMode::Mono),\n-                \"abc\" => out.ay_mode(ZXAYMode::ABC),\n-                \"acb\" => out.ay_mode(ZXAYMode::ACB),\n-                _ => unreachable!(),\n-            };\n-        };\n-        if let Some(value) = cmd.value_of(\"VOLUME\") {\n-            if let Ok(value) = value.parse::<usize>() {\n-                out.volume(value);\n-            } else {\n-                println!(\"[Warning] Volume value is incorrect, setting volume to 100\");\n-            }\n-        };\n-        if let Some(latency_str) = cmd.value_of(\"LATENCY\") {\n-            if let Ok(latency) = latency_str.parse::<usize>() {\n-                out.latency(latency);\n-            }\n-        };\n-        out\n+fn machine_from_str(s: &str) -> Result<ZXMachine, anyhow::Error> {\n+    match s.to_lowercase().as_str() {\n+        \"48k\" | \"48\" => Ok(ZXMachine::Sinclair48K),\n+        \"128k\" | \"128\" => Ok(ZXMachine::Sinclair128K),\n+        s => Err(anyhow::anyhow!(\"Invalid machine type `{}`\", s)),\n     }\n+}\n \n-    \/\/\/ Changes machine type\n-    pub fn machine(&mut self, machine: ZXMachine) -> &mut Self {\n-        self.machine = machine;\n-        match machine {\n-            ZXMachine::Sinclair48K => self.ay_enabled = false,\n-            ZXMachine::Sinclair128K => self.ay_enabled = true,\n-        }\n-        self\n-    }\n+fn emualtion_speed_from_str(s: &str) -> Result<EmulationSpeed, anyhow::Error> {\n+    match s.to_lowercase().as_str() {\n+        \"max\" => Ok(EmulationSpeed::Max),\n+        s => {\n+            let speed: std::num::NonZeroUsize = s\n+                .parse()\n+                .map_err(|_| anyhow::anyhow!(\"Invalid emulation speed `{}`\", s))?;\n \n-    \/\/\/ changes screen scale\n-    pub fn scale(&mut self, scale: usize) -> &mut Self {\n-        \/\/ place into bounds\n-        if scale > 5 {\n-            self.scale = 2;\n-        } else {\n-            self.scale = scale;\n+            Ok(EmulationSpeed::Definite(speed.into()))\n         }\n-        self.screen_size = (SCREEN_WIDTH * self.scale, SCREEN_HEIGHT * self.scale);\n-        self\n-    }\n-\n-    \/\/\/ changes fastload flag\n-    pub fn fastload(&mut self, value: bool) -> &mut Self {\n-        self.fastload = value;\n-        self\n     }\n+}\n \n-    \/\/\/ changes lound latency\n-    pub fn latency(&mut self, latency: usize) -> &mut Self {\n-        self.latency = latency;\n-        self\n-    }\n+fn scale_from_str(s: &str) -> Result<usize, anyhow::Error> {\n+    let scale: std::num::NonZeroUsize = s\n+        .parse()\n+        .map_err(|_| anyhow::anyhow!(\"Invalid screen scale `{}`\", s))?;\n \n-    \/\/\/ Changes AY chip mode\n-    pub fn ay_mode(&mut self, mode: ZXAYMode) -> &mut Self {\n-        self.ay_enabled = true;\n-        self.ay_mode = mode;\n-        self\n-    }\n+    Ok(scale.into())\n+}\n \n-    \/\/\/ Changes ay state (on\/off)\n-    pub fn ay(&mut self, state: bool) -> &mut Self {\n-        self.ay_enabled = state;\n-        self\n+fn ay_mode_from_str(s: &str) -> Result<ZXAYMode, anyhow::Error> {\n+    match s.to_lowercase().as_str() {\n+        \"mono\" => Ok(ZXAYMode::Mono),\n+        \"abc\" => Ok(ZXAYMode::ABC),\n+        \"acb\" => Ok(ZXAYMode::ACB),\n+        s => Err(anyhow::anyhow!(\"Invalid AY chip mode `{}`\", s)),\n     }\n+}\n \n-    \/\/\/ Changes beeper state (on\/off)\n-    pub fn beeper(&mut self, state: bool) -> &mut Self {\n-        self.beeper_enabled = state;\n-        self\n-    }\n+fn sound_latency_from_str(s: &str) -> Result<usize, anyhow::Error> {\n+    let latency = s\n+        .parse::<usize>()\n+        .map_err(|_| anyhow::anyhow!(\"Invalid sound latency `{}`\", s))?;\n \n-    \/\/\/ changes sound flag\n-    pub fn sound(&mut self, state: bool) -> &mut Self {\n-        self.sound_enabled = state;\n-        self\n+    if latency < 64 {\n+        anyhow::bail!(\"Setting sound latency lower than 64 is bad for your health\");\n     }\n-\n-    \/\/\/ Changes volume\n-    pub fn volume(&mut self, val: usize) -> &mut Self {\n-        self.volume = if val > 200 { 200 } else { val };\n-        self\n+    if latency > 1024 * 64 {\n+        anyhow::bail!(\"This sound latency is HUGE. Please don't try this at home!\");\n     }\n \n-    \/\/\/ cahnges kempston joy connection\n-    pub fn kempston(&mut self, value: bool) -> &mut Self {\n-        self.kempston = value;\n-        self\n-    }\n+    Ok(latency)\n+}\n \n-    \/\/\/ changes TAP path\n-    pub fn tap(&mut self, value: impl AsRef<Path>) -> &mut Self {\n-        self.tap = Some(value.as_ref().into());\n-        self\n-    }\n+fn sound_sample_rate_from_str(s: &str) -> Result<usize, anyhow::Error> {\n+    let sample_rate = s\n+        .parse::<usize>()\n+        .map_err(|_| anyhow::anyhow!(\"Invalid sound sample rate {}\", s))?;\n \n-    \/\/\/ changes SNA path\n-    pub fn sna(&mut self, value: impl AsRef<Path>) -> &mut Self {\n-        self.sna = Some(value.as_ref().into());\n-        self\n+    \/\/ Sample rate range derived from https:\/\/github.com\/audiojs\/sample-rate\n+    if sample_rate < 8000 {\n+        anyhow::bail!(\"Provided sound sample rate `{}` is too low\", sample_rate);\n     }\n-\n-    \/\/\/ changes ROM path\n-    pub fn rom(&mut self, value: impl AsRef<Path>) -> &mut Self {\n-        self.rom = Some(value.as_ref().into());\n-        self\n+    if sample_rate > 384000 {\n+        anyhow::bail!(\"Provided sound sample rate `{}` is too high\", sample_rate);\n     }\n \n-    \/\/\/ changes emulation speed\n-    pub fn speed(&mut self, value: EmulationSpeed) -> &mut Self {\n-        self.speed = value;\n-        self\n-    }\n+    Ok(sample_rate)\n+}\n \n+impl Settings {\n     pub fn to_rustzx_settings(&self) -> RustzxSettings {\n+        let ay_enabled = (matches!(self.machine, ZXMachine::Sinclair128K) || self.force_enable_ay)\n+            && (!self.force_disable_ay);\n+\n         RustzxSettings {\n             machine: self.machine,\n             emulation_speed: self.speed,\n-            tape_fastload: self.fastload,\n-            enable_kempston: self.kempston,\n+            tape_fastload: !self.disable_fastload,\n+            enable_kempston: !self.disable_kempston,\n             ay_mode: self.ay_mode,\n-            ay_enabled: self.ay_enabled,\n-            beeper_enabled: self.beeper_enabled,\n-            sound_enabled: self.sound_enabled,\n-            sound_volume: self.volume as u8,\n+            ay_enabled,\n+            beeper_enabled: !self.disable_beeper,\n+            sound_enabled: !self.disable_sound,\n+            sound_volume: 100,\n             load_default_rom: self.rom.is_none(),\n+            sound_sample_rate: self.sound_sample_rate,\n         }\n     }\n }\ndiff --git a\/rustzx\/src\/app\/sound\/sound_sdl.rs b\/rustzx\/src\/app\/sound\/sound_sdl.rs\nindex 6f028c6..a7a6117 100644\n--- a\/rustzx\/src\/app\/sound\/sound_sdl.rs\n+++ b\/rustzx\/src\/app\/sound\/sound_sdl.rs\n@@ -1,10 +1,11 @@\n \/\/! Real Audio SDL backend\n use super::{SoundDevice, ZXSample};\n use crate::{app::settings::Settings, backends::SDL_CONTEXT};\n-use rustzx_core::zx::sound::{CHANNELS, SAMPLE_RATE};\n use sdl2::audio::{AudioCallback, AudioDevice, AudioSpecDesired};\n use std::sync::mpsc::{sync_channel, Receiver, SyncSender};\n \n+const CHANNEL_COUNT: usize = 2;\n+\n \/\/\/ Struct which used in SDL audio callback\n struct SdlCallback {\n     samples: Receiver<ZXSample>,\n@@ -15,7 +16,7 @@ impl AudioCallback for SdlCallback {\n \n     \/\/\/ main callback function\n     fn callback(&mut self, out: &mut [f32]) {\n-        for chunk in out.chunks_mut(CHANNELS) {\n+        for chunk in out.chunks_mut(CHANNEL_COUNT) {\n             \/\/ recieve samples from channel\n             if let Ok(sample) = self.samples.recv() {\n                 chunk[0] = sample.left;\n@@ -42,11 +43,11 @@ impl SoundSdl {\n         if let Some(audio) = audio_subsystem {\n             \/\/ prepare specs\n             let desired_spec = AudioSpecDesired {\n-                freq: Some(SAMPLE_RATE as i32),\n-                channels: Some(CHANNELS as u8),\n-                samples: Some(settings.latency as u16),\n+                freq: Some(settings.sound_sample_rate as i32),\n+                channels: Some(CHANNEL_COUNT as u8),\n+                samples: Some(settings.sound_latency as u16),\n             };\n-            let (tx, rx) = sync_channel(settings.latency as usize);\n+            let (tx, rx) = sync_channel(settings.sound_latency as usize);\n             let device_handle = audio\n                 .open_playback(None, &desired_spec, |_| SdlCallback { samples: rx })\n                 .expect(\"[ERROR Sdl audio device error, try --nosound]\");\ndiff --git a\/rustzx\/src\/app\/video\/mod.rs b\/rustzx\/src\/app\/video\/mod.rs\nindex b976ecb..81acc48 100644\n--- a\/rustzx\/src\/app\/video\/mod.rs\n+++ b\/rustzx\/src\/app\/video\/mod.rs\n@@ -1,7 +1,9 @@\n \/\/! platform-independent traits. Submodules with backends will be selectable\n \/\/! via cargo features in future\n+mod palette;\n mod video_sdl;\n \n+pub use palette::Palette;\n pub use video_sdl::VideoSdl;\n \n \/\/\/ Texture id binging\ndiff --git a\/rustzx\/src\/app\/video\/palette.rs b\/rustzx\/src\/app\/video\/palette.rs\nnew file mode 100644\nindex 0000000..d2768a5\n--- \/dev\/null\n+++ b\/rustzx\/src\/app\/video\/palette.rs\n@@ -0,0 +1,65 @@\n+use rustzx_core::zx::video::colors::{ZXBrightness, ZXColor};\n+\n+type ColorRgba = [u8; 4];\n+\n+\/\/\/ represents set of colors\n+struct ColorSet {\n+    black: ColorRgba,\n+    blue: ColorRgba,\n+    red: ColorRgba,\n+    purple: ColorRgba,\n+    green: ColorRgba,\n+    cyan: ColorRgba,\n+    yellow: ColorRgba,\n+    white: ColorRgba,\n+}\n+pub struct Palette {\n+    bright: ColorSet,\n+    normal: ColorSet,\n+}\n+\n+impl Default for Palette {\n+    fn default() -> Self {\n+        Palette {\n+            normal: ColorSet {\n+                black: 0x000000FF_u32.to_be_bytes(),\n+                blue: 0x0000CDFF_u32.to_be_bytes(),\n+                red: 0xCD0000FF_u32.to_be_bytes(),\n+                purple: 0xCD00CDFF_u32.to_be_bytes(),\n+                green: 0x00CD00FF_u32.to_be_bytes(),\n+                cyan: 0x00CDCDFF_u32.to_be_bytes(),\n+                yellow: 0xCDCD00FF_u32.to_be_bytes(),\n+                white: 0xCDCDCDFF_u32.to_be_bytes(),\n+            },\n+            bright: ColorSet {\n+                black: 0x000000FF_u32.to_be_bytes(),\n+                blue: 0x0000FFFF_u32.to_be_bytes(),\n+                red: 0xFF0000FF_u32.to_be_bytes(),\n+                purple: 0xFF00FFFF_u32.to_be_bytes(),\n+                green: 0x00FF00FF_u32.to_be_bytes(),\n+                cyan: 0x00FFFFFF_u32.to_be_bytes(),\n+                yellow: 0xFFFF00FF_u32.to_be_bytes(),\n+                white: 0xFFFFFFFF_u32.to_be_bytes(),\n+            },\n+        }\n+    }\n+}\n+\n+impl Palette {\n+    pub fn get_rgba(&self, color: ZXColor, brightness: ZXBrightness) -> ColorRgba {\n+        let set = match brightness {\n+            ZXBrightness::Normal => &self.normal,\n+            ZXBrightness::Bright => &self.bright,\n+        };\n+        match color {\n+            ZXColor::Black => set.black,\n+            ZXColor::Blue => set.blue,\n+            ZXColor::Red => set.red,\n+            ZXColor::Purple => set.purple,\n+            ZXColor::Green => set.green,\n+            ZXColor::Cyan => set.cyan,\n+            ZXColor::Yellow => set.yellow,\n+            ZXColor::White => set.white,\n+        }\n+    }\n+}\ndiff --git a\/rustzx\/src\/app\/video\/video_sdl.rs b\/rustzx\/src\/app\/video\/video_sdl.rs\nindex b71166e..d421f01 100644\n--- a\/rustzx\/src\/app\/video\/video_sdl.rs\n+++ b\/rustzx\/src\/app\/video\/video_sdl.rs\n@@ -1,5 +1,6 @@\n use super::{Rect, TextureInfo, VideoDevice};\n use crate::{app::settings::Settings, backends::SDL_CONTEXT};\n+use rustzx_core::zx::constants::{SCREEN_HEIGHT, SCREEN_WIDTH};\n use sdl2::{\n     pixels::PixelFormatEnum as PixelFormat,\n     rect::Rect as SdlRect,\n@@ -26,7 +27,10 @@ impl VideoSdl {\n         });\n         if let Some(video) = video_subsystem {\n             \/\/ construct window and renderer form it\n-            let (width, height) = settings.screen_size;\n+            let (width, height) = (\n+                SCREEN_WIDTH * settings.scale,\n+                SCREEN_HEIGHT * settings.scale,\n+            );\n             let window = video\n                 .window(\n                     &format!(\"RustZX v{}\", env!(\"CARGO_PKG_VERSION\")),\ndiff --git a\/rustzx\/src\/host\/frame_buffer.rs b\/rustzx\/src\/host\/frame_buffer.rs\nnew file mode 100644\nindex 0000000..0c1136e\n--- \/dev\/null\n+++ b\/rustzx\/src\/host\/frame_buffer.rs\n@@ -0,0 +1,50 @@\n+use crate::app::video::Palette;\n+use rustzx_core::{\n+    host::{FrameBuffer, FrameBufferSource},\n+    zx::video::colors::{ZXBrightness, ZXColor},\n+};\n+\n+const RGBA_PIXEL_SIZE: usize = 4;\n+\n+#[derive(Clone)]\n+pub struct FrameBufferContext;\n+\n+pub struct RgbaFrameBuffer {\n+    buffer: Vec<u8>,\n+    palette: Palette,\n+    buffer_row_size: usize,\n+}\n+\n+impl FrameBuffer for RgbaFrameBuffer {\n+    type Context = FrameBufferContext;\n+\n+    fn new(\n+        width: usize,\n+        height: usize,\n+        _source: FrameBufferSource,\n+        _context: Self::Context,\n+    ) -> Self {\n+        Self {\n+            buffer: vec![0u8; width * height * RGBA_PIXEL_SIZE],\n+            palette: Palette::default(),\n+            buffer_row_size: width * RGBA_PIXEL_SIZE,\n+        }\n+    }\n+\n+    fn set_color(&mut self, x: usize, y: usize, color: ZXColor, brightness: ZXBrightness) {\n+        let buffer_pos = y * self.buffer_row_size + x * RGBA_PIXEL_SIZE;\n+\n+        self.palette\n+            .get_rgba(color, brightness)\n+            .iter()\n+            .copied()\n+            .zip(&mut self.buffer[buffer_pos..buffer_pos + RGBA_PIXEL_SIZE])\n+            .for_each(|(source, dest)| *dest = source);\n+    }\n+}\n+\n+impl RgbaFrameBuffer {\n+    pub fn rgba_data(&self) -> &[u8] {\n+        &self.buffer\n+    }\n+}\ndiff --git a\/rustzx\/src\/host\/mod.rs b\/rustzx\/src\/host\/mod.rs\nindex 4f77144..190a571 100644\n--- a\/rustzx\/src\/host\/mod.rs\n+++ b\/rustzx\/src\/host\/mod.rs\n@@ -1,24 +1,36 @@\n+mod frame_buffer;\n mod io;\n \n use anyhow::{anyhow, bail, Context};\n+use frame_buffer::{FrameBufferContext, RgbaFrameBuffer};\n use io::FileAsset;\n use rustzx_core::{\n-    host::{Host, RomFormat, RomSet, Snapshot, Tape},\n-    zx::ZXMachine,\n+    host::{FrameBuffer, Host, HostContext, RomFormat, RomSet, Snapshot, Tape},\n+    zx::machine::ZXMachine,\n };\n use std::{collections::VecDeque, fs::File, path::Path};\n \n const SUPPORTED_SNAPSHOT_FORMATS: [&str; 1] = [\"sna\"];\n const SUPPORTED_TAPE_FORMATS: [&str; 1] = [\"tap\"];\n \n-pub struct GuiHost;\n+pub struct AppHost;\n \n-impl Host for GuiHost {\n+impl Host for AppHost {\n+    type Context = AppHostContext;\n+    type FrameBuffer = RgbaFrameBuffer;\n     type RomSet = FileRomSet;\n     type SnapshotAsset = FileAsset;\n     type TapeAsset = FileAsset;\n }\n \n+pub struct AppHostContext;\n+\n+impl HostContext<AppHost> for AppHostContext {\n+    fn frame_buffer_context(&self) -> <<AppHost as Host>::FrameBuffer as FrameBuffer>::Context {\n+        FrameBufferContext\n+    }\n+}\n+\n pub struct FileRomSet {\n     pages: VecDeque<FileAsset>,\n }\ndiff --git a\/rustzx\/src\/main.rs b\/rustzx\/src\/main.rs\nindex d899b36..45d98da 100644\n--- a\/rustzx\/src\/main.rs\n+++ b\/rustzx\/src\/main.rs\n@@ -5,11 +5,12 @@ mod backends;\n mod host;\n \n use app::{RustzxApp, Settings};\n+use structopt::StructOpt;\n \n fn main() {\n     env_logger::init();\n \n-    let settings = Settings::from_clap();\n+    let settings = Settings::from_args();\n     let result = RustzxApp::from_config(settings)\n         .and_then(|mut emulator| emulator.start())\n         .map_err(|e| log::error!(\"ERROR: {}\", e));\n","test_patch":"","problem_statement":"Eliminate loading a whole file to vector in tap loader\nCurrently we already have file-like `libcore`-friendly abstraction over currently loading tap asset but still perform read to `Vec` instead of `seek` + `read` on demand; This will allow to port `rustzx-core` to more resource-restricted hosts.\n","hints_text":"","created_at":1620,"merge_commit_sha":"a59601712747336126bf31434aac664e85019477","ci_name_list":[]}
{"repo":"linebender\/resvg","pull_number":586,"instance_id":"linebender__resvg-586","issue_numbers":["581"],"base_commit":"00005084c2544179a7e094d4efa979df1ec04e1b","patch":"diff --git a\/usvg-text-layout\/src\/lib.rs b\/usvg-text-layout\/src\/lib.rs\nindex 602002aee..7482bbedf 100644\n--- a\/usvg-text-layout\/src\/lib.rs\n+++ b\/usvg-text-layout\/src\/lib.rs\n@@ -805,7 +805,13 @@ fn convert_decoration(\n \n     let mut path = PathData::new();\n     for dec_span in decoration_spans {\n-        let rect = Rect::new(0.0, -thickness \/ 2.0, dec_span.width, thickness).unwrap();\n+        let rect = match Rect::new(0.0, -thickness \/ 2.0, dec_span.width, thickness) {\n+            Some(v) => v,\n+            None => {\n+                log::warn!(\"a decoration span has a malformed bbox\");\n+                continue;\n+            }\n+        };\n \n         let start_idx = path.len();\n         path.push_rect(rect);\n@@ -1843,7 +1849,12 @@ fn apply_length_adjust(chunk: &TextChunk, clusters: &mut [OutlinedCluster]) {\n         }\n \n         if span.length_adjust == LengthAdjust::Spacing {\n-            let factor = (target_width - width) \/ (cluster_indexes.len() - 1) as f64;\n+            let factor = if cluster_indexes.len() > 1 {\n+                (target_width - width) \/ (cluster_indexes.len() - 1) as f64\n+            }   else {\n+                0 as f64\n+            };\n+\n             for i in cluster_indexes {\n                 clusters[i].advance = clusters[i].width + factor;\n             }\ndiff --git a\/usvg\/src\/geom.rs b\/usvg\/src\/geom.rs\nindex b6c0bf900..31c6a2ca5 100644\n--- a\/usvg\/src\/geom.rs\n+++ b\/usvg\/src\/geom.rs\n@@ -78,7 +78,7 @@ pub trait IsValidLength {\n impl IsValidLength for f64 {\n     #[inline]\n     fn is_valid_length(&self) -> bool {\n-        *self > 0.0\n+        *self > 0.0 && self.is_finite()\n     }\n }\n \n","test_patch":"diff --git a\/tests\/integration\/render.rs b\/tests\/integration\/render.rs\nindex 45d37e3e1..9572eb69f 100644\n--- a\/tests\/integration\/render.rs\n+++ b\/tests\/integration\/render.rs\n@@ -482,6 +482,7 @@ use crate::render;\n #[test] fn a_text_decoration_017() { assert_eq!(render(\"a-text-decoration-017\"), 0); }\n #[test] fn a_text_decoration_018() { assert_eq!(render(\"a-text-decoration-018\"), 0); }\n #[test] fn a_text_decoration_019() { assert_eq!(render(\"a-text-decoration-019\"), 0); }\n+#[test] fn a_text_decoration_020() { assert_eq!(render(\"a-text-decoration-020\"), 0); }\n #[test] fn a_text_rendering_001() { assert_eq!(render(\"a-text-rendering-001\"), 0); }\n #[test] fn a_text_rendering_002() { assert_eq!(render(\"a-text-rendering-002\"), 0); }\n #[test] fn a_text_rendering_003() { assert_eq!(render(\"a-text-rendering-003\"), 0); }\ndiff --git a\/tests\/png\/a-text-decoration-020.png b\/tests\/png\/a-text-decoration-020.png\nnew file mode 100644\nindex 000000000..f71338765\nBinary files \/dev\/null and b\/tests\/png\/a-text-decoration-020.png differ\ndiff --git a\/tests\/svg\/a-text-decoration-020.svg b\/tests\/svg\/a-text-decoration-020.svg\nnew file mode 100644\nindex 000000000..d63f452fc\n--- \/dev\/null\n+++ b\/tests\/svg\/a-text-decoration-020.svg\n@@ -0,0 +1,10 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+     font-family=\"Noto Sans\" font-size=\"48\">\n+    <title>Text with text decoration and only one chunk<\/title>\n+\n+    <text id=\"text1\" fill=\"#33FF02\" font-family=\"sans-serif\" font-size=\"14\" font-weight=\"bold\" lengthAdjust=\"spacing\"\n+          text-decoration=\"underline\" textLength=\"8\" x=\"5\" y=\"20\">+\n+    <\/text>\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\n\\ No newline at end of file\n","problem_statement":"panic with SVG generated by PlantUML\nExample SVG:\r\nhttps:\/\/www.plantuml.com\/plantuml\/svg\/SoWkIImgAStDuU9ApaaiBbPmoy_dujBcud98pKi12WC0\r\n\r\ncall stack:\r\n```txt\r\n# Child-SP          RetAddr               Call Site\r\n00 00000042`c8ef9db0 00007ffd`c8846720     KERNELBASE!RaiseException+0x69\r\n01 00000042`c8ef9e90 00007ff7`cdf63f48     VCRUNTIME140!_CxxThrowException(void * pExceptionObject = 0x00000042`c8ef9f10, struct _s__ThrowInfo * pThrowInfo = <Value unavailable error>)+0x90 [D:\\a\\_work\\1\\s\\src\\vctools\\crt\\vcruntime\\src\\eh\\throw.cpp @ 75] \r\n02 (Inline Function) --------`--------     Yiili!panic_unwind::real_imp::panic(void)+0x77 [\/rustc\/d5a82bbd26e1ad8b7401f6a718a9c57c96905483\/library\\panic_unwind\\src\\seh.rs @ 322] \r\n03 00000042`c8ef9ef0 00007ff7`cdebcfcb     Yiili!panic_unwind::__rust_start_panic(void)+0x88 [\/rustc\/d5a82bbd26e1ad8b7401f6a718a9c57c96905483\/library\\panic_unwind\\src\\lib.rs @ 103] \r\n04 00000042`c8ef9f30 00007ff7`cdebcca7     Yiili!std::panicking::rust_panic(void)+0x1b [\/rustc\/d5a82bbd26e1ad8b7401f6a718a9c57c96905483\/library\\std\\src\\panicking.rs @ 736] \r\n05 00000042`c8efa000 00007ff7`cdebc95b     Yiili!std::panicking::rust_panic_with_hook(void)+0x297 [\/rustc\/d5a82bbd26e1ad8b7401f6a718a9c57c96905483\/library\\std\\src\\panicking.rs @ 706] \r\n06 00000042`c8efa0f0 00007ff7`cdeb8def     Yiili!std::panicking::begin_panic_handler::closure$0(void)+0x8b [\/rustc\/d5a82bbd26e1ad8b7401f6a718a9c57c96905483\/library\\std\\src\\panicking.rs @ 577] \r\n07 00000042`c8efa170 00007ff7`cdebc5b0     Yiili!std::sys_common::backtrace::__rust_end_short_backtrace<std::panicking::begin_panic_handler::closure_env$0,never$>(void)+0x1f [\/rustc\/d5a82bbd26e1ad8b7401f6a718a9c57c96905483\/library\\std\\src\\sys_common\\backtrace.rs @ 137] \r\n08 00000042`c8efa1b0 00007ff7`ce339e35     Yiili!std::panicking::begin_panic_handler(void)+0x70 [\/rustc\/d5a82bbd26e1ad8b7401f6a718a9c57c96905483\/library\\std\\src\\panicking.rs @ 575] \r\n09 00000042`c8efa200 00007ff7`ce339f5c     Yiili!core::panicking::panic_fmt(void)+0x35 [\/rustc\/d5a82bbd26e1ad8b7401f6a718a9c57c96905483\/library\\core\\src\\panicking.rs @ 64] \r\n0a 00000042`c8efa250 00007ff7`cdfa43b8     Yiili!core::panicking::panic(void)+0x4c [\/rustc\/d5a82bbd26e1ad8b7401f6a718a9c57c96905483\/library\\core\\src\\panicking.rs @ 111] \r\n0b 00000042`c8efa2c0 00007ff7`cdf9b5de     Yiili!ZN16usvg_text_layout13text_to_paths17h416cba2b0444cc32E+0xe1b8\r\n0c 00000042`c8efa550 00007ff7`cdf92ae5     Yiili!ZN16usvg_text_layout13text_to_paths17h416cba2b0444cc32E+0x53de\r\n0d 00000042`c8eface0 00007ff7`cdf95440     Yiili!ZN65_$LT$usvg..text..Text$u20$as$u20$usvg_text_layout..TextToPath$GT$7convert17hb74169065f07d82dE+0x75\r\n0e 00000042`c8efb140 00007ff7`cde39ed4     Yiili!ZN16usvg_text_layout12convert_text17h3d42be6e397c8a03E+0x4b0\r\n0f 00000042`c8efb270 00007ff7`ce250a6b     Yiili!resvg_parse_tree_from_data+0xa4\r\n10 00000042`c8efb390 00007ff7`ce250e04     Yiili!ResvgRenderer::load(class QByteArray * data = 0x00000042`c8eff5e8, class ResvgOptions * opt = <Value unavailable error>)+0x4b [H:\\Shareware\\yiili\\src\\thirdparty\\resvg\\include\\ResvgQt.h @ 356] \r\n```\n","hints_text":"For some reason I cannot download this file. Can you add it here?\nSVG raw content:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" contentStyleType=\"text\/css\" height=\"343px\" preserveAspectRatio=\"none\" style=\"width:533px;height:343px;background:#000000;\" version=\"1.1\" viewBox=\"0 0 533 343\" width=\"533px\" zoomAndPan=\"magnify\"><defs\/><g><rect fill=\"#152215\" height=\"1\" style=\"stroke:#152215;stroke-width:1.0;\" width=\"1\" x=\"0\" y=\"0\"\/><rect fill=\"#FFFFFF\" height=\"73\" style=\"stroke:#FFFFFF;stroke-width:1.0;\" width=\"532\" x=\"0\" y=\"0\"\/><image height=\"53\" width=\"450\" x=\"1\" xlink:href=\"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcIAAAA1CAMAAADlJhtiAAADAFBMVEX4Z1QAOpD\/\/9tmtv\/b\/\/8AADo6AAD\/\/\/8AAAAALEnbkDqQ2\/+QOgA6kNu2ZgBmAAD\/tmb\/\/7b\/25AAZrYAAGa2\/\/\/\/aVQAJ0j5Z1T\/alSvVVAAI0ZmOgA6ZpD3Z1Q6Zrbbtma22\/+2Zjr3ZlMAOmb+\/\/\/\/27YAOjrbtpD4ZlS229tmtts6kLYAZpC2kDpmkNv4ZlP\/bVSQZjrb\/9sAKkg6ADr4Z1P3VkH3ZlT3VT\/3VkD3WEMQMEmhUk86kJA6OgC2kGY6Zmb3YEz3Xkn3ZVH3XEf3Y0\/3W0b3V0L3ZVL3ZFH\/tpBmZmaQ29vb25BmkLaQttu225Db\/7YAZmb+9fT3XUj5gXH3Xkr3Vj\/3WEL7vLP3XEj3VUD3X0v4ZFD3X0r\/\/\/73YU33ZFD7Z1TbkGaQZgCQkDpmtpBmOjrb27b4W0b5g3P5lIX3Yk795+T3X0n3WUX5i3v6loj6n5L4bVr7x8D3YU73ZE\/7vbX8vLT3Uz7++\/v3Z1P6lYf3XUf939r+7Or+9PL++fj3VD\/6koP+9vX7q5\/6l4n7ua\/8xb74Xkn95uP2VkD+\/Pv3Wkb2WEP7sKb7u7L92tX94t35hHX8w7z92dP6pZn80Mn4aFP5f2\/3aVX\/\/v\/7r6T5nI\/4aFX+\/\/73YUz+\/v73WkX8zsf5Z1P5dGL7urH93Nf97+3+\/Pr3WUT7v7b+7uv2VT\/96uf6npH5hnb+aFMAIkb99vT3V0EAKEj3cF4AJkf7ubDfYVGzVlD4hnatVFCXT08AH0b\/aVP8y8T++\/qaUE\/+7+0AIkeoU1D4YU33XUn4cmD3Y1D4bVv4emi2tpCQtv\/\/29vb2\/+2kJDb29u2ttu227Y6AGY6OpC2\/9tmtraQkGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmvaTnAAANRklEQVR4Xu2ca4wkRR3Aq58z0zOzA7e7zL5uNseyx\/tiIsKehGDC4+CQ6CdECCJBjYbwwYSESDSaGI2JgolfkOAH4gNjVPjAQzQoJIJ3EXIPPLgHd9ztws3uLbO3u7Pz6q5+WNVVXd1d0zM9u7nZRzK\/5Larq+pf\/\/\/Uv7oeM\/8+IQF6bG3k0J0euuuU3ijYUEQ+o8dWo+fCLU\/PhVueLrowPShcYvGZPS443XOhZpXApw6fG03KloEkZMCoEedzXLNHiK64cHgX6mddV7Rrk3xRJNB0L4a2wBVQ9u9+aEoQ7CHLq9kKOgTSDqo2LKhunjaIMxNGX6jmpkTKrsVIIXQiYIeKwoz\/lzIF9rt56aOhbBBxqEjUVRNqScF6a5fEl0Wh2WUJV0xXshW+DOBsOtB0KUtr8mi2baChgHSW0Z1kKwb6o+OqUDMzQlmzFbdk4yGWRuKZv0qk0LzkTWOF3x4eRmhPvsCKpnYOPFbvH3tsWZtQpOXrz7IC\/myJTJEzqp4VxBX4TGcPuVq7yH26ZItZEKSWhJN\/exaMNzIph9bkkXUJSWKd+E61dBH9ERI26rLG7mO6qDhLeme2dBtiaSRZYU1GRos0oJRG\/OS7QzRj4vaLbpqqTm3fbu667fP3Xn39f68P1Q+TkxYWgVDnBpuEVzF4tWAjH6SEkCNscYlm1QB4AM+C6C+dB11y8zcAcNJaWMQ13Va4RdO2kLd8nVYSQHtcQB8uZfzv0DYJlWxrenjbGNREUKMrR9gxiBZwJptClqOcoWCKKXBMOIrbIJZSAabVbUioZ5qM7IDoifSSP8Lvo8sPv+XMufcTQ4+ID7JaT504cgYGJlN+Ik1XEoaGVy3rqmM0A02QEsSzK85VTcmGaP+iedMGLsJZ5IrKwWjRrUeKoVZFU+J4UbfdGkBLlwBAs2NiRcrUHFt2Wx0\/7ahKA+LedSekdGXnzIrUV8k6WDk3RccZlFCFBQ2pA8NFiGdjTyOTI9Uk5I30surJovnb9Q\/6ICzlKUBri0THF7aUNMC0koYyxPzV0sKFsoU\/zDabuPDWoS\/fDwqPP8LqPTJ\/5BC7aXJhqoGXIvZBqal4gZRs\/IkVA3VR2VsAgdtjZfwPfZqqPSgXUQtj1jnWoZpd+INzV2ls1nRrol7JDxyvSraWvOkV0fUl7pzB7CmsAlAXphowYU9MJwWIrXFN8ok1qH7HGyZaevsqIh5InkaJybm10pW+bJFY78pK9q2vD8rn8FgMpDwFIyfS9zzvdjCylKqhkn2koWCXrYLotTAtOlhZygF47O79xjX3PfPy8qt+vXfu2FlcZHf80HEcvBSZeGi5QLUuiniBrKiaCDVdTgC0Zsl6znvK5GXdQv9EdWmipJRXAJQ0vd7As6qLWlt89jeDA6dITTFjpM9XhLRpKwMz0li1YttWWt85X18EclrFZrtrimQkkvoSdOqKiaxxTWLEGQTkxs0HLytDUaqP1Qw0SqhGJkeGumxdPIsGGJMVnY+Q9aqRsFlKpwoacv5kpnLQBNRSFyZJGgKiYUeva+3pwIUTwtT94OVgNQD2jYwcYTe8C0UT7SNod2KyguKAsbIqoPGLbLYkqSZY40LNU5cVdLEP95AsLmQUJNVXz4NllT02sjX596fL50VSM+OkRN02VSMrLK44C0BAfSxbK\/gEKiN3ArI70oCmVpKGjQcU6hgR\/2HEGQTlHW9mPlbgF48Bx0xamq+RypFPVk+sbL\/xpMpkVStdByk92\/BTfVQBVBazIpailrowSdIQ6jdxLS6Ml7ky\/+jX+DwA\/nrNV\/BqGYm7HtkL7DEV6gCOzgG8GTHozqOWPnNpaP4lOxHrcKVk4e3NtDAcnPg+uM5f5x1dL6dNYOBmkyZQ0WAGBtkjmFIDXxoiLnTKQBe90SVbwRNqnEE5abpPVESQh4JoqyGNRI5UU2pTM6+pQdkleHkj43YpTfkKgO4uC9RSCpWkDVnqWnYzHbhw6vGHn+XzED\/+7P4Cn+eBejIXsgaqHz9IPiQcNfpMbDSsWoEtJ0JFMn271IQ1gm5G5os7BjO0JLy1NUBtR+XuhIq6R6+jD2DDbB\/y1PigCZK2eCeAwybqJrfvGNDOje92BIHtAGMNwh2e+J0oOanyZUxjUA6j7LsUediThTZQ1BNWvRxIYRGigLqOWuo1QLW6DWmDmVbHjbbEunDimAS+yWdiDrUcMmZoyANQvQKMjf0ZbetRd6tFfRlUZTAoHbHLgRl4IDWMBzmoyInZjGifE4QzSWYb155yBjpAGLnRFpEJS6o1WgaSNXNWANWk9JqgzjloFy983RvtuOdzUuWj\/SJrKN6gTBIPjstkUIPSDNPI5Nw6UEFGiktMNifttq08PhL5KU+BIo5rpGViqYsneTtpSJg3WnZpO+J2pOqfqncFawT4zkvexiqc70IOAgFSeMc8XBTzZ5vshFpiGWfiwwjav5+z5VRNtPa+0lTRrWmj7eFZabQ4cdLPT2ulwVlcHSkAeEvLgXYUez+k1nq0MUiDieARBG9IfY2uHM22hgK6WAFKdfjd8AUhzoVze564PVjDp7Dng3+RVJQLeVAnrmnH3DXWalBrucB5EcZObheQOF2fWaFPfRMz269ouRiG0JKTFiiY5tqiOrrAWg1qLwfFHJ0rUSpc1F3iXDj81G18lsdZ\/2TYllr\/SVmYA3jh2hys1aAYOZHtwcUWv7h0h1gXCi0ftYHpGT4rmrNDNwDrcv70uIGs1aC2corunQlQKlzUXVrYw\/i22NJPeuE\/fFYLZmeBSL4t3SSs1aC1ynWVuKfwR07Lp1C7js\/psRHEfcFWfutosEKQ3a8Ky24i7knu0VXinkI1+08+yyM10nKO7bGOxLnwqFXlszwOeL8H99hQYidBIfi1bJCf1p7js3psBHFPIfjY\/iWfRSiegHxWj40gbjtTKSUn3suRbUuIJ944doYmY5\/kHt0k9ikE+17\/efO2pQBWslk+s8eGEO\/Cowfs50Dhq+HMmScP\/iMQPdNjA4mdSAEoHT\/wg+fL4bn0S4de92+aJtJEqh4\/NDCa1CAVWYKQMpRWu6g2rEKK07el6cCFYC7x4ffuerGwl0bLFJZ\/cZV+OPAdN+9CDSx1FgQCJUhCWljCy7dY7FTnrEKK07e14bs\/klNq4smnc\/fRu0ePPz\/5Nvf7aQj86zuBRp+3CkJPmmny0ypLEHK26UT9HNCqHUIrqQg4fT7tNWxOOnIhOPoz441Tv\/qkf264+ukn+7Y7bzZvcALY4jbaQY6uBC48+EWHcIIi1L0GwrRoh9JKqhlen097DZuTTiZSRGnxvf7i6RNzS7PW+dPvvB9eGPlh4Dg1OktJhoinNnJJQUvcodSHKkDKDOB3H0SjSo6WJOGXyxZuAO4qGeHtFm3HMiMnQSKFGV4p4AAE1IBtRVXl9fm6mKVWoYIzHjgsqlabljYDsYEXweIrq\/jp419sagq8SNTVhFZSqiRO3v3kOAjdYVHqiTp+LYFFWNNEIJ69bdi944Wxc2HzLPAh1QAAtchi4bno+mZ9VNe\/P0c1SCR6Hsr0vQDWEjXF1bJpWNXQOuo6j\/dgM+YtlRKouFua6fyl+PfP6fwk6oWb7cFhnOnGd2oOjiEEgQQrl3MagLCUv1peWIR2\/901Ubq4TyHNTZpyZhvQFPwT+fKUht\/BSBdFOUGkMOla5l0cMYgWPFOURL5ahD6q61pPA8hNGOmHEiBVHBvG4RS0JWYKkd4sdDiRtoUblVC+\/KCpKNlUjUSfe+Hyfry6W02s09BCL+FHsbcNu\/cD4MNh826wvtsOdH4tWRaksfAWF13frM\/2dFENkEbPW\/S9AK8lyEwhhm8SuuDCrDCPp7SabXtx8uTix6tjUnqCLIQswcrbh92zMHYubB5LYRdqeCK1LODFwjfC1SL0sYB7qsGm0fPeewFeS5pvymaiC9Yg7+NAeSnpRZ+zIHQapQ4T9r6IaTQYz94u7N4LY+fC5j0cHb+CiPfFJBaeqxahj+nyLXWj5733AryWAqZsJrrgQgOk0UcuXyWMyCT6nFwCUeq2uUfXaSAYS4Si2NuF3QeC54Nh8\/j+Vic7YoBrANx9AC9YNBY+VC1Cnx9w72nwPMneC3Bb8k3pNGhoXWjhwr+80If4PZ\/dEZdYeKpU3l8petHn7sWPUlfQPKvo9EjoJQJR7IRWYfeB4HkubB6At8V0UQXHBXX\/PWUvFj5crT9SH9VFLfWi5733AryWfFNuoTZuCqLXwnt3yof6+\/u\/sCfqhZgmuLWwwn4lTuZqg1WJXmT9tCR4\/\/GBOklmOz8B\/PKanNXRZJuvnMwv5N\/Fr1ujA4BQ8ppzQBVNfoKtmBI6XZrCeVTuAAtLWWjtNkdXwFh6GsCRspCvSCBcbSlCn+HpOk81WGX3dAU1Q7DufAd6LX3ETIkO594gos+F4OGX3Ms8K2kHfy6MJu4d1rjyC8166+saLVy4KjpyYdz\/yBFXfqFZb33dY\/2+aRAXIv\/HGEZc+YVmvfV1jXV7Cnt0ixY70h5bh54LtzzhibTHFuT\/mGwAUijVTY4AAAAASUVORK5CYII=\" y=\"10\"\/><image height=\"62\" width=\"62\" x=\"450\" xlink:href=\"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAAA+CAYAAABzwahEAAACn0lEQVR4Xu3PQa7bQBADUd\/\/0slKmwcUONJ3gCR2AVw0ye6RXr8+lJfGp\/D98U\/j++OfRv746\/V6JPflbv\/CvVMVmXjgVO7L3f6Fe6cqMlmLUv3TDxH7zovVz2QtSvX\/+R\/3ByovzL1T+ZqVeZGJiz5QeWHuncrXrMyLTFz0gcpPqTvma1bmRSYu+kDlp9Qd8zUr8yITF32gctGvufw1K\/MiExd9oHLRr7n8NSvzIpO1KKtv\/tN5sfqZrEVZffOfzovVz+RavCv33z3fVZGJB07l\/rvnuyo6+SE+XB9Us\/67+WOX\/fD6oZr1301erg9YvthXhbnzYvUzqQ9cvthXhbnzYvUzWYsX9tasvyTmpUU2jg\/QW7P+kpiXFtnwgIdLhT1lz\/nUNy8ycdGHSoU9Zc\/51DcvMvHwkphX7+I0v6siEw8siXn1Lk7zuyo6OcSHfNB5+Rfmdb9YvU4O8YN80Hn5F+Z1v1i9TFw8fXj19GvWl8rLl2x44O4HVU+\/Zn2pvHzJhh9Qsi\/lX5g\/nUtFJh4o2ZfyL8yfzqUik1o8Phz5Xb+wv2bJpBYvv\/KLyu\/6hf01SyYuns7K3Fm\/8lL1F9nwwOmszJ31Ky9Vf7EbD\/EDnBerX3n5shsP8QOcF6tfefmSjevAXRXVW\/6a9c2LTDx8qqJ6y1+zvnmRyVqU1a9cf\/3QReXlSzZOD1ysfuX6f92P+0GVOytz56e6S2540Icqd1bmzk91l9zwoA9V7lwq7JXsO+tLJi56sHLnUmGvZN9ZXzJx0YOVL2r\/lNrXN5dMXPRg5YvaP6X29c0lk7Uo9tcHPPXVaS6ZrEWxvz7gqa9Oc8nEA6dy31m\/sF97d\/2LTHzwVO476xf2a++uf9HJf873xz+N749\/Gh\/7478BF\/nNnZYDEesAAAAASUVORK5CYII=\" y=\"5.5\"\/><rect fill=\"#000000\" height=\"196.5781\" style=\"stroke:#000000;stroke-width:1.0;\" width=\"532\" x=\"0\" y=\"73\"\/><text fill=\"#33FF02\" font-family=\"sans-serif\" font-size=\"12\" font-style=\"italic\" font-weight=\"bold\" lengthAdjust=\"spacing\" textLength=\"107\" x=\"5\" y=\"90\">PlantUML 1.2023.1<\/text><rect fill=\"#33FF02\" height=\"22.6094\" style=\"stroke:#33FF02;stroke-width:1.0;\" width=\"149\" x=\"5\" y=\"101.0938\"\/><text fill=\"#000000\" font-family=\"sans-serif\" font-size=\"14\" font-weight=\"bold\" lengthAdjust=\"spacing\" textLength=\"147\" x=\"6\" y=\"116.0938\">[From string (line 6) ]<\/text><text fill=\"#33FF02\" font-family=\"sans-serif\" font-size=\"14\" font-weight=\"bold\" lengthAdjust=\"spacing\" textLength=\"4\" x=\"5\" y=\"137.7031\">\u00a0<\/text><text fill=\"#33FF02\" font-family=\"sans-serif\" font-size=\"14\" font-weight=\"bold\" lengthAdjust=\"spacing\" textLength=\"71\" x=\"5\" y=\"155.3125\">@startuml<\/text><text fill=\"#33FF02\" font-family=\"sans-serif\" font-size=\"14\" font-weight=\"bold\" lengthAdjust=\"spacing\" textLength=\"4\" x=\"5\" y=\"172.9219\">\u00a0<\/text><text fill=\"#33FF02\" font-family=\"sans-serif\" font-size=\"14\" font-weight=\"bold\" lengthAdjust=\"spacing\" textLength=\"67\" x=\"5\" y=\"190.5313\">class Foo<\/text><text fill=\"#33FF02\" font-family=\"sans-serif\" font-size=\"14\" font-weight=\"bold\" lengthAdjust=\"spacing\" textLength=\"4\" x=\"5\" y=\"208.1406\">\u00a0<\/text><text fill=\"#33FF02\" font-family=\"sans-serif\" font-size=\"14\" font-weight=\"bold\" lengthAdjust=\"spacing\" textLength=\"4\" x=\"5\" y=\"225.75\">\u00a0<\/text><text fill=\"#33FF02\" font-family=\"sans-serif\" font-size=\"14\" font-weight=\"bold\" lengthAdjust=\"spacing\" text-decoration=\"wavy underline\" textLength=\"8\" x=\"5\" y=\"243.3594\">+<\/text><text fill=\"#FF0000\" font-family=\"sans-serif\" font-size=\"14\" font-weight=\"bold\" lengthAdjust=\"spacing\" textLength=\"95\" x=\"9\" y=\"260.9688\">Syntax Error?<\/text><rect fill=\"#FFFFFF\" height=\"73\" style=\"stroke:#FFFFFF;stroke-width:1.0;\" width=\"532\" x=\"0\" y=\"269.5781\"\/><image height=\"53\" width=\"450\" x=\"1\" xlink:href=\"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcIAAAA1CAMAAADlJhtiAAADAFBMVEX4Z1QAOpD\/\/9tmtv\/b\/\/8AADo6AAD\/\/\/8AAAAALEnbkDqQ2\/+QOgA6kNu2ZgBmAAD\/tmb\/\/7b\/25AAZrYAAGa2\/\/\/\/aVQAJ0j5Z1T\/alSvVVAAI0ZmOgA6ZpD3Z1Q6Zrbbtma22\/+2Zjr3ZlMAOmb+\/\/\/\/27YAOjrbtpD4ZlS229tmtts6kLYAZpC2kDpmkNv4ZlP\/bVSQZjrb\/9sAKkg6ADr4Z1P3VkH3ZlT3VT\/3VkD3WEMQMEmhUk86kJA6OgC2kGY6Zmb3YEz3Xkn3ZVH3XEf3Y0\/3W0b3V0L3ZVL3ZFH\/tpBmZmaQ29vb25BmkLaQttu225Db\/7YAZmb+9fT3XUj5gXH3Xkr3Vj\/3WEL7vLP3XEj3VUD3X0v4ZFD3X0r\/\/\/73YU33ZFD7Z1TbkGaQZgCQkDpmtpBmOjrb27b4W0b5g3P5lIX3Yk795+T3X0n3WUX5i3v6loj6n5L4bVr7x8D3YU73ZE\/7vbX8vLT3Uz7++\/v3Z1P6lYf3XUf939r+7Or+9PL++fj3VD\/6koP+9vX7q5\/6l4n7ua\/8xb74Xkn95uP2VkD+\/Pv3Wkb2WEP7sKb7u7L92tX94t35hHX8w7z92dP6pZn80Mn4aFP5f2\/3aVX\/\/v\/7r6T5nI\/4aFX+\/\/73YUz+\/v73WkX8zsf5Z1P5dGL7urH93Nf97+3+\/Pr3WUT7v7b+7uv2VT\/96uf6npH5hnb+aFMAIkb99vT3V0EAKEj3cF4AJkf7ubDfYVGzVlD4hnatVFCXT08AH0b\/aVP8y8T++\/qaUE\/+7+0AIkeoU1D4YU33XUn4cmD3Y1D4bVv4emi2tpCQtv\/\/29vb2\/+2kJDb29u2ttu227Y6AGY6OpC2\/9tmtraQkGYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmvaTnAAANRklEQVR4Xu2ca4wkRR3Aq58z0zOzA7e7zL5uNseyx\/tiIsKehGDC4+CQ6CdECCJBjYbwwYSESDSaGI2JgolfkOAH4gNjVPjAQzQoJIJ3EXIPPLgHd9ztws3uLbO3u7Pz6q5+WNVVXd1d0zM9u7nZRzK\/5Larq+pf\/\/\/Uv7oeM\/8+IQF6bG3k0J0euuuU3ijYUEQ+o8dWo+fCLU\/PhVueLrowPShcYvGZPS443XOhZpXApw6fG03KloEkZMCoEedzXLNHiK64cHgX6mddV7Rrk3xRJNB0L4a2wBVQ9u9+aEoQ7CHLq9kKOgTSDqo2LKhunjaIMxNGX6jmpkTKrsVIIXQiYIeKwoz\/lzIF9rt56aOhbBBxqEjUVRNqScF6a5fEl0Wh2WUJV0xXshW+DOBsOtB0KUtr8mi2baChgHSW0Z1kKwb6o+OqUDMzQlmzFbdk4yGWRuKZv0qk0LzkTWOF3x4eRmhPvsCKpnYOPFbvH3tsWZtQpOXrz7IC\/myJTJEzqp4VxBX4TGcPuVq7yH26ZItZEKSWhJN\/exaMNzIph9bkkXUJSWKd+E61dBH9ERI26rLG7mO6qDhLeme2dBtiaSRZYU1GRos0oJRG\/OS7QzRj4vaLbpqqTm3fbu667fP3Xn39f68P1Q+TkxYWgVDnBpuEVzF4tWAjH6SEkCNscYlm1QB4AM+C6C+dB11y8zcAcNJaWMQ13Va4RdO2kLd8nVYSQHtcQB8uZfzv0DYJlWxrenjbGNREUKMrR9gxiBZwJptClqOcoWCKKXBMOIrbIJZSAabVbUioZ5qM7IDoifSSP8Lvo8sPv+XMufcTQ4+ID7JaT504cgYGJlN+Ik1XEoaGVy3rqmM0A02QEsSzK85VTcmGaP+iedMGLsJZ5IrKwWjRrUeKoVZFU+J4UbfdGkBLlwBAs2NiRcrUHFt2Wx0\/7ahKA+LedSekdGXnzIrUV8k6WDk3RccZlFCFBQ2pA8NFiGdjTyOTI9Uk5I30surJovnb9Q\/6ICzlKUBri0THF7aUNMC0koYyxPzV0sKFsoU\/zDabuPDWoS\/fDwqPP8LqPTJ\/5BC7aXJhqoGXIvZBqal4gZRs\/IkVA3VR2VsAgdtjZfwPfZqqPSgXUQtj1jnWoZpd+INzV2ls1nRrol7JDxyvSraWvOkV0fUl7pzB7CmsAlAXphowYU9MJwWIrXFN8ok1qH7HGyZaevsqIh5InkaJybm10pW+bJFY78pK9q2vD8rn8FgMpDwFIyfS9zzvdjCylKqhkn2koWCXrYLotTAtOlhZygF47O79xjX3PfPy8qt+vXfu2FlcZHf80HEcvBSZeGi5QLUuiniBrKiaCDVdTgC0Zsl6znvK5GXdQv9EdWmipJRXAJQ0vd7As6qLWlt89jeDA6dITTFjpM9XhLRpKwMz0li1YttWWt85X18EclrFZrtrimQkkvoSdOqKiaxxTWLEGQTkxs0HLytDUaqP1Qw0SqhGJkeGumxdPIsGGJMVnY+Q9aqRsFlKpwoacv5kpnLQBNRSFyZJGgKiYUeva+3pwIUTwtT94OVgNQD2jYwcYTe8C0UT7SNod2KyguKAsbIqoPGLbLYkqSZY40LNU5cVdLEP95AsLmQUJNVXz4NllT02sjX596fL50VSM+OkRN02VSMrLK44C0BAfSxbK\/gEKiN3ArI70oCmVpKGjQcU6hgR\/2HEGQTlHW9mPlbgF48Bx0xamq+RypFPVk+sbL\/xpMpkVStdByk92\/BTfVQBVBazIpailrowSdIQ6jdxLS6Ml7ky\/+jX+DwA\/nrNV\/BqGYm7HtkL7DEV6gCOzgG8GTHozqOWPnNpaP4lOxHrcKVk4e3NtDAcnPg+uM5f5x1dL6dNYOBmkyZQ0WAGBtkjmFIDXxoiLnTKQBe90SVbwRNqnEE5abpPVESQh4JoqyGNRI5UU2pTM6+pQdkleHkj43YpTfkKgO4uC9RSCpWkDVnqWnYzHbhw6vGHn+XzED\/+7P4Cn+eBejIXsgaqHz9IPiQcNfpMbDSsWoEtJ0JFMn271IQ1gm5G5os7BjO0JLy1NUBtR+XuhIq6R6+jD2DDbB\/y1PigCZK2eCeAwybqJrfvGNDOje92BIHtAGMNwh2e+J0oOanyZUxjUA6j7LsUediThTZQ1BNWvRxIYRGigLqOWuo1QLW6DWmDmVbHjbbEunDimAS+yWdiDrUcMmZoyANQvQKMjf0ZbetRd6tFfRlUZTAoHbHLgRl4IDWMBzmoyInZjGifE4QzSWYb155yBjpAGLnRFpEJS6o1WgaSNXNWANWk9JqgzjloFy983RvtuOdzUuWj\/SJrKN6gTBIPjstkUIPSDNPI5Nw6UEFGiktMNifttq08PhL5KU+BIo5rpGViqYsneTtpSJg3WnZpO+J2pOqfqncFawT4zkvexiqc70IOAgFSeMc8XBTzZ5vshFpiGWfiwwjav5+z5VRNtPa+0lTRrWmj7eFZabQ4cdLPT2ulwVlcHSkAeEvLgXYUez+k1nq0MUiDieARBG9IfY2uHM22hgK6WAFKdfjd8AUhzoVze564PVjDp7Dng3+RVJQLeVAnrmnH3DXWalBrucB5EcZObheQOF2fWaFPfRMz269ouRiG0JKTFiiY5tqiOrrAWg1qLwfFHJ0rUSpc1F3iXDj81G18lsdZ\/2TYllr\/SVmYA3jh2hys1aAYOZHtwcUWv7h0h1gXCi0ftYHpGT4rmrNDNwDrcv70uIGs1aC2corunQlQKlzUXVrYw\/i22NJPeuE\/fFYLZmeBSL4t3SSs1aC1ynWVuKfwR07Lp1C7js\/psRHEfcFWfutosEKQ3a8Ky24i7knu0VXinkI1+08+yyM10nKO7bGOxLnwqFXlszwOeL8H99hQYidBIfi1bJCf1p7js3psBHFPIfjY\/iWfRSiegHxWj40gbjtTKSUn3suRbUuIJ944doYmY5\/kHt0k9ikE+17\/efO2pQBWslk+s8eGEO\/Cowfs50Dhq+HMmScP\/iMQPdNjA4mdSAEoHT\/wg+fL4bn0S4de92+aJtJEqh4\/NDCa1CAVWYKQMpRWu6g2rEKK07el6cCFYC7x4ffuerGwl0bLFJZ\/cZV+OPAdN+9CDSx1FgQCJUhCWljCy7dY7FTnrEKK07e14bs\/klNq4smnc\/fRu0ePPz\/5Nvf7aQj86zuBRp+3CkJPmmny0ypLEHK26UT9HNCqHUIrqQg4fT7tNWxOOnIhOPoz441Tv\/qkf264+ukn+7Y7bzZvcALY4jbaQY6uBC48+EWHcIIi1L0GwrRoh9JKqhlen097DZuTTiZSRGnxvf7i6RNzS7PW+dPvvB9eGPlh4Dg1OktJhoinNnJJQUvcodSHKkDKDOB3H0SjSo6WJOGXyxZuAO4qGeHtFm3HMiMnQSKFGV4p4AAE1IBtRVXl9fm6mKVWoYIzHjgsqlabljYDsYEXweIrq\/jp419sagq8SNTVhFZSqiRO3v3kOAjdYVHqiTp+LYFFWNNEIJ69bdi944Wxc2HzLPAh1QAAtchi4bno+mZ9VNe\/P0c1SCR6Hsr0vQDWEjXF1bJpWNXQOuo6j\/dgM+YtlRKouFua6fyl+PfP6fwk6oWb7cFhnOnGd2oOjiEEgQQrl3MagLCUv1peWIR2\/901Ubq4TyHNTZpyZhvQFPwT+fKUht\/BSBdFOUGkMOla5l0cMYgWPFOURL5ahD6q61pPA8hNGOmHEiBVHBvG4RS0JWYKkd4sdDiRtoUblVC+\/KCpKNlUjUSfe+Hyfry6W02s09BCL+FHsbcNu\/cD4MNh826wvtsOdH4tWRaksfAWF13frM\/2dFENkEbPW\/S9AK8lyEwhhm8SuuDCrDCPp7SabXtx8uTix6tjUnqCLIQswcrbh92zMHYubB5LYRdqeCK1LODFwjfC1SL0sYB7qsGm0fPeewFeS5pvymaiC9Yg7+NAeSnpRZ+zIHQapQ4T9r6IaTQYz94u7N4LY+fC5j0cHb+CiPfFJBaeqxahj+nyLXWj5733AryWAqZsJrrgQgOk0UcuXyWMyCT6nFwCUeq2uUfXaSAYS4Si2NuF3QeC54Nh8\/j+Vic7YoBrANx9AC9YNBY+VC1Cnx9w72nwPMneC3Bb8k3pNGhoXWjhwr+80If4PZ\/dEZdYeKpU3l8petHn7sWPUlfQPKvo9EjoJQJR7IRWYfeB4HkubB6At8V0UQXHBXX\/PWUvFj5crT9SH9VFLfWi5733AryWfFNuoTZuCqLXwnt3yof6+\/u\/sCfqhZgmuLWwwn4lTuZqg1WJXmT9tCR4\/\/GBOklmOz8B\/PKanNXRZJuvnMwv5N\/Fr1ujA4BQ8ppzQBVNfoKtmBI6XZrCeVTuAAtLWWjtNkdXwFh6GsCRspCvSCBcbSlCn+HpOk81WGX3dAU1Q7DufAd6LX3ETIkO594gos+F4OGX3Ms8K2kHfy6MJu4d1rjyC8166+saLVy4KjpyYdz\/yBFXfqFZb33dY\/2+aRAXIv\/HGEZc+YVmvfV1jXV7Cnt0ixY70h5bh54LtzzhibTHFuT\/mGwAUijVTY4AAAAASUVORK5CYII=\" y=\"279.5781\"\/><image height=\"62\" width=\"62\" x=\"450\" xlink:href=\"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD4AAAA+CAYAAABzwahEAAACn0lEQVR4Xu3PQa7bQBADUd\/\/0slKmwcUONJ3gCR2AVw0ye6RXr8+lJfGp\/D98U\/j++OfRv746\/V6JPflbv\/CvVMVmXjgVO7L3f6Fe6cqMlmLUv3TDxH7zovVz2QtSvX\/+R\/3ByovzL1T+ZqVeZGJiz5QeWHuncrXrMyLTFz0gcpPqTvma1bmRSYu+kDlp9Qd8zUr8yITF32gctGvufw1K\/MiExd9oHLRr7n8NSvzIpO1KKtv\/tN5sfqZrEVZffOfzovVz+RavCv33z3fVZGJB07l\/rvnuyo6+SE+XB9Us\/67+WOX\/fD6oZr1301erg9YvthXhbnzYvUzqQ9cvthXhbnzYvUzWYsX9tasvyTmpUU2jg\/QW7P+kpiXFtnwgIdLhT1lz\/nUNy8ycdGHSoU9Zc\/51DcvMvHwkphX7+I0v6siEw8siXn1Lk7zuyo6OcSHfNB5+Rfmdb9YvU4O8YN80Hn5F+Z1v1i9TFw8fXj19GvWl8rLl2x44O4HVU+\/Zn2pvHzJhh9Qsi\/lX5g\/nUtFJh4o2ZfyL8yfzqUik1o8Phz5Xb+wv2bJpBYvv\/KLyu\/6hf01SyYuns7K3Fm\/8lL1F9nwwOmszJ31Ky9Vf7EbD\/EDnBerX3n5shsP8QOcF6tfefmSjevAXRXVW\/6a9c2LTDx8qqJ6y1+zvnmRyVqU1a9cf\/3QReXlSzZOD1ysfuX6f92P+0GVOytz56e6S2540Icqd1bmzk91l9zwoA9V7lwq7JXsO+tLJi56sHLnUmGvZN9ZXzJx0YOVL2r\/lNrXN5dMXPRg5YvaP6X29c0lk7Uo9tcHPPXVaS6ZrEWxvz7gqa9Oc8nEA6dy31m\/sF97d\/2LTHzwVO476xf2a++uf9HJf873xz+N749\/Gh\/7478BF\/nNnZYDEesAAAAASUVORK5CYII=\" y=\"275.0781\"\/><!--SRC=[Iyv9B2vMSClFv-9IuD96GbmvgMab2iMPAQaW6G00]--><\/g><\/svg>\r\n```\nCan confirm. Will take a look.","created_at":1677,"merge_commit_sha":"42145621309796c79015cd14fa86a4c6e40916ea","ci_name_list":[]}
{"repo":"linebender\/resvg","pull_number":482,"instance_id":"linebender__resvg-482","issue_numbers":["481"],"base_commit":"ee20674d21f4abd637873c28fb8bbff30d9e06a5","patch":"diff --git a\/usvg\/src\/lib.rs b\/usvg\/src\/lib.rs\nindex 739535fdf..7042e13ba 100644\n--- a\/usvg\/src\/lib.rs\n+++ b\/usvg\/src\/lib.rs\n@@ -794,7 +794,9 @@ fn calc_node_bbox(\n             let mut bbox = PathBbox::new_bbox();\n \n             for child in node.children() {\n-                if let Some(c_bbox) = calc_node_bbox(&child, ts) {\n+                let mut child_transform = ts.clone();\n+                child_transform.append(&child.transform());\n+                if let Some(c_bbox) = calc_node_bbox(&child, child_transform) {\n                     bbox = bbox.expand(c_bbox);\n                 }\n             }\n","test_patch":"","problem_statement":"Transforms and bbox\nThis SVG doc:\r\n```xml\r\n<svg width=\"102\" height=\"124\" viewBox=\"0 0 102 124\" fill=\"none\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\r\n   <rect width=\"124\" height=\"102\" transform=\"translate(102) rotate(90)\" fill=\"#7B61FF\"\/>\r\n<\/svg>\r\n```\r\n...and this code:\r\n```rust\r\nuse usvg::NodeExt;\r\n\r\nfn main() {\r\n    let tree = usvg::Tree::from_str(\r\n        include_str!(\"..\/simplified.svg\"),\r\n        &usvg::Options { ..Default::default() }.to_ref(),\r\n    )\r\n    .unwrap();\r\n\r\n    let bbox = tree.root().calculate_bbox().unwrap();\r\n    println!(\r\n        \"bbox: {}x{}+{}+{}\",\r\n        bbox.width(),\r\n        bbox.height(),\r\n        bbox.x(),\r\n        bbox.y()\r\n    );\r\n}\r\n```\r\nreports a bbox of `124x102+0+0`. Since the rect is rotated by 90 degrees, I'd expect a bbox of `102x124+0+0`. `resvg` renders the document honoring the transform (and only sets pixels within 102x124).\r\n\r\nAm I misunderstanding bbox? I really want to know the bounds of the pixels that will be painted by a given document, and I know bbox doesn't consider filter bounds (like drop shadows), so I think I need to write an alternative implementation of bbox anyway, so I am really asking if this is a bug that you'd like a fix for, or if this is expected behavior and any \"paint bounds\" implementation I make should either exist outside of usvg or be a new method.\n","hints_text":"This change gives me the bbox result I am expecting; \r\n```diff\r\ndiff --git a\/usvg\/src\/lib.rs b\/usvg\/src\/lib.rs\r\nindex 739535f..7042e13 100644\r\n--- a\/usvg\/src\/lib.rs\r\n+++ b\/usvg\/src\/lib.rs\r\n@@ -794,7 +794,9 @@ fn calc_node_bbox(\r\n             let mut bbox = PathBbox::new_bbox();\r\n\r\n             for child in node.children() {\r\n-                if let Some(c_bbox) = calc_node_bbox(&child, ts) {\r\n+                let mut child_transform = ts.clone();\r\n+                child_transform.append(&child.transform());\r\n+                if let Some(c_bbox) = calc_node_bbox(&child, child_transform) {\r\n                     bbox = bbox.expand(c_bbox);\r\n                 }\r\n             }\r\n```\nLooks like a bug to me. This method is not used by the renderer, it's just a utility.\r\nFill free to send a patch.","created_at":1637,"merge_commit_sha":"b7ee0dac70178d28652ce50ce407893c75dc3997","ci_name_list":[]}
{"repo":"rustzx\/rustzx","pull_number":133,"instance_id":"rustzx__rustzx-133","issue_numbers":["97"],"base_commit":"af66de9b27707025c10f946ec2fc5a9b307fe1d8","patch":"diff --git a\/.cargo\/config.toml b\/.cargo\/config.toml\nindex 2591cb8..17297ec 100644\n--- a\/.cargo\/config.toml\n+++ b\/.cargo\/config.toml\n@@ -15,4 +15,4 @@ rustflags = [\n rustflags = [\n   \"-C\", \"link-arg=-undefined\",\n   \"-C\", \"link-arg=dynamic_lookup\",\n-]\n\\ No newline at end of file\n+]\ndiff --git a\/.github\/workflows\/ci.yml b\/.github\/workflows\/ci.yml\nindex 60ae7b8..ef43a88 100644\n--- a\/.github\/workflows\/ci.yml\n+++ b\/.github\/workflows\/ci.yml\n@@ -95,3 +95,10 @@ jobs:\n         with:\n           command: test\n           args: -p rustzx-test\n+  typos:\n+    name: \"Typos check\"\n+    runs-on: ubuntu-20.04\n+    steps:\n+      - uses: actions\/checkout@v2\n+      - name: Typos\n+        uses: crate-ci\/typos@master\ndiff --git a\/CHANGELOG.md b\/CHANGELOG.md\nindex d3c8af1..530f860 100644\n--- a\/CHANGELOG.md\n+++ b\/CHANGELOG.md\n@@ -37,7 +37,7 @@ Changes:\n     - File autodetect from CLI\n     - Added configurable sound sample rate\n     - Removed redundant args\n-- **[Dependencies]** Switched to bundled `sdl` crate mode, making build almost dependecy-free (CMake and C compiller are still requird)\n+- **[Dependencies]** Switched to bundled `sdl` crate mode, making build almost dependency-free (CMake and C compiller are still requird)\n - **[Infrastructure]** Moved CI to _Github Actions_\n     - Added `rustfmt` step to CI\n     - Added `clippy` step to CI\n@@ -78,7 +78,7 @@ Changes:\n - **[05.07.2016]** v0.8 development started in branch `develop`\n - **[27.06.2016]** Release v0.7.1\n - **[26.06.2016]** Beeper sound implemented :notes:, release planed to July 1 :rocket:\n-- **[12.06.2016]** Some Comand line arguments fixes\/enchantments\n+- **[12.06.2016]** Some Command line arguments fixes\/enchantments\n - **[12.06.2016]** SNA files loading\n - **[11.06.2016]** Command line arguments using **clap** crate\n - **[11.06.2016]** Tap files fast loading implemented, finnaly!\ndiff --git a\/Cargo.lock b\/Cargo.lock\nindex 5d58a05..5cc1ac9 100644\n--- a\/Cargo.lock\n+++ b\/Cargo.lock\n@@ -16,9 +16,9 @@ checksum = \"aae1277d39aeec15cb388266ecc24b11c80469deae6067e17a1a7aa9e5c1f234\"\n \n [[package]]\n name = \"alsa\"\n-version = \"0.6.0\"\n+version = \"0.7.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"5915f52fe2cf65e83924d037b6c5290b7cee097c6b5c8700746e6168a343fd6b\"\n+checksum = \"8512c9117059663fb5606788fbca3619e2a91dac0e3fe516242eab1fa6be5e44\"\n dependencies = [\n  \"alsa-sys\",\n  \"bitflags\",\n@@ -64,13 +64,13 @@ dependencies = [\n \n [[package]]\n name = \"autocfg\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n+checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n \n [[package]]\n name = \"aym\"\n-version = \"0.15.1\"\n+version = \"0.16.0\"\n dependencies = [\n  \"libm\",\n  \"num-traits\",\n@@ -233,6 +233,12 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"core-foundation-sys\"\n+version = \"0.6.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"e7ca8a5221364ef15ce201e8ed2f609fc312682a8f4e0e3d4aa5879764e0fa3b\"\n+\n [[package]]\n name = \"core-foundation-sys\"\n version = \"0.8.2\"\n@@ -241,11 +247,12 @@ checksum = \"ea221b5284a47e40033bf9b66f35f984ec0ea2931eb03505246cd27a963f981b\"\n \n [[package]]\n name = \"coreaudio-rs\"\n-version = \"0.10.0\"\n+version = \"0.11.2\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"11894b20ebfe1ff903cbdc52259693389eea03b94918a2def2c30c3bf227ad88\"\n+checksum = \"cb17e2d1795b1996419648915df94bc7103c28f7b48062d7acf4652fc371b2ff\"\n dependencies = [\n  \"bitflags\",\n+ \"core-foundation-sys 0.6.2\",\n  \"coreaudio-sys\",\n ]\n \n@@ -260,27 +267,27 @@ dependencies = [\n \n [[package]]\n name = \"cpal\"\n-version = \"0.13.5\"\n+version = \"0.15.1\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"74117836a5124f3629e4b474eed03e479abaf98988b4bb317e29f08cfe0e4116\"\n+checksum = \"f1241019dec4a73f874bdf6fe3467a8478b47cecaf79435f7acb01f107ab41b1\"\n dependencies = [\n  \"alsa\",\n- \"core-foundation-sys\",\n+ \"core-foundation-sys 0.8.2\",\n  \"coreaudio-rs\",\n- \"jni\",\n+ \"dasp_sample\",\n+ \"jni 0.19.0\",\n  \"js-sys\",\n- \"lazy_static\",\n  \"libc\",\n- \"mach\",\n- \"ndk 0.6.0\",\n- \"ndk-glue 0.6.2\",\n- \"nix\",\n+ \"mach2\",\n+ \"ndk\",\n+ \"ndk-context\",\n  \"oboe\",\n+ \"once_cell\",\n  \"parking_lot\",\n- \"stdweb\",\n- \"thiserror\",\n+ \"wasm-bindgen\",\n+ \"wasm-bindgen-futures\",\n  \"web-sys\",\n- \"winapi\",\n+ \"windows\",\n ]\n \n [[package]]\n@@ -302,23 +309,22 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"darling\"\n-version = \"0.10.2\"\n+name = \"crossbeam-utils\"\n+version = \"0.8.15\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"0d706e75d87e35569db781a9b5e2416cff1236a47ed380831f959382ccd5f858\"\n+checksum = \"3c063cd8cc95f5c377ed0d4b49a4b21f632396ff690e8470c29b3359b346984b\"\n dependencies = [\n- \"darling_core 0.10.2\",\n- \"darling_macro 0.10.2\",\n+ \"cfg-if\",\n ]\n \n [[package]]\n name = \"darling\"\n-version = \"0.13.4\"\n+version = \"0.10.2\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"a01d95850c592940db9b8194bc39f4bc0e89dee5c4265e4b1807c34a9aba453c\"\n+checksum = \"0d706e75d87e35569db781a9b5e2416cff1236a47ed380831f959382ccd5f858\"\n dependencies = [\n- \"darling_core 0.13.4\",\n- \"darling_macro 0.13.4\",\n+ \"darling_core\",\n+ \"darling_macro\",\n ]\n \n [[package]]\n@@ -335,41 +341,22 @@ dependencies = [\n  \"syn\",\n ]\n \n-[[package]]\n-name = \"darling_core\"\n-version = \"0.13.4\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"859d65a907b6852c9361e3185c862aae7fafd2887876799fa55f5f99dc40d610\"\n-dependencies = [\n- \"fnv\",\n- \"ident_case\",\n- \"proc-macro2\",\n- \"quote\",\n- \"strsim 0.10.0\",\n- \"syn\",\n-]\n-\n [[package]]\n name = \"darling_macro\"\n version = \"0.10.2\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"d9b5a2f4ac4969822c62224815d069952656cadc7084fdca9751e6d959189b72\"\n dependencies = [\n- \"darling_core 0.10.2\",\n+ \"darling_core\",\n  \"quote\",\n  \"syn\",\n ]\n \n [[package]]\n-name = \"darling_macro\"\n-version = \"0.13.4\"\n+name = \"dasp_sample\"\n+version = \"0.11.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"9c972679f83bdf9c42bd905396b6c3588a843a17f0f16dfcfa3e2c5d57441835\"\n-dependencies = [\n- \"darling_core 0.13.4\",\n- \"quote\",\n- \"syn\",\n-]\n+checksum = \"0c87e182de0887fd5361989c677c4e8f5000cd9491d6d563161a8f3a5519fc7f\"\n \n [[package]]\n name = \"deflate\"\n@@ -484,7 +471,7 @@ version = \"0.6.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"7e08079fa3c89edec9160ceaa9e7172785468c26c053d12924cce0d5a55c241a\"\n dependencies = [\n- \"darling 0.10.2\",\n+ \"darling\",\n  \"proc-macro2\",\n  \"quote\",\n  \"syn\",\n@@ -541,15 +528,6 @@ version = \"1.0.1\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39\"\n \n-[[package]]\n-name = \"instant\"\n-version = \"0.1.11\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"716d3d89f35ac6a34fd0eed635395f4c3b76fa889338a4632e5231a8684216bd\"\n-dependencies = [\n- \"cfg-if\",\n-]\n-\n [[package]]\n name = \"itoa\"\n version = \"1.0.2\"\n@@ -570,6 +548,20 @@ dependencies = [\n  \"walkdir\",\n ]\n \n+[[package]]\n+name = \"jni\"\n+version = \"0.20.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"039022cdf4d7b1cf548d31f60ae783138e5fd42013f6271049d7df7afadef96c\"\n+dependencies = [\n+ \"cesu8\",\n+ \"combine\",\n+ \"jni-sys\",\n+ \"log\",\n+ \"thiserror\",\n+ \"walkdir\",\n+]\n+\n [[package]]\n name = \"jni-sys\"\n version = \"0.3.0\"\n@@ -587,9 +579,9 @@ dependencies = [\n \n [[package]]\n name = \"js-sys\"\n-version = \"0.3.55\"\n+version = \"0.3.61\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"7cc9ffccd38c451a86bf13657df244e9c3f37493cce8e5e21e940963777acc84\"\n+checksum = \"445dde2150c55e483f3d8416706b97ec8e8237c307e5b7b4b8dd15e6af2a0730\"\n dependencies = [\n  \"wasm-bindgen\",\n ]\n@@ -633,10 +625,11 @@ checksum = \"c7d73b3f436185384286bd8098d17ec07c9a7d2388a6599f824d8502b529702a\"\n \n [[package]]\n name = \"lock_api\"\n-version = \"0.4.5\"\n+version = \"0.4.9\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"712a4d093c9976e24e7dbca41db895dabcbac38eb5f4045393d17a95bdfb1109\"\n+checksum = \"435011366fe56583b16cf956f9df0095b405b82d76425bc8981c0e22e60ec4df\"\n dependencies = [\n+ \"autocfg\",\n  \"scopeguard\",\n ]\n \n@@ -650,10 +643,10 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"mach\"\n-version = \"0.3.2\"\n+name = \"mach2\"\n+version = \"0.4.1\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"b823e83b2affd8f40a9ee8c29dbc56404c1e34cd2710921f2801e2cf29527afa\"\n+checksum = \"6d0d1830bcd151a6fc4aea1369af235b36c1528fe976b8ff678683c9995eade8\"\n dependencies = [\n  \"libc\",\n ]\n@@ -664,15 +657,6 @@ version = \"2.3.4\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"0ee1c47aaa256ecabcaea351eae4a9b01ef39ed810004e298d2511ed284b1525\"\n \n-[[package]]\n-name = \"memoffset\"\n-version = \"0.6.5\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce\"\n-dependencies = [\n- \"autocfg\",\n-]\n-\n [[package]]\n name = \"miniz_oxide\"\n version = \"0.3.7\"\n@@ -703,27 +687,15 @@ dependencies = [\n \n [[package]]\n name = \"ndk\"\n-version = \"0.4.0\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"d64d6af06fde0e527b1ba5c7b79a6cc89cfc46325b0b2887dffe8f70197e0c3c\"\n-dependencies = [\n- \"bitflags\",\n- \"jni-sys\",\n- \"ndk-sys 0.2.1\",\n- \"num_enum\",\n- \"thiserror\",\n-]\n-\n-[[package]]\n-name = \"ndk\"\n-version = \"0.6.0\"\n+version = \"0.7.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"2032c77e030ddee34a6787a64166008da93f6a352b629261d0fee232b8742dd4\"\n+checksum = \"451422b7e4718271c8b5b3aadf5adedba43dc76312454b387e98fae0fc951aa0\"\n dependencies = [\n  \"bitflags\",\n  \"jni-sys\",\n- \"ndk-sys 0.3.0\",\n+ \"ndk-sys\",\n  \"num_enum\",\n+ \"raw-window-handle\",\n  \"thiserror\",\n ]\n \n@@ -733,87 +705,24 @@ version = \"0.1.1\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"27b02d87554356db9e9a873add8782d4ea6e3e58ea071a9adb9a2e8ddb884a8b\"\n \n-[[package]]\n-name = \"ndk-glue\"\n-version = \"0.4.0\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"d3e9e94628f24e7a3cb5b96a2dc5683acd9230bf11991c2a1677b87695138420\"\n-dependencies = [\n- \"lazy_static\",\n- \"libc\",\n- \"log\",\n- \"ndk 0.4.0\",\n- \"ndk-macro 0.2.0\",\n- \"ndk-sys 0.2.1\",\n-]\n-\n-[[package]]\n-name = \"ndk-glue\"\n-version = \"0.6.2\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"0d0c4a7b83860226e6b4183edac21851f05d5a51756e97a1144b7f5a6b63e65f\"\n-dependencies = [\n- \"lazy_static\",\n- \"libc\",\n- \"log\",\n- \"ndk 0.6.0\",\n- \"ndk-context\",\n- \"ndk-macro 0.3.0\",\n- \"ndk-sys 0.3.0\",\n-]\n-\n-[[package]]\n-name = \"ndk-macro\"\n-version = \"0.2.0\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"05d1c6307dc424d0f65b9b06e94f88248e6305726b14729fd67a5e47b2dc481d\"\n-dependencies = [\n- \"darling 0.10.2\",\n- \"proc-macro-crate 0.1.5\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n-[[package]]\n-name = \"ndk-macro\"\n-version = \"0.3.0\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"0df7ac00c4672f9d5aece54ee3347520b7e20f158656c7db2e6de01902eb7a6c\"\n-dependencies = [\n- \"darling 0.13.4\",\n- \"proc-macro-crate 1.1.0\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n [[package]]\n name = \"ndk-sys\"\n-version = \"0.2.1\"\n+version = \"0.4.1+23.1.7779620\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"c44922cb3dbb1c70b5e5f443d63b64363a898564d739ba5198e3a9138442868d\"\n-\n-[[package]]\n-name = \"ndk-sys\"\n-version = \"0.3.0\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"6e5a6ae77c8ee183dcbbba6150e2e6b9f3f4196a7666c02a715a95692ec1fa97\"\n+checksum = \"3cf2aae958bd232cac5069850591667ad422d263686d75b52a065f9badeee5a3\"\n dependencies = [\n  \"jni-sys\",\n ]\n \n [[package]]\n name = \"nix\"\n-version = \"0.23.1\"\n+version = \"0.24.3\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"9f866317acbd3a240710c63f065ffb1e4fd466259045ccb504130b7f668f35c6\"\n+checksum = \"fa52e972a9a719cecb6864fb88568781eb706bac2cd1d4f04a648542dbf78069\"\n dependencies = [\n  \"bitflags\",\n- \"cc\",\n  \"cfg-if\",\n  \"libc\",\n- \"memoffset\",\n ]\n \n [[package]]\n@@ -882,7 +791,7 @@ version = \"0.5.4\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"486ea01961c4a818096de679a8b740b26d9033146ac5291b1c98557658f8cdd9\"\n dependencies = [\n- \"proc-macro-crate 1.1.0\",\n+ \"proc-macro-crate\",\n  \"proc-macro2\",\n  \"quote\",\n  \"syn\",\n@@ -899,13 +808,13 @@ dependencies = [\n \n [[package]]\n name = \"oboe\"\n-version = \"0.4.4\"\n+version = \"0.5.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"e15e22bc67e047fe342a32ecba55f555e3be6166b04dd157cd0f803dfa9f48e1\"\n+checksum = \"8868cc237ee02e2d9618539a23a8d228b9bb3fc2e7a5b11eed3831de77c395d0\"\n dependencies = [\n- \"jni\",\n- \"ndk 0.4.0\",\n- \"ndk-glue 0.4.0\",\n+ \"jni 0.20.0\",\n+ \"ndk\",\n+ \"ndk-context\",\n  \"num-derive\",\n  \"num-traits\",\n  \"oboe-sys\",\n@@ -913,18 +822,18 @@ dependencies = [\n \n [[package]]\n name = \"oboe-sys\"\n-version = \"0.4.4\"\n+version = \"0.5.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"338142ae5ab0aaedc8275aa8f67f460e43ae0fca76a695a742d56da0a269eadc\"\n+checksum = \"7f44155e7fb718d3cfddcf70690b2b51ac4412f347cd9e4fbe511abe9cd7b5f2\"\n dependencies = [\n  \"cc\",\n ]\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.8.0\"\n+version = \"1.17.1\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"692fcb63b64b1758029e0a96ee63e049ce8c5948587f2f7208df04625e5f6b56\"\n+checksum = \"b7e5500299e16ebb147ae15a00a942af264cf3688f47923b8fc2cd5858f23ad3\"\n \n [[package]]\n name = \"opaque-debug\"\n@@ -934,27 +843,25 @@ checksum = \"624a8340c38c1b80fd549087862da4ba43e08858af025b236e509b6649fc13d5\"\n \n [[package]]\n name = \"parking_lot\"\n-version = \"0.11.2\"\n+version = \"0.12.1\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99\"\n+checksum = \"3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f\"\n dependencies = [\n- \"instant\",\n  \"lock_api\",\n  \"parking_lot_core\",\n ]\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.8.5\"\n+version = \"0.9.7\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"d76e8e1493bcac0d2766c42737f34458f1c8c50c0d23bcb24ea953affb273216\"\n+checksum = \"9069cbb9f99e3a5083476ccb29ceb1de18b9118cafa53e90c9551235de2b9521\"\n dependencies = [\n  \"cfg-if\",\n- \"instant\",\n  \"libc\",\n  \"redox_syscall\",\n  \"smallvec\",\n- \"winapi\",\n+ \"windows-sys\",\n ]\n \n [[package]]\n@@ -993,15 +900,6 @@ version = \"0.2.10\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"ac74c624d6b2d21f425f752262f42188365d7b8ff1aff74c82e45136510a4857\"\n \n-[[package]]\n-name = \"proc-macro-crate\"\n-version = \"0.1.5\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"1d6ea3c4595b96363c13943497db34af4460fb474a95c43f4446ad341b8c9785\"\n-dependencies = [\n- \"toml\",\n-]\n-\n [[package]]\n name = \"proc-macro-crate\"\n version = \"1.1.0\"\n@@ -1038,11 +936,11 @@ dependencies = [\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.26\"\n+version = \"1.0.53\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"a152013215dca273577e18d2bf00fa862b89b24169fb78c4c95aeb07992c9cec\"\n+checksum = \"ba466839c78239c09faf015484e5cc04860f88242cff4d03eb038f04b4699b73\"\n dependencies = [\n- \"unicode-xid\",\n+ \"unicode-ident\",\n ]\n \n [[package]]\n@@ -1094,6 +992,12 @@ dependencies = [\n  \"rand_core\",\n ]\n \n+[[package]]\n+name = \"raw-window-handle\"\n+version = \"0.5.1\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"4f851a03551ceefd30132e447f07f96cb7011d6b658374f3aed847333adb5559\"\n+\n [[package]]\n name = \"redox_syscall\"\n version = \"0.2.10\"\n@@ -1124,6 +1028,15 @@ version = \"1.0.1\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"b9b1a3d5f46d53f4a3478e2be4a5a5ce5108ea58b100dcd139830eae7f79a3a1\"\n \n+[[package]]\n+name = \"ringbuf\"\n+version = \"0.3.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"93ca10b9c9e53ac855a2d6953bce34cef6edbac32c4b13047a4d59d67299420a\"\n+dependencies = [\n+ \"crossbeam-utils\",\n+]\n+\n [[package]]\n name = \"rustc-hash\"\n version = \"1.1.0\"\n@@ -1132,11 +1045,12 @@ checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n \n [[package]]\n name = \"rustzx\"\n-version = \"0.15.0\"\n+version = \"0.16.0\"\n dependencies = [\n  \"anyhow\",\n  \"cpal\",\n  \"log\",\n+ \"ringbuf\",\n  \"rustzx-core\",\n  \"rustzx-utils\",\n  \"sdl2\",\n@@ -1147,7 +1061,7 @@ dependencies = [\n \n [[package]]\n name = \"rustzx-core\"\n-version = \"0.15.0\"\n+version = \"0.16.0\"\n dependencies = [\n  \"aym\",\n  \"bitflags\",\n@@ -1161,7 +1075,7 @@ dependencies = [\n \n [[package]]\n name = \"rustzx-test\"\n-version = \"0.15.0\"\n+version = \"0.16.0\"\n dependencies = [\n  \"anyhow\",\n  \"base64\",\n@@ -1178,7 +1092,7 @@ dependencies = [\n \n [[package]]\n name = \"rustzx-utils\"\n-version = \"0.15.0\"\n+version = \"0.16.0\"\n dependencies = [\n  \"flate2\",\n  \"log\",\n@@ -1187,7 +1101,7 @@ dependencies = [\n \n [[package]]\n name = \"rustzx-z80\"\n-version = \"0.15.0\"\n+version = \"0.16.0\"\n dependencies = [\n  \"paste\",\n ]\n@@ -1281,12 +1195,6 @@ version = \"0.5.2\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"6e63cff320ae2c57904679ba7cb63280a3dc4613885beafb148ee7bf9aa9042d\"\n \n-[[package]]\n-name = \"stdweb\"\n-version = \"0.1.3\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"ef5430c8e36b713e13b48a9f709cc21e046723fe44ce34587b73a830203b533e\"\n-\n [[package]]\n name = \"strsim\"\n version = \"0.8.0\"\n@@ -1299,12 +1207,6 @@ version = \"0.9.3\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"6446ced80d6c486436db5c078dde11a9f73d42b57fb273121e160b84f63d894c\"\n \n-[[package]]\n-name = \"strsim\"\n-version = \"0.10.0\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623\"\n-\n [[package]]\n name = \"structopt\"\n version = \"0.3.21\"\n@@ -1352,13 +1254,13 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.70\"\n+version = \"1.0.109\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"b9505f307c872bab8eb46f77ae357c8eba1fdacead58ee5a850116b1d7f82883\"\n+checksum = \"72b64191b275b66ffe2469e8af2c1cfe3bafa67b529ead792a6d0160888b4237\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"unicode-xid\",\n+ \"unicode-ident\",\n ]\n \n [[package]]\n@@ -1443,6 +1345,12 @@ version = \"1.13.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"879f6906492a7cd215bfa4cf595b600146ccfac0c79bcbd1f3000162af5e8b06\"\n \n+[[package]]\n+name = \"unicode-ident\"\n+version = \"1.0.8\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"e5464a87b239f13a63a501f2701565754bae92d243d4bb7eb12f6d57d2269bf4\"\n+\n [[package]]\n name = \"unicode-segmentation\"\n version = \"1.7.1\"\n@@ -1455,12 +1363,6 @@ version = \"0.1.8\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"9337591893a19b88d8d87f2cec1e73fad5cdfd10e5a6f349f498ad6ea2ffb1e3\"\n \n-[[package]]\n-name = \"unicode-xid\"\n-version = \"0.2.1\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"f7fe0bb3479651439c9112f72b6c505038574c9fbb575ed1bf3b797fa39dd564\"\n-\n [[package]]\n name = \"vec_map\"\n version = \"0.8.2\"\n@@ -1481,7 +1383,7 @@ checksum = \"5fecdca9a5291cc2b8dcf7dc02453fee791a280f3743cb0905f8822ae463b3fe\"\n \n [[package]]\n name = \"vtx\"\n-version = \"0.15.0\"\n+version = \"0.16.0\"\n dependencies = [\n  \"aym\",\n  \"byteorder\",\n@@ -1495,7 +1397,7 @@ dependencies = [\n \n [[package]]\n name = \"vtx-bin\"\n-version = \"0.15.0\"\n+version = \"0.16.0\"\n dependencies = [\n  \"anyhow\",\n  \"structopt\",\n@@ -1522,9 +1424,9 @@ checksum = \"1a143597ca7c7793eff794def352d41792a93c481eb1042423ff7ff72ba2c31f\"\n \n [[package]]\n name = \"wasm-bindgen\"\n-version = \"0.2.78\"\n+version = \"0.2.84\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"632f73e236b219150ea279196e54e610f5dbafa5d61786303d4da54f84e47fce\"\n+checksum = \"31f8dcbc21f30d9b8f2ea926ecb58f6b91192c17e9d33594b3df58b2007ca53b\"\n dependencies = [\n  \"cfg-if\",\n  \"wasm-bindgen-macro\",\n@@ -1532,24 +1434,36 @@ dependencies = [\n \n [[package]]\n name = \"wasm-bindgen-backend\"\n-version = \"0.2.78\"\n+version = \"0.2.84\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"a317bf8f9fba2476b4b2c85ef4c4af8ff39c3c7f0cdfeed4f82c34a880aa837b\"\n+checksum = \"95ce90fd5bcc06af55a641a86428ee4229e44e07033963a2290a8e241607ccb9\"\n dependencies = [\n  \"bumpalo\",\n- \"lazy_static\",\n  \"log\",\n+ \"once_cell\",\n  \"proc-macro2\",\n  \"quote\",\n  \"syn\",\n  \"wasm-bindgen-shared\",\n ]\n \n+[[package]]\n+name = \"wasm-bindgen-futures\"\n+version = \"0.4.34\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"f219e0d211ba40266969f6dbdd90636da12f75bee4fc9d6c23d1260dadb51454\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"js-sys\",\n+ \"wasm-bindgen\",\n+ \"web-sys\",\n+]\n+\n [[package]]\n name = \"wasm-bindgen-macro\"\n-version = \"0.2.78\"\n+version = \"0.2.84\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"d56146e7c495528bf6587663bea13a8eb588d39b36b679d83972e1a2dbbdacf9\"\n+checksum = \"4c21f77c0bedc37fd5dc21f897894a5ca01e7bb159884559461862ae90c0b4c5\"\n dependencies = [\n  \"quote\",\n  \"wasm-bindgen-macro-support\",\n@@ -1557,9 +1471,9 @@ dependencies = [\n \n [[package]]\n name = \"wasm-bindgen-macro-support\"\n-version = \"0.2.78\"\n+version = \"0.2.84\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"7803e0eea25835f8abdc585cd3021b3deb11543c6fe226dcd30b228857c5c5ab\"\n+checksum = \"2aff81306fcac3c7515ad4e177f521b5c9a15f2b08f4e32d823066102f35a5f6\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1570,9 +1484,9 @@ dependencies = [\n \n [[package]]\n name = \"wasm-bindgen-shared\"\n-version = \"0.2.78\"\n+version = \"0.2.84\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"0237232789cf037d5480773fe568aac745bfe2afbc11a863e97901780a6b47cc\"\n+checksum = \"0046fef7e28c3804e5e38bfa31ea2a0f73905319b677e57ebe37e49358989b5d\"\n \n [[package]]\n name = \"wav\"\n@@ -1623,3 +1537,78 @@ name = \"winapi-x86_64-pc-windows-gnu\"\n version = \"0.4.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n+\n+[[package]]\n+name = \"windows\"\n+version = \"0.44.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"9e745dab35a0c4c77aa3ce42d595e13d2003d6902d6b08c9ef5fc326d08da12b\"\n+dependencies = [\n+ \"windows-targets\",\n+]\n+\n+[[package]]\n+name = \"windows-sys\"\n+version = \"0.45.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0\"\n+dependencies = [\n+ \"windows-targets\",\n+]\n+\n+[[package]]\n+name = \"windows-targets\"\n+version = \"0.42.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071\"\n+dependencies = [\n+ \"windows_aarch64_gnullvm\",\n+ \"windows_aarch64_msvc\",\n+ \"windows_i686_gnu\",\n+ \"windows_i686_msvc\",\n+ \"windows_x86_64_gnu\",\n+ \"windows_x86_64_gnullvm\",\n+ \"windows_x86_64_msvc\",\n+]\n+\n+[[package]]\n+name = \"windows_aarch64_gnullvm\"\n+version = \"0.42.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8\"\n+\n+[[package]]\n+name = \"windows_aarch64_msvc\"\n+version = \"0.42.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43\"\n+\n+[[package]]\n+name = \"windows_i686_gnu\"\n+version = \"0.42.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f\"\n+\n+[[package]]\n+name = \"windows_i686_msvc\"\n+version = \"0.42.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnu\"\n+version = \"0.42.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnullvm\"\n+version = \"0.42.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3\"\n+\n+[[package]]\n+name = \"windows_x86_64_msvc\"\n+version = \"0.42.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+checksum = \"9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0\"\ndiff --git a\/Cargo.toml b\/Cargo.toml\nindex 42589d1..0abb881 100644\n--- a\/Cargo.toml\n+++ b\/Cargo.toml\n@@ -9,3 +9,20 @@ members = [\n     \"vtx\",\n     \"vtx\/vtx-bin\",\n ]\n+\n+[workspace.package]\n+version = \"0.16.0\"\n+license = \"MIT\"\n+edition = \"2021\"\n+authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n+repository = \"https:\/\/github.com\/rustzx\/rustzx\"\n+\n+\n+\n+\n+[workspace.dependencies]\n+aym = { path = \"aym\" }\n+rustzx-core = { path = \"rustzx-core\" }\n+rustzx-utils = { path = \"rustzx-utils\" }\n+rustzx-z80 = { path = \"rustzx-z80\" }\n+vtx = { path = \"vtx\" }\ndiff --git a\/README.md b\/README.md\nindex 529a689..411e0db 100644\n--- a\/README.md\n+++ b\/README.md\n@@ -36,6 +36,10 @@ ZX Spectrum emulator written in Rust\n     - Global allocator is still needed, but all dynamic\n        allocations were minimized\n     - All resource-heavy features are configurable via cargo `features`\n+- Obscure Z80 features emulation:\n+    - `WZ\/memptr` register (`F3\/F5` flags obscure behavior in `BIT n, (HL)`)\n+    - `Q` register (`F3\/F5` flags obscure behavior in `SCF` and `CCF`)\n+    - Block instruction flags [oddities](https:\/\/github.com\/MrKWatkins\/ZXSpectrumNextTests\/tree\/develop\/Tests\/ZX48_ZX128\/Z80BlockInstructionFlags) (`LDxR`\/`CPxR`\/`INxR`\/`OTxR`)\n \n ## Install\n 1. Sure that you have C compiller and CMake to\n@@ -118,6 +122,7 @@ defails about ZX Spectrum.\n - [FUSE](http:\/\/fuse-emulator.sourceforge.net\/) emulator source for finding out correct timings\n - [YAZE test suite](https:\/\/www.mathematik.uni-ulm.de\/users\/ag\/yaze-ag\/)\n - [z80test test suite](https:\/\/github.com\/raxoft\/z80test)\n+- [ROM routines](https:\/\/skoolkid.github.io\/rom\/maps\/routines.html)\n \n ## ROM's\n Emulator contains ROMs, created by by Sinclair Research Ltd (now owned by Amstrad plc),\ndiff --git a\/aym\/Cargo.toml b\/aym\/Cargo.toml\nindex 8102448..b4f9780 100644\n--- a\/aym\/Cargo.toml\n+++ b\/aym\/Cargo.toml\n@@ -1,12 +1,14 @@\n [package]\n name = \"aym\"\n-version = \"0.15.1\"\n description = \"AY\/YM sound chip emulation library\"\n-authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n-license = \"MIT\"\n-edition = \"2018\"\n keywords = [\"ay\", \"sound\", \"emulator\", \"no_std\"]\n-repository = \"https:\/\/github.com\/rustzx\/rustzx\"\n+\n+version.workspace = true\n+license.workspace = true\n+edition.workspace = true\n+authors.workspace = true\n+repository.workspace = true\n+\n \n [dependencies]\n num-traits = { version = \"0.2\", default-features = false }\ndiff --git a\/aym\/src\/lib.rs b\/aym\/src\/lib.rs\nindex e6f4daf..617bb66 100644\n--- a\/aym\/src\/lib.rs\n+++ b\/aym\/src\/lib.rs\n@@ -9,7 +9,7 @@ use num_traits::Num;\n \/\/\/ AY\/YM Sound chip register count\n pub const AY_REGISTER_COUNT: usize = 14;\n \n-\/\/\/ Samples, returned by `aym` implemnt this trait; It allows to correctly convert\n+\/\/\/ Samples, returned by `aym` implement this trait; It allows to correctly convert\n \/\/\/ the sound sample between different types. e.g.\n \/\/\/ [to_f32](AySample::to_f32)\/[to_f64](AySample::to_f64) will always return sample in the\n \/\/\/ correct range `[-1.0; 1.0]`, while for example [to_i8](AySample::to_i8)\ndiff --git a\/rustzx-core\/Cargo.toml b\/rustzx-core\/Cargo.toml\nindex 209a286..15a470f 100644\n--- a\/rustzx-core\/Cargo.toml\n+++ b\/rustzx-core\/Cargo.toml\n@@ -1,12 +1,13 @@\n [package]\n name = \"rustzx-core\"\n-version = \"0.15.0\"\n-authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n-description = \"ZX Spectum emulator core library\"\n-repository = \"https:\/\/github.com\/rustzx\/rustzx\"\n+description = \"ZX Spectrum emulator core library\"\n keywords = [\"emulator\", \"game\", \"z80\", \"no_std\"]\n-license = \"MIT\"\n-edition = \"2018\"\n+\n+version.workspace = true\n+license.workspace = true\n+edition.workspace = true\n+authors.workspace = true\n+repository.workspace = true\n \n [features]\n default = []\n@@ -23,6 +24,6 @@ lazy_static = { version = \"1.1\", features = [\"spin_no_std\"] }\n displaydoc = { version = \"0.2\", default-features = false }\n from_variants = \"0.6\"\n enum_dispatch = \"0.3\"\n-aym = { version = \"0.15\", path = \"..\/aym\", optional = true }\n-rustzx-z80 = { version = \"0.15\", path = \"..\/rustzx-z80\" }\n+aym = { workspace = true, optional = true }\n+rustzx-z80 = { workspace = true }\n strum = { version = \"0.22\", default-features = false, features = [\"derive\"], optional = true }\ndiff --git a\/rustzx-core\/src\/emulator\/fastload\/tap.rs b\/rustzx-core\/src\/emulator\/fastload\/tap.rs\nindex 72a39aa..28e99f6 100644\n--- a\/rustzx-core\/src\/emulator\/fastload\/tap.rs\n+++ b\/rustzx-core\/src\/emulator\/fastload\/tap.rs\n@@ -4,7 +4,7 @@ use rustzx_z80::{RegName16, Z80Bus, FLAG_CARRY, FLAG_ZERO};\n \n pub fn fast_load_tap<H: Host>(emulator: &mut Emulator<H>) -> Result<()> {\n     \/\/ So, at current moment we at 0x056C in 48K Rom.\n-    \/\/ AF contains some garbage. so we need to swap if wtih A'F'\n+    \/\/ AF contains some garbage. so we need to swap if with A'F'\n     emulator.cpu.regs.swap_af_alt();\n     \/\/ now we have type of block at A and flags before LD-BYTES at F\n     let mut f = emulator.cpu.regs.get_flags();\ndiff --git a\/rustzx-core\/src\/emulator\/mod.rs b\/rustzx-core\/src\/emulator\/mod.rs\nindex 54efe48..248bd06 100644\n--- a\/rustzx-core\/src\/emulator\/mod.rs\n+++ b\/rustzx-core\/src\/emulator\/mod.rs\n@@ -1,5 +1,6 @@\n \/\/! Platform-independent high-level Emulator interaction module\n mod fastload;\n+pub mod poke;\n mod screenshot;\n mod snapshot;\n \n@@ -33,6 +34,25 @@ use crate::zx::sound::sample::SoundSample;\n #[cfg(feature = \"autoload\")]\n use crate::{host::BufferCursor, zx::machine::ZXMachine};\n \n+\/\/\/ Represents emulator stop reason\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum EmulationStopReason {\n+    \/\/\/ Requested frames count have been emulated successfully\n+    Completed,\n+    \/\/\/ Emulation time limit has been reached\n+    Timeout,\n+    \/\/\/ Emulator has reached breakpoint address\n+    Breakpoint,\n+}\n+\n+\/\/\/ Represents emulator emulation result\n+pub struct EmulationInfo {\n+    \/\/\/ Emulation duration in emulated time (not real time)\n+    pub duration: Duration,\n+    \/\/\/ Emulation stop reason, see [EmulationStopReason]\n+    pub stop_reason: EmulationStopReason,\n+}\n+\n \/\/\/ Represents main Emulator structure\n pub struct Emulator<H: Host> {\n     settings: RustzxSettings,\n@@ -167,7 +187,7 @@ impl<H: Host> Emulator<H> {\n     }\n \n     \/\/\/ Rewinds tape. May return error if underlying tape asset failed to\n-    \/\/\/ perform seek operaion to go back to the the beginning of the tape\n+    \/\/\/ perform seek operation to go back to the the beginning of the tape\n     pub fn rewind_tape(&mut self) -> Result<()> {\n         self.controller.tape.rewind()\n     }\n@@ -189,6 +209,21 @@ impl<H: Host> Emulator<H> {\n         self.controller.io_extender.as_mut()\n     }\n \n+    \/\/\/ Sets [Host::DebugInterface] for the emulator instance\n+    pub fn set_debug_interface(&mut self, debug_interface: H::DebugInterface) {\n+        self.controller.debug_interface = Some(debug_interface);\n+    }\n+\n+    \/\/\/ Returns current [Host::DebugInterface] instance\n+    pub fn debug_interface(&mut self) -> Option<&mut H::DebugInterface> {\n+        self.controller.debug_interface.as_mut()\n+    }\n+\n+    \/\/\/ Reads byte from memory\n+    pub fn peek(&self, addr: u16) -> u8 {\n+        self.controller.memory.read(addr)\n+    }\n+\n     pub fn border_color(&self) -> ZXColor {\n         self.controller.border_color\n     }\n@@ -228,18 +263,26 @@ impl<H: Host> Emulator<H> {\n         self.controller.mixer.pop()\n     }\n \n-    fn process_events(&mut self, event: EmulationEvents) -> Result<()> {\n-        if event.contains(EmulationEvents::TAPE_FAST_LOAD_TRIGGER_DETECTED)\n-            && self.controller.tape.can_fast_load()\n-            && self.fast_load\n-        {\n+    fn process_fast_load_event(&mut self) -> Result<()> {\n+        if self.controller.tape.can_fast_load() && self.fast_load {\n             fastload::tap::fast_load_tap(self)?;\n         }\n         Ok(())\n     }\n \n-    \/\/\/ Perform emulatio up to `emulation_limit` duration, returns actuall elapsed duration\n-    pub fn emulate_frames(&mut self, emulation_limit: Duration) -> Result<Duration> {\n+    \/\/\/ Execute `poke::Poke` action on the emulator\n+    pub fn execute_poke(&mut self, poke: impl poke::Poke) {\n+        for action in poke.actions().iter().copied() {\n+            match action {\n+                poke::PokeAction::Mem { addr, value } => {\n+                    self.controller.memory.force_write(addr, value);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/\/ Perform emulatio up to `emulation_limit` duration, returns actual elapsed duration\n+    pub fn emulate_frames(&mut self, emulation_limit: Duration) -> Result<EmulationInfo> {\n         let stopwatch = H::EmulationStopwatch::new();\n         \/\/ frame loop\n         loop {\n@@ -251,15 +294,27 @@ impl<H: Host> Emulator<H> {\n                 if let Some(e) = self.controller.take_last_emulation_error() {\n                     return Err(e);\n                 }\n-                if !self.controller.events().is_empty() {\n-                    self.process_events(self.controller.events())?;\n-                    self.controller.clear_events();\n+\n+                let events = self.controller.take_events();\n+                if !events.is_empty() {\n+                    if events.contains(EmulationEvents::TAPE_FAST_LOAD_TRIGGER_DETECTED) {\n+                        self.process_fast_load_event()?;\n+                    }\n+                    if events.contains(EmulationEvents::PC_BREAKPOINT) {\n+                        return Ok(EmulationInfo {\n+                            duration: stopwatch.measure(),\n+                            stop_reason: EmulationStopReason::Breakpoint,\n+                        });\n+                    }\n                 }\n \n                 match self.mode {\n                     EmulationMode::FrameCount(frames) => {\n                         if self.controller.frames_count() >= frames {\n-                            return Ok(stopwatch.measure());\n+                            return Ok(EmulationInfo {\n+                                duration: stopwatch.measure(),\n+                                stop_reason: EmulationStopReason::Completed,\n+                            });\n                         };\n                     }\n                     EmulationMode::Max => {\n@@ -271,7 +326,10 @@ impl<H: Host> Emulator<H> {\n             }\n             \/\/ if time is bigger than `max_time` then stop emulation cycle\n             if stopwatch.measure() > emulation_limit {\n-                return Ok(stopwatch.measure());\n+                return Ok(EmulationInfo {\n+                    duration: stopwatch.measure(),\n+                    stop_reason: EmulationStopReason::Timeout,\n+                });\n             }\n         }\n     }\ndiff --git a\/rustzx-core\/src\/emulator\/poke.rs b\/rustzx-core\/src\/emulator\/poke.rs\nnew file mode 100644\nindex 0000000..b154d45\n--- \/dev\/null\n+++ b\/rustzx-core\/src\/emulator\/poke.rs\n@@ -0,0 +1,35 @@\n+\/\/! Pokes are used to modify internal emulator state such as memory, registers, etc.\n+\n+\/\/\/ Action to perform on emulator state\n+#[derive(Clone, Copy)]\n+pub enum PokeAction {\n+    Mem { addr: u16, value: u8 },\n+}\n+\n+impl PokeAction {\n+    \/\/\/ Creates new memory poke action\n+    pub const fn mem(addr: u16, value: u8) -> Self {\n+        Self::Mem { addr, value }\n+    }\n+}\n+\n+pub trait Poke {\n+    \/\/\/ Returns list of actions to perform on emulator state\n+    fn actions(&self) -> &[PokeAction];\n+}\n+\n+\/\/\/ Poke which disables message and enter key prompt in 48K ROM when scrolling screen in BASIC mode\n+pub struct DisableScrollMessageRom48;\n+impl Poke for DisableScrollMessageRom48 {\n+    fn actions(&self) -> &[PokeAction] {\n+        \/\/ Injects `JP 0x0CD2` at 0x0C88\n+        \/\/ https:\/\/skoolkid.github.io\/rom\/asm\/0C55.html\n+        const ACTIONS: &[PokeAction] = &[\n+            PokeAction::mem(0x0C88, 0xC3),\n+            PokeAction::mem(0x0C89, 0xD2),\n+            PokeAction::mem(0x0C8A, 0x0C),\n+        ];\n+\n+        ACTIONS\n+    }\n+}\ndiff --git a\/rustzx-core\/src\/host\/io.rs b\/rustzx-core\/src\/host\/io.rs\nindex ce33612..ce6a917 100644\n--- a\/rustzx-core\/src\/host\/io.rs\n+++ b\/rustzx-core\/src\/host\/io.rs\n@@ -96,7 +96,7 @@ pub trait DataRecorder {\n     \/\/\/ destination asset was reached (e.g. buffer filled)\n     fn write(&mut self, buf: &[u8]) -> Result<usize>;\n \n-    \/\/\/ Writes all bytes to the destiantion or returns\n+    \/\/\/ Writes all bytes to the destination or returns\n     \/\/\/ [IoError::WriteZero] if destination refused to accept\n     \/\/\/ more bytes\n     fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\ndiff --git a\/rustzx-core\/src\/host\/mod.rs b\/rustzx-core\/src\/host\/mod.rs\nindex 4768904..b544a68 100644\n--- a\/rustzx-core\/src\/host\/mod.rs\n+++ b\/rustzx-core\/src\/host\/mod.rs\n@@ -57,13 +57,13 @@ pub trait IoExtender {\n     \/\/\/ Read byte value from io extender\n     fn read(&mut self, port: u16) -> u8;\n     \/\/\/ Return true if io externder can process\n-    \/\/\/ incomming read\/write operation for a\n+    \/\/\/ incoming read\/write operation for a\n     \/\/\/ given port\n     fn extends_port(&self, port: u16) -> bool;\n }\n \n-\/\/\/ Does not extend any IO\n-pub struct StubIoExtender {}\n+\/\/\/ IO externder which does nothing\n+pub struct StubIoExtender;\n \n impl IoExtender for StubIoExtender {\n     fn write(&mut self, _: u16, _: u8) {}\n@@ -77,6 +77,21 @@ impl IoExtender for StubIoExtender {\n     }\n }\n \n+\/\/\/ Allows to externd RustZX emulator with custom debug logic\n+pub trait DebugInterface {\n+    \/\/\/ Returns true if breakpoint at given address is set and emulation should be stopped\n+    fn check_pc_breakpoint(&mut self, addr: u16) -> bool;\n+}\n+\n+\/\/\/ Debug interface which does nothing\n+pub struct StubDebugInterface;\n+\n+impl DebugInterface for StubDebugInterface {\n+    fn check_pc_breakpoint(&mut self, _addr: u16) -> bool {\n+        false\n+    }\n+}\n+\n \/\/\/ Represents set of required types for emulator implementation\n \/\/\/ based on `rustzx-core`.\n pub trait Host {\n@@ -91,4 +106,6 @@ pub trait Host {\n     type EmulationStopwatch: Stopwatch;\n     \/\/\/ RustZX debug port implementation\n     type IoExtender: IoExtender;\n+    \/\/\/ Debug interface logic (e.g. breakpoints)\n+    type DebugInterface: DebugInterface;\n }\ndiff --git a\/rustzx-core\/src\/lib.rs b\/rustzx-core\/src\/lib.rs\nindex 5a571ee..408c8f7 100644\n--- a\/rustzx-core\/src\/lib.rs\n+++ b\/rustzx-core\/src\/lib.rs\n@@ -8,7 +8,7 @@ pub mod error;\n pub mod host;\n pub mod zx;\n \n-pub use emulator::Emulator;\n+pub use emulator::{poke, EmulationInfo, EmulationStopReason, Emulator};\n pub use settings::RustzxSettings;\n pub use utils::EmulationMode;\n \ndiff --git a\/rustzx-core\/src\/zx\/constants.rs b\/rustzx-core\/src\/zx\/constants.rs\nindex 32abbd1..b3bd13f 100644\n--- a\/rustzx-core\/src\/zx\/constants.rs\n+++ b\/rustzx-core\/src\/zx\/constants.rs\n@@ -15,7 +15,7 @@ pub const FPS: usize = 50;\n pub(crate) const BITMAP_MAX_REL: u16 = 0x17FF;\n pub(crate) const ATTR_BASE_REL: u16 = 0x1800;\n pub(crate) const ATTR_MAX_REL: u16 = 0x1AFF;\n-\/\/\/ on all spectrums theese values are fixed\n+\/\/\/ on all spectrums these values are fixed\n pub(crate) const CLOCKS_PER_COL: usize = 4;\n #[cfg(feature = \"precise-border\")]\n pub(crate) const PIXELS_PER_CLOCK: usize = 2;\ndiff --git a\/rustzx-core\/src\/zx\/controller.rs b\/rustzx-core\/src\/zx\/controller.rs\nindex 2245083..fd9c3fe 100644\n--- a\/rustzx-core\/src\/zx\/controller.rs\n+++ b\/rustzx-core\/src\/zx\/controller.rs\n@@ -1,7 +1,7 @@\n-\/\/! Contains ZX Spectrum System contrller (like ula or so) of emulator\n+\/\/! Contains ZX Spectrum System controller (like ula or so) of emulator\n use crate::{\n     error::Error,\n-    host::{Host, HostContext, IoExtender},\n+    host::{DebugInterface, Host, HostContext, IoExtender},\n     settings::RustzxSettings,\n     utils::screen::bitmap_line_addr,\n     zx::{\n@@ -30,7 +30,7 @@ use crate::zx::video::border::ZXBorder;\n \n \/\/\/ ZX System controller\n pub(crate) struct ZXController<H: Host> {\n-    \/\/ parts of ZX Spectum.\n+    \/\/ parts of ZX Spectrum.\n     pub machine: ZXMachine,\n     pub memory: ZXMemory,\n     pub screen: ZXScreen<H::FrameBuffer>,\n@@ -40,6 +40,7 @@ pub(crate) struct ZXController<H: Host> {\n     pub kempston: Option<KempstonJoy>,\n     pub mouse: Option<KempstonMouse>,\n     pub io_extender: Option<H::IoExtender>,\n+    pub debug_interface: Option<H::DebugInterface>,\n     #[cfg(feature = \"sound\")]\n     pub mixer: ZXMixer,\n     pub keyboard: [u8; 8],\n@@ -50,7 +51,7 @@ pub(crate) struct ZXController<H: Host> {\n     pub border_color: ZXColor,\n     \/\/ clocls count from frame start\n     frame_clocks: usize,\n-    \/\/ frames count, which passed during emulation invokation\n+    \/\/ frames count, which passed during emulation invocation\n     passed_frames: usize,\n     events: EmulationEvents,\n     paging_enabled: bool,\n@@ -108,6 +109,7 @@ impl<H: Host> ZXController<H> {\n             kempston,\n             mouse,\n             io_extender: None,\n+            debug_interface: None,\n             #[cfg(feature = \"sound\")]\n             mixer,\n             keyboard: [0xFF; 8],\n@@ -312,14 +314,9 @@ impl<H: Host> ZXController<H> {\n         self.mixer.new_frame();\n     }\n \n-    \/\/\/ Clears all detected\n-    pub fn clear_events(&mut self) {\n-        self.events.clear();\n-    }\n-\n-    \/\/\/ Returns last events\n-    pub fn events(&self) -> EmulationEvents {\n-        self.events\n+    \/\/\/ Collects all events from the last emulation step\n+    pub fn take_events(&mut self) -> EmulationEvents {\n+        self.events.take()\n     }\n \n     \/\/\/ Returns true if all frame clocks has been passed\n@@ -433,6 +430,11 @@ impl<H: Host> Z80Bus for ZXController<H> {\n                 self.events |= EmulationEvents::TAPE_FAST_LOAD_TRIGGER_DETECTED;\n             }\n         }\n+        if let Some(debug) = &mut self.debug_interface {\n+            if debug.check_pc_breakpoint(addr) {\n+                self.events |= EmulationEvents::PC_BREAKPOINT;\n+            }\n+        }\n     }\n \n     \/\/\/ read data without taking onto account contention\n@@ -450,7 +452,7 @@ impl<H: Host> Z80Bus for ZXController<H> {\n         }\n     }\n \n-    \/\/\/ Cahnges internal state on clocks count change (emualtion processing)\n+    \/\/\/ Changes internal state on clocks count change (emulation processing)\n     fn wait_internal(&mut self, clk: usize) {\n         self.frame_clocks += clk;\n         if let Err(e) = self.tape.process_clocks(clk) {\ndiff --git a\/rustzx-core\/src\/zx\/events.rs b\/rustzx-core\/src\/zx\/events.rs\nindex 7a5951b..b869fb4 100644\n--- a\/rustzx-core\/src\/zx\/events.rs\n+++ b\/rustzx-core\/src\/zx\/events.rs\n@@ -1,14 +1,20 @@\n use bitflags::bitflags;\n \n bitflags! {\n+    \/\/\/ Emulation events\n     #[derive(Default)]\n     pub struct EmulationEvents: u8 {\n+        \/\/\/ Set when tape fast load trigger is detected\n         const TAPE_FAST_LOAD_TRIGGER_DETECTED = 0b00000001;\n+        \/\/\/ Set when PC breakpoint is reached\n+        const PC_BREAKPOINT = 0b00000010;\n     }\n }\n \n impl EmulationEvents {\n-    pub fn clear(&mut self) {\n+    pub fn take(&mut self) -> Self {\n+        let events = *self;\n         self.bits = 0;\n+        events\n     }\n }\ndiff --git a\/rustzx-core\/src\/zx\/memory.rs b\/rustzx-core\/src\/zx\/memory.rs\nindex a8604a1..124ecc7 100644\n--- a\/rustzx-core\/src\/zx\/memory.rs\n+++ b\/rustzx-core\/src\/zx\/memory.rs\n@@ -42,7 +42,7 @@ pub struct ZXMemory {\n }\n \n impl ZXMemory {\n-    \/\/\/ Returns new Memory with coresponding rom and ram types\n+    \/\/\/ Returns new Memory with corresponding rom and ram types\n     pub fn new(rom_type: RomType, ram_type: RamType) -> ZXMemory {\n         let ram_size;\n         let mem_map;\n@@ -70,20 +70,27 @@ impl ZXMemory {\n \n     \/\/\/ Returns value form memory\n     pub fn read(&self, addr: u16) -> u8 {\n-        let page = self.map[(addr as usize) \/ PAGE_SIZE];\n-        let addr_rel = addr as usize % PAGE_SIZE;\n+        let (page, offset) = self.paged_address(addr);\n         match page {\n-            Page::Rom(page) => self.rom[(page as usize) * PAGE_SIZE + addr_rel],\n-            Page::Ram(page) => self.ram[(page as usize) * PAGE_SIZE + addr_rel],\n+            Page::Rom(page) => self.rom[(page as usize) * PAGE_SIZE + offset],\n+            Page::Ram(page) => self.ram[(page as usize) * PAGE_SIZE + offset],\n         }\n     }\n \n-    \/\/\/ Writes value to memory\n+    \/\/\/ Writes value to writable memory\n     pub fn write(&mut self, addr: u16, value: u8) {\n-        let page = self.map[(addr as usize) \/ PAGE_SIZE];\n-        let addr_rel = addr as usize % PAGE_SIZE;\n+        let (page, offset) = self.paged_address(addr);\n         if let Page::Ram(page) = page {\n-            self.ram[(page as usize) * PAGE_SIZE + addr_rel] = value;\n+            self.ram[(page as usize) * PAGE_SIZE + offset] = value;\n+        }\n+    }\n+\n+    \/\/\/ Writes to memory space, overriding even ROM routines. Useful for testing and ROM poke's\n+    pub(crate) fn force_write(&mut self, addr: u16, value: u8) {\n+        let (page, offset) = self.paged_address(addr);\n+        match page {\n+            Page::Ram(page) => self.ram[(page as usize) * PAGE_SIZE + offset] = value,\n+            Page::Rom(page) => self.rom[(page as usize) * PAGE_SIZE + offset] = value,\n         }\n     }\n \n@@ -142,4 +149,11 @@ impl ZXMemory {\n         let shift = page as usize * PAGE_SIZE;\n         &self.ram[shift..shift + PAGE_SIZE]\n     }\n+\n+    \/\/\/ Calculates [Page] and local offset from memory address\n+    fn paged_address(&self, addr: u16) -> (Page, usize) {\n+        let page = self.map[(addr as usize) \/ PAGE_SIZE];\n+        let offset = addr as usize % PAGE_SIZE;\n+        (page, offset)\n+    }\n }\ndiff --git a\/rustzx-core\/src\/zx\/mouse\/kempston.rs b\/rustzx-core\/src\/zx\/mouse\/kempston.rs\nindex 4f1eda1..db0e1b3 100644\n--- a\/rustzx-core\/src\/zx\/mouse\/kempston.rs\n+++ b\/rustzx-core\/src\/zx\/mouse\/kempston.rs\n@@ -1,7 +1,7 @@\n const WHEEL_MASK: u8 = 0xF0;\n const WHEEL_SHIFT: usize = 4;\n \n-\/\/ non_exhaustive allows to restrict struct instantiation only to `Default::deafault`\n+\/\/ non_exhaustive allows to restrict struct instantiation only to `Default::defaault`\n #[non_exhaustive]\n pub(crate) struct KempstonMouse {\n     pub buttons_port: u8,\ndiff --git a\/rustzx-core\/src\/zx\/sound\/beeper.rs b\/rustzx-core\/src\/zx\/sound\/beeper.rs\nindex d4679fd..ede8d4f 100644\n--- a\/rustzx-core\/src\/zx\/sound\/beeper.rs\n+++ b\/rustzx-core\/src\/zx\/sound\/beeper.rs\n@@ -20,7 +20,7 @@ impl SampleGenerator<f64> for ZXBeeper {\n         \/\/ - Beeper intentionally made produce only positive half-wave 0..0.5\n         \/\/ range instead of -0.25..0.25) because of current emulator lack of\n         \/\/ dc filtering.\n-        \/\/ - Beeper only produces a quater of available sample\n+        \/\/ - Beeper only produces a quarter of available sample\n         \/\/ range because relatively to AY chip, square wave of a beeper is\n         \/\/ too loud\n \ndiff --git a\/rustzx-core\/src\/zx\/sound\/mixer.rs b\/rustzx-core\/src\/zx\/sound\/mixer.rs\nindex fce6a40..ffb7732 100644\n--- a\/rustzx-core\/src\/zx\/sound\/mixer.rs\n+++ b\/rustzx-core\/src\/zx\/sound\/mixer.rs\n@@ -1,4 +1,4 @@\n-\/\/! Module implemets zx spectrum audio devices mixer\n+\/\/! Module implements zx spectrum audio devices mixer\n use crate::zx::{\n     constants::FPS,\n     sound::{\ndiff --git a\/rustzx-core\/src\/zx\/sound\/sample.rs b\/rustzx-core\/src\/zx\/sound\/sample.rs\nindex fb2a9d1..49a883f 100644\n--- a\/rustzx-core\/src\/zx\/sound\/sample.rs\n+++ b\/rustzx-core\/src\/zx\/sound\/sample.rs\n@@ -40,7 +40,7 @@ where\n         self\n     }\n \n-    \/\/\/ multiplies self channels separatly\n+    \/\/\/ multiplies self channels separately\n     pub fn mul(&mut self, val_left: T, val_right: T) -> &mut Self {\n         self.left *= val_left;\n         self.right *= val_right;\ndiff --git a\/rustzx-core\/src\/zx\/tape\/mod.rs b\/rustzx-core\/src\/zx\/tape\/mod.rs\nindex e17cc57..8386b66 100644\n--- a\/rustzx-core\/src\/zx\/tape\/mod.rs\n+++ b\/rustzx-core\/src\/zx\/tape\/mod.rs\n@@ -29,7 +29,7 @@ pub trait TapeImpl {\n     fn can_fast_load(&self) -> bool;\n     \/\/\/ Returns byte of current block or `None` if block has ended\n     fn next_block_byte(&mut self) -> Result<Option<u8>>;\n-    \/\/\/ Loads next block. Retruns false if end of the tape is reached\n+    \/\/\/ Loads next block. Returns false if end of the tape is reached\n     fn next_block(&mut self) -> Result<bool>;\n     \/\/\/ Returns current tape (`ear`) bit\n     fn current_bit(&self) -> bool;\ndiff --git a\/rustzx-core\/src\/zx\/tape\/tap.rs b\/rustzx-core\/src\/zx\/tape\/tap.rs\nindex 65a3e7e..482c75e 100644\n--- a\/rustzx-core\/src\/zx\/tape\/tap.rs\n+++ b\/rustzx-core\/src\/zx\/tape\/tap.rs\n@@ -32,7 +32,7 @@ pub struct Tap<A: LoadableAsset + SeekableAsset> {\n     state: TapeState,\n     prev_state: TapeState,\n     buffer: [u8; BUFFER_SIZE],\n-    bufer_offset: usize,\n+    buffer_offset: usize,\n     block_bytes_read: usize,\n     current_block_size: Option<usize>,\n     tape_ended: bool,\n@@ -50,7 +50,7 @@ impl<A: LoadableAsset + SeekableAsset> Tap<A> {\n             curr_bit: false,\n             curr_byte: 0x00,\n             buffer: [0u8; BUFFER_SIZE],\n-            bufer_offset: 0,\n+            buffer_offset: 0,\n             block_bytes_read: 0,\n             current_block_size: None,\n             delay: 0,\n@@ -76,13 +76,14 @@ impl<A: LoadableAsset + SeekableAsset> TapeImpl for Tap<A> {\n                 return Ok(None);\n             }\n \n-            let mut buffer_read_pos = self.block_bytes_read - self.bufer_offset;\n+            let mut buffer_read_pos = self.block_bytes_read - self.buffer_offset;\n \n             \/\/ Read new buffer if required\n             if buffer_read_pos >= BUFFER_SIZE {\n-                let bytes_to_read = (block_size - self.bufer_offset - BUFFER_SIZE).min(BUFFER_SIZE);\n+                let bytes_to_read =\n+                    (block_size - self.buffer_offset - BUFFER_SIZE).min(BUFFER_SIZE);\n                 self.asset.read_exact(&mut self.buffer[0..bytes_to_read])?;\n-                self.bufer_offset += BUFFER_SIZE;\n+                self.buffer_offset += BUFFER_SIZE;\n                 buffer_read_pos = 0;\n             }\n \n@@ -120,7 +121,7 @@ impl<A: LoadableAsset + SeekableAsset> TapeImpl for Tap<A> {\n         self.asset\n             .read_exact(&mut self.buffer[0..block_bytes_to_read])?;\n \n-        self.bufer_offset = 0;\n+        self.buffer_offset = 0;\n         self.block_bytes_read = 0;\n         self.current_block_size = Some(block_size);\n \n@@ -264,7 +265,7 @@ impl<A: LoadableAsset + SeekableAsset> TapeImpl for Tap<A> {\n         self.curr_bit = false;\n         self.curr_byte = 0x00;\n         self.block_bytes_read = 0;\n-        self.bufer_offset = 0;\n+        self.buffer_offset = 0;\n         self.current_block_size = None;\n         self.delay = 0;\n         self.asset.seek(SeekFrom::Start(0))?;\ndiff --git a\/rustzx-core\/src\/zx\/video\/border.rs b\/rustzx-core\/src\/zx\/video\/border.rs\nindex 0b9b7e2..dd42f18 100644\n--- a\/rustzx-core\/src\/zx\/video\/border.rs\n+++ b\/rustzx-core\/src\/zx\/video\/border.rs\n@@ -66,7 +66,7 @@ impl<FB: FrameBuffer> ZXBorder<FB> {\n     \/\/\/ and bool value, which signals end of frame\n     fn next_border_pixel(&self, clocks: usize) -> (usize, usize, bool) {\n         let specs = self.machine.specs();\n-        \/\/ begining of the first line (first pixel timing minus border lines\n+        \/\/ beginning of the first line (first pixel timing minus border lines\n         \/\/ minus left border columns)\n         let clocks_origin = specs.clocks_first_pixel\n             - 8 * BORDER_ROWS * specs.clocks_line\n@@ -82,7 +82,7 @@ impl<FB: FrameBuffer> ZXBorder<FB> {\n         \/\/ so, next pixel will be current + 2\n         let mut pixel = ((clocks % specs.clocks_line) + 1) * PIXELS_PER_CLOCK;\n         \/\/ if beam out of screen on horizontal pos.\n-        \/\/ pixel - 2 bacause we added 2 on prev line\n+        \/\/ pixel - 2 because we added 2 on prev line\n         if pixel - PIXELS_PER_CLOCK >= SCREEN_WIDTH {\n             \/\/ first pixel of next line\n             pixel = 0;\ndiff --git a\/rustzx-core\/src\/zx\/video\/screen.rs b\/rustzx-core\/src\/zx\/video\/screen.rs\nindex 80c74a0..6c50b07 100644\n--- a\/rustzx-core\/src\/zx\/video\/screen.rs\n+++ b\/rustzx-core\/src\/zx\/video\/screen.rs\n@@ -178,7 +178,7 @@ impl<FB: FrameBuffer> ZXScreen<FB> {\n                     );\n                 }\n             }\n-            \/\/ cahnge last block to current\n+            \/\/ change last block to current\n             self.last_blocks = blocks;\n         }\n     }\ndiff --git a\/rustzx-utils\/Cargo.toml b\/rustzx-utils\/Cargo.toml\nindex 3bba001..62f756d 100644\n--- a\/rustzx-utils\/Cargo.toml\n+++ b\/rustzx-utils\/Cargo.toml\n@@ -1,15 +1,16 @@\n [package]\n name = \"rustzx-utils\"\n-version = \"0.15.0\"\n-authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n description = \"Additional helpers for rustzx-core based emulators\"\n-repository = \"https:\/\/github.com\/rustzx\/rustzx\"\n keywords = [\"rustzx\", \"emulator\", \"no_std\"]\n-license = \"MIT\"\n-edition = \"2018\"\n+\n+version.workspace = true\n+license.workspace = true\n+edition.workspace = true\n+authors.workspace = true\n+repository.workspace = true\n \n [dependencies]\n-rustzx-core = { version = \"0.15\", path = \"..\/rustzx-core\" }\n+rustzx-core = { workspace = true }\n log = { version = \"0.4\", optional = true }\n flate2 = { version = \"1.0\", optional = true }\n \ndiff --git a\/rustzx-z80\/Cargo.toml b\/rustzx-z80\/Cargo.toml\nindex 74e239f..c4906bf 100644\n--- a\/rustzx-z80\/Cargo.toml\n+++ b\/rustzx-z80\/Cargo.toml\n@@ -1,12 +1,13 @@\n [package]\n name = \"rustzx-z80\"\n-version = \"0.15.0\"\n-authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n description = \"Z80 CPU emulator library\"\n-repository = \"https:\/\/github.com\/rustzx\/rustzx\"\n keywords = [\"emulator\", \"z80\", \"no_std\"]\n-license = \"MIT\"\n-edition = \"2018\"\n+\n+version.workspace = true\n+license.workspace = true\n+edition.workspace = true\n+authors.workspace = true\n+repository.workspace = true\n \n [dev-dependencies]\n paste = \"1.0\"\ndiff --git a\/rustzx-z80\/src\/bus.rs b\/rustzx-z80\/src\/bus.rs\nindex 826127f..31b354b 100644\n--- a\/rustzx-z80\/src\/bus.rs\n+++ b\/rustzx-z80\/src\/bus.rs\n@@ -40,7 +40,7 @@ pub trait Z80Bus {\n     fn read_io(&mut self, port: u16) -> u8;\n     \/\/ Method for writing to io port.\n     fn write_io(&mut self, port: u16, data: u8);\n-    \/\/\/ Provided metod to write word, LSB first (clk - clocks per byte)\n+    \/\/\/ Provided method to write word, LSB first (clk - clocks per byte)\n     fn write_word(&mut self, addr: u16, data: u16, clk: usize) {\n         let [l, h] = data.to_le_bytes();\n         self.write(addr, l, clk);\n@@ -53,7 +53,7 @@ pub trait Z80Bus {\n         u16::from_le_bytes([l, h])\n     }\n     \/\/\/ Reads value from bus during interrupt.\n-    \/\/\/ mutable bacause on interrupt read some internal system attributes may be changed\n+    \/\/\/ mutable because on interrupt read some internal system attributes may be changed\n     fn read_interrupt(&mut self) -> u8;\n     \/\/\/ Method, invoked by Z80 in case of RETI instruction. Default implementation is empty\n     fn reti(&mut self);\ndiff --git a\/rustzx-z80\/src\/cpu.rs b\/rustzx-z80\/src\/cpu.rs\nindex 2985c66..00c49c5 100644\n--- a\/rustzx-z80\/src\/cpu.rs\n+++ b\/rustzx-z80\/src\/cpu.rs\n@@ -107,6 +107,8 @@ impl Z80 {\n \n     fn handle_interrupt(&mut self, bus: &mut impl Z80Bus) {\n         if bus.nmi_active() {\n+            \/\/ q resets during interrupt\n+            self.regs.clear_q();\n             \/\/ Release halt line on the bus\n             if self.halted {\n                 bus.halt(false);\n@@ -126,6 +128,8 @@ impl Z80 {\n             self.regs.inc_r();\n             \/\/ 5 + 3 + 3 = 11 clocks\n         } else if bus.int_active() && self.regs.get_iff1() {\n+            \/\/ q resets during interrupt\n+            self.regs.clear_q();\n             \/\/ Release halt line on the bus\n             if self.halted {\n                 bus.halt(false);\n@@ -143,9 +147,6 @@ impl Z80 {\n \n                     \/\/ 3 + 3 + 7 = 13 clocks\n                     bus.wait_internal(7);\n-\n-                    \/\/ mem_ptr is set to PC\n-                    self.regs.set_mem_ptr(self.regs.get_pc());\n                 }\n                 \/\/ jump using interrupt vector\n                 IntMode::Im2 => {\n@@ -157,11 +158,10 @@ impl Z80 {\n                     self.regs.set_pc(addr);\n                     bus.wait_internal(7);\n                     \/\/ 3 + 3 + 3 + 3 + 7 = 19 clocks\n-\n-                    \/\/ mem_ptr is set to PC\n-                    self.regs.set_mem_ptr(self.regs.get_pc());\n                 }\n             }\n+            \/\/ mem_ptr is set to PC\n+            self.regs.set_mem_ptr(self.regs.get_pc());\n         }\n     }\n \n@@ -174,6 +174,14 @@ impl Z80 {\n             \/\/ allow interrupts again\n             self.skip_interrupt = false;\n         };\n+\n+        \/\/ Actions to be performed before any opcode execution\n+        let before_execute_opcode = |cpu: &mut Self| {\n+            \/\/ Save Q register value from previous emulation step, which is later used to\n+            \/\/ properly calculate flags in some instructions\n+            cpu.regs.step_q();\n+        };\n+\n         let byte1 = if self.active_prefix != Prefix::None {\n             let tmp = self.active_prefix.to_byte().unwrap();\n             self.active_prefix = Prefix::None;\n@@ -195,28 +203,33 @@ impl Z80 {\n                             self.skip_interrupt = true;\n                         }\n                         Prefix::CB => {\n+                            before_execute_opcode(self);\n                             execute_bits(self, bus, prefix_single);\n                         }\n                         Prefix::None => {\n                             let opcode = Opcode::from_byte(byte2);\n+                            before_execute_opcode(self);\n                             execute_normal(self, bus, opcode, prefix_single);\n                         }\n                     };\n                 }\n                 Prefix::CB => {\n                     \/\/ opcode will be read in the called\n+                    before_execute_opcode(self);\n                     execute_bits(self, bus, Prefix::None);\n                 }\n                 Prefix::ED => {\n                     let byte2 = self.fetch_byte(bus, 4);\n                     self.regs.inc_r();\n                     let opcode = Opcode::from_byte(byte2);\n+                    before_execute_opcode(self);\n                     execute_extended(self, bus, opcode);\n                 }\n                 _ => unreachable!(),\n             };\n         } else {\n             let opcode = Opcode::from_byte(byte1);\n+            before_execute_opcode(self);\n             execute_normal(self, bus, opcode, Prefix::None);\n         };\n         \/\/ Allow bus implementation to process pc-based events\ndiff --git a\/rustzx-z80\/src\/lib.rs b\/rustzx-z80\/src\/lib.rs\nindex bcce89c..7358768 100644\n--- a\/rustzx-z80\/src\/lib.rs\n+++ b\/rustzx-z80\/src\/lib.rs\n@@ -15,6 +15,6 @@ pub use codegen::{CodeGenerator, CodegenMemorySpace};\n pub use cpu::{IntMode, Z80};\n pub use opcode::{Opcode, Prefix};\n pub use registers::{\n-    RegName16, RegName8, Regs, FLAG_CARRY, FLAG_F3, FLAG_F5, FLAG_HALF_CARRY, FLAG_PV, FLAG_SIGN,\n-    FLAG_SUB, FLAG_ZERO,\n+    flag_pos, RegName16, RegName8, Regs, FLAG_CARRY, FLAG_F3, FLAG_F5, FLAG_HALF_CARRY, FLAG_PV,\n+    FLAG_SIGN, FLAG_SUB, FLAG_ZERO,\n };\ndiff --git a\/rustzx-z80\/src\/opcode\/group_bits.rs b\/rustzx-z80\/src\/opcode\/group_bits.rs\nindex 031d2e6..516cd9e 100644\n--- a\/rustzx-z80\/src\/opcode\/group_bits.rs\n+++ b\/rustzx-z80\/src\/opcode\/group_bits.rs\n@@ -24,9 +24,7 @@ pub fn execute_bits(cpu: &mut Z80, bus: &mut impl Z80Bus, prefix: Prefix) {\n         let displacement = cpu.fetch_byte(bus, 3) as i8;\n         let addr = cpu\n             .regs\n-            .get_reg_16_with_displacement(RegName16::HL.with_prefix(prefix), displacement);\n-\n-        cpu.regs.set_mem_ptr(addr);\n+            .build_addr_with_offset(RegName16::HL.with_prefix(prefix), displacement);\n         let opcode = Opcode::from_byte(bus.read(cpu.regs.get_pc(), 3));\n         bus.wait_loop(cpu.regs.get_pc(), 2);\n         cpu.regs.inc_pc();\ndiff --git a\/rustzx-z80\/src\/opcode\/group_extended.rs b\/rustzx-z80\/src\/opcode\/group_extended.rs\nindex 62688d4..eb154b4 100644\n--- a\/rustzx-z80\/src\/opcode\/group_extended.rs\n+++ b\/rustzx-z80\/src\/opcode\/group_extended.rs\n@@ -3,6 +3,7 @@ use crate::{\n         execute_cpi_cpd, execute_ini_ind, execute_ldi_ldd, execute_outi_outd, execute_pop_16,\n         BlockDir, Opcode, Prefix,\n     },\n+    registers::BlockIoOpcode,\n     smallnum::{U1, U2, U3},\n     tables::{\n         lookup16_r12, lookup8_r12, HALF_CARRY_ADD_TABLE, HALF_CARRY_SUB_TABLE, OVERFLOW_ADD_TABLE,\n@@ -95,15 +96,14 @@ pub fn execute_extended(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode) {\n                         \/\/ LD (nn), rp[p]\n                         U1::N0 => {\n                             bus.write_word(addr, cpu.regs.get_reg_16(reg), 3);\n-                            cpu.regs.set_mem_ptr(addr.wrapping_add(1));\n                         }\n                         \/\/ LD rp[p], (nn)\n                         U1::N1 => {\n                             let val = bus.read_word(addr, 3);\n                             cpu.regs.set_reg_16(reg, val);\n-                            cpu.regs.set_mem_ptr(addr.wrapping_add(1));\n                         }\n                     }\n+                    cpu.regs.set_mem_ptr(addr.wrapping_add(1));\n                 }\n                 \/\/ NEG (A = 0 - A)\n                 U3::N4 => {\n@@ -243,6 +243,7 @@ pub fn execute_extended(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode) {\n                                 bus.wait_loop(cpu.regs.get_de().wrapping_sub(1), 5);\n                                 cpu.regs.dec_pc();\n                                 cpu.regs.dec_pc();\n+                                cpu.regs.update_flags_block_mem_cycle();\n                             };\n                         }\n                         \/\/ LDDR\n@@ -254,6 +255,7 @@ pub fn execute_extended(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode) {\n                                 bus.wait_loop(cpu.regs.get_de().wrapping_add(1), 5);\n                                 cpu.regs.dec_pc();\n                                 cpu.regs.dec_pc();\n+                                cpu.regs.update_flags_block_mem_cycle();\n                             };\n                         }\n                         \/\/ NOP\n@@ -282,6 +284,7 @@ pub fn execute_extended(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode) {\n                                 bus.wait_loop(cpu.regs.get_hl().wrapping_sub(1), 5);\n                                 cpu.regs.dec_pc();\n                                 cpu.regs.dec_pc();\n+                                cpu.regs.update_flags_block_mem_cycle();\n                             };\n                         }\n                         \/\/ CPDR\n@@ -292,6 +295,7 @@ pub fn execute_extended(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode) {\n                                 bus.wait_loop(cpu.regs.get_hl().wrapping_add(1), 5);\n                                 cpu.regs.dec_pc();\n                                 cpu.regs.dec_pc();\n+                                cpu.regs.update_flags_block_mem_cycle();\n                             };\n                         }\n                         \/\/ NOP\n@@ -304,25 +308,31 @@ pub fn execute_extended(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode) {\n                 U3::N2 => {\n                     match opcode.y {\n                         \/\/ INI\n-                        U3::N4 => execute_ini_ind(cpu, bus, BlockDir::Inc),\n+                        U3::N4 => {\n+                            execute_ini_ind(cpu, bus, BlockDir::Inc);\n+                        }\n                         \/\/ IND\n-                        U3::N5 => execute_ini_ind(cpu, bus, BlockDir::Dec),\n+                        U3::N5 => {\n+                            execute_ini_ind(cpu, bus, BlockDir::Dec);\n+                        }\n                         \/\/ INIR\n                         U3::N6 => {\n-                            execute_ini_ind(cpu, bus, BlockDir::Inc);\n+                            let m = execute_ini_ind(cpu, bus, BlockDir::Inc);\n                             if cpu.regs.get_reg_8(RegName8::B) != 0 {\n                                 bus.wait_loop(cpu.regs.get_hl().wrapping_sub(1), 5);\n                                 cpu.regs.dec_pc();\n                                 cpu.regs.dec_pc();\n+                                cpu.regs.update_flags_block_io_cycle(BlockIoOpcode::Inir, m);\n                             };\n                         }\n                         \/\/ INDR\n                         U3::N7 => {\n-                            execute_ini_ind(cpu, bus, BlockDir::Dec);\n+                            let m = execute_ini_ind(cpu, bus, BlockDir::Dec);\n                             if cpu.regs.get_reg_8(RegName8::B) != 0 {\n                                 bus.wait_loop(cpu.regs.get_hl().wrapping_add(1), 5);\n                                 cpu.regs.dec_pc();\n                                 cpu.regs.dec_pc();\n+                                cpu.regs.update_flags_block_io_cycle(BlockIoOpcode::Indr, m);\n                             };\n                         }\n                         \/\/ NOP\n@@ -335,25 +345,31 @@ pub fn execute_extended(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode) {\n                 U3::N3 => {\n                     match opcode.y {\n                         \/\/ OUTI\n-                        U3::N4 => execute_outi_outd(cpu, bus, BlockDir::Inc),\n+                        U3::N4 => {\n+                            execute_outi_outd(cpu, bus, BlockDir::Inc);\n+                        }\n                         \/\/ OUTD\n-                        U3::N5 => execute_outi_outd(cpu, bus, BlockDir::Dec),\n+                        U3::N5 => {\n+                            execute_outi_outd(cpu, bus, BlockDir::Dec);\n+                        }\n                         \/\/ OTIR\n                         U3::N6 => {\n-                            execute_outi_outd(cpu, bus, BlockDir::Inc);\n+                            let m = execute_outi_outd(cpu, bus, BlockDir::Inc);\n                             if cpu.regs.get_reg_8(RegName8::B) != 0 {\n                                 bus.wait_loop(cpu.regs.get_bc(), 5);\n                                 cpu.regs.dec_pc();\n                                 cpu.regs.dec_pc();\n+                                cpu.regs.update_flags_block_io_cycle(BlockIoOpcode::Otir, m);\n                             };\n                         }\n                         \/\/ OTDR\n                         U3::N7 => {\n-                            execute_outi_outd(cpu, bus, BlockDir::Dec);\n+                            let m = execute_outi_outd(cpu, bus, BlockDir::Dec);\n                             if cpu.regs.get_reg_8(RegName8::B) != 0 {\n                                 bus.wait_loop(cpu.regs.get_bc(), 5);\n                                 cpu.regs.dec_pc();\n                                 cpu.regs.dec_pc();\n+                                cpu.regs.update_flags_block_io_cycle(BlockIoOpcode::Otdr, m);\n                             };\n                         }\n                         \/\/ NOP\ndiff --git a\/rustzx-z80\/src\/opcode\/group_nonprefixed.rs b\/rustzx-z80\/src\/opcode\/group_nonprefixed.rs\nindex 3688234..c1b36ae 100644\n--- a\/rustzx-z80\/src\/opcode\/group_nonprefixed.rs\n+++ b\/rustzx-z80\/src\/opcode\/group_nonprefixed.rs\n@@ -263,7 +263,7 @@ pub fn execute_normal(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode, pref\n                     bus.wait_loop(cpu.regs.get_pc(), 5);\n                     cpu.regs.inc_pc();\n                     cpu.regs\n-                        .get_reg_16_with_displacement(RegName16::HL.with_prefix(prefix), d)\n+                        .build_addr_with_offset(RegName16::HL.with_prefix(prefix), d)\n                 };\n                 \/\/ read data\n                 data = bus.read(addr, 3);\n@@ -322,7 +322,7 @@ pub fn execute_normal(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode, pref\n                     \/\/ LD (IX+d\/ IY+d)\n                     let d = cpu.fetch_byte(bus, 3) as i8;\n                     cpu.regs\n-                        .get_reg_16_with_displacement(RegName16::HL.with_prefix(prefix), d)\n+                        .build_addr_with_offset(RegName16::HL.with_prefix(prefix), d)\n                 };\n                 LoadOperand8::Indirect(addr)\n             };\n@@ -462,7 +462,9 @@ pub fn execute_normal(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode, pref\n                 U3::N6 => {\n                     let data = cpu.regs.get_acc();\n                     let mut flags = cpu.regs.get_flags() & (FLAG_ZERO | FLAG_PV | FLAG_SIGN);\n-                    flags |= F3F5_TABLE[data as usize] | FLAG_CARRY;\n+                    flags |= ((cpu.regs.get_last_q() ^ cpu.regs.get_flags()) | data)\n+                        & (FLAG_F3 | FLAG_F5);\n+                    flags |= FLAG_CARRY;\n                     cpu.regs.set_flags(flags);\n                 }\n                 \/\/ CCF Invert carry flag\n@@ -471,7 +473,8 @@ pub fn execute_normal(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode, pref\n                     let data = cpu.regs.get_acc();\n                     let old_carry = (cpu.regs.get_flags() & FLAG_CARRY) != 0;\n                     let mut flags = cpu.regs.get_flags() & (FLAG_SIGN | FLAG_PV | FLAG_ZERO);\n-                    flags |= F3F5_TABLE[data as usize];\n+                    flags |= ((cpu.regs.get_last_q() ^ cpu.regs.get_flags()) | data)\n+                        & (FLAG_F3 | FLAG_F5);\n                     flags |= old_carry as u8 * FLAG_HALF_CARRY;\n                     flags |= (!old_carry) as u8 * FLAG_CARRY;\n                     cpu.regs.set_flags(flags);\n@@ -497,8 +500,9 @@ pub fn execute_normal(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode, pref\n                 let d = bus.read(cpu.regs.get_pc(), 3) as i8;\n                 bus.wait_loop(cpu.regs.get_pc(), 5);\n                 cpu.regs.inc_pc();\n+\n                 cpu.regs\n-                    .get_reg_16_with_displacement(RegName16::HL.with_prefix(prefix), d)\n+                    .build_addr_with_offset(RegName16::HL.with_prefix(prefix), d)\n             };\n             cpu.regs\n                 .set_reg_8(RegName8::from_u3(opcode.y).unwrap(), bus.read(src_addr, 3));\n@@ -515,7 +519,7 @@ pub fn execute_normal(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode, pref\n                 bus.wait_loop(cpu.regs.get_pc(), 5);\n                 cpu.regs.inc_pc();\n                 cpu.regs\n-                    .get_reg_16_with_displacement(RegName16::HL.with_prefix(prefix), d)\n+                    .build_addr_with_offset(RegName16::HL.with_prefix(prefix), d)\n             };\n             bus.write(\n                 dst_addr,\n@@ -532,8 +536,6 @@ pub fn execute_normal(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode, pref\n             let to = RegName8::from_u3(opcode.y).unwrap().with_prefix(prefix);\n             let tmp = cpu.regs.get_reg_8(from);\n             cpu.regs.set_reg_8(to, tmp);\n-            cpu.regs\n-                .set_mem_ptr((cpu.regs.get_reg_8(to).wrapping_add(1)) as u16 | ((tmp as u16) << 8));\n         }\n         \/\/ ---------------------------------\n         \/\/ [0b10yyyzzz] instruction section\n@@ -553,7 +555,7 @@ pub fn execute_normal(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode, pref\n                     cpu.regs.inc_pc();\n                     let addr = cpu\n                         .regs\n-                        .get_reg_16_with_displacement(RegName16::HL.with_prefix(prefix), d);\n+                        .build_addr_with_offset(RegName16::HL.with_prefix(prefix), d);\n                     bus.read(addr, 3)\n                 }\n             };\n@@ -596,10 +598,11 @@ pub fn execute_normal(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode, pref\n                 \/\/ [0b11pp1001] instruction group (assorted)\n                 U1::N1 => {\n                     match opcode.p {\n-                        \/\/ RET ; return\n+                        \/\/ RET\n                         \/\/ [0b11001001] : C9;\n                         U2::N0 => {\n                             execute_pop_16(cpu, bus, RegName16::PC, 3);\n+                            cpu.regs.set_mem_ptr(cpu.regs.get_pc());\n                             \/\/ Clocks: 10\n                         }\n                         \/\/ EXX\n@@ -755,6 +758,7 @@ pub fn execute_normal(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode, pref\n                             cpu.regs.inc_pc();\n                             execute_push_16(cpu, bus, RegName16::PC, 3);\n                             cpu.regs.set_pc(addr);\n+                            cpu.regs.set_mem_ptr(cpu.regs.get_pc());\n                         }\n                         \/\/ [0b11011101] : DD\n                         U2::N1 => {\n@@ -786,8 +790,8 @@ pub fn execute_normal(cpu: &mut Z80, bus: &mut impl Z80Bus, opcode: Opcode, pref\n             \/\/ CALL y*8\n             cpu.regs\n                 .set_reg_16(RegName16::PC, (opcode.y.as_byte() as u16) * 8);\n-            \/\/ 4 + 1 + 3 + 3 = 11\n             cpu.regs.set_mem_ptr(cpu.regs.get_pc());\n+            \/\/ Clocks: 4 + 1 + 3 + 3 = 11\n         }\n     };\n }\ndiff --git a\/rustzx-z80\/src\/opcode\/internal_block.rs b\/rustzx-z80\/src\/opcode\/internal_block.rs\nindex d34ba69..8317dce 100644\n--- a\/rustzx-z80\/src\/opcode\/internal_block.rs\n+++ b\/rustzx-z80\/src\/opcode\/internal_block.rs\n@@ -68,8 +68,10 @@ pub fn execute_cpi_cpd(cpu: &mut Z80, bus: &mut impl Z80Bus, dir: BlockDir) -> b\n     tmp == 0\n }\n \n-\/\/\/ ini\/ind instruction group\n-pub fn execute_ini_ind(cpu: &mut Z80, bus: &mut impl Z80Bus, dir: BlockDir) {\n+\/\/\/ INI\/IND instruction group\n+\/\/\/\n+\/\/\/ Returns last written value at (HL)\n+pub fn execute_ini_ind(cpu: &mut Z80, bus: &mut impl Z80Bus, dir: BlockDir) -> u8 {\n     bus.wait_no_mreq(cpu.regs.get_ir(), 1);\n     let src = bus.read_io(cpu.regs.get_bc());\n     bus.write(cpu.regs.get_hl(), src, 3);\n@@ -97,10 +99,13 @@ pub fn execute_ini_ind(cpu: &mut Z80, bus: &mut impl Z80Bus, dir: BlockDir) {\n     \/\/ Parity of (k & 7) xor B is PV flag\n     flags |= PARITY_TABLE[((k & 0x07) ^ b) as usize];\n     cpu.regs.set_flags(flags);\n+\n+    src\n }\n \n-\/\/\/ outi\/outd instruction group\n-pub fn execute_outi_outd(cpu: &mut Z80, bus: &mut impl Z80Bus, dir: BlockDir) {\n+\/\/\/ OUTI\/OUTD instruction group\n+\/\/\/ Returns last read value at (HL)\n+pub fn execute_outi_outd(cpu: &mut Z80, bus: &mut impl Z80Bus, dir: BlockDir) -> u8 {\n     bus.wait_no_mreq(cpu.regs.get_ir(), 1);\n     let src = bus.read(cpu.regs.get_hl(), 3);\n     let b = cpu.regs.dec_reg_8(RegName8::B);\n@@ -128,4 +133,6 @@ pub fn execute_outi_outd(cpu: &mut Z80, bus: &mut impl Z80Bus, dir: BlockDir) {\n     \/\/ Parity of (k & 7) xor B is PV flag\n     flags |= PARITY_TABLE[((k & 0x07) ^ b) as usize];\n     cpu.regs.set_flags(flags);\n+\n+    src\n }\ndiff --git a\/rustzx-z80\/src\/opcode\/types.rs b\/rustzx-z80\/src\/opcode\/types.rs\nindex abb2b77..97af0d7 100644\n--- a\/rustzx-z80\/src\/opcode\/types.rs\n+++ b\/rustzx-z80\/src\/opcode\/types.rs\n@@ -50,13 +50,13 @@ pub enum BitOperand8 {\n     Reg(RegName8),\n }\n \n-\/\/\/ Direction of address cahange in block functions\n+\/\/\/ Direction of address change in block functions\n pub enum BlockDir {\n     Inc,\n     Dec,\n }\n \n-\/\/\/ Opcode, devided in parts\n+\/\/\/ Opcode, divided in parts\n \/\/\/ ```text\n \/\/\/ xxyyyzzz\n \/\/\/ xxppqzzz\ndiff --git a\/rustzx-z80\/src\/registers.rs b\/rustzx-z80\/src\/registers.rs\nindex f0650eb..9e4d4f2 100644\n--- a\/rustzx-z80\/src\/registers.rs\n+++ b\/rustzx-z80\/src\/registers.rs\n@@ -2,6 +2,7 @@\n use crate::{\n     opcode::Prefix,\n     smallnum::{U2, U3},\n+    tables::PARITY_TABLE,\n };\n \n pub const FLAG_CARRY: u8 = 0b00000001;\n@@ -13,6 +14,11 @@ pub const FLAG_F5: u8 = 0b00100000;\n pub const FLAG_ZERO: u8 = 0b01000000;\n pub const FLAG_SIGN: u8 = 0b10000000;\n \n+\/\/ Returns flag position in binary. Useful for making binary shifts in code more obvious.\n+pub const fn flag_pos(flag: u8) -> u8 {\n+    flag.trailing_zeros() as u8\n+}\n+\n \/\/\/ 8-bit register names\n #[derive(Clone,Copy)]\n #[rustfmt::skip]\n@@ -115,7 +121,10 @@ impl RegName16 {\n pub struct Regs {\n     pc: u16,\n     sp: u16,\n+    \/\/ Obscure Z80 feature which affects how F3\/F5 flags are set in `BIT n, (HL)` instruction\n     mem_ptr: u16,\n+    \/\/ Obscure Z80 feature which affects how F3\/F5 flags are set in `CCF` and `SCF` instructions\n+    q: u8, last_q: u8,\n     ixh: u8, ixl: u8,\n     iyh: u8, iyl: u8,\n     r: u8,\n@@ -245,9 +254,11 @@ impl Regs {\n         self.set_reg_16(reg, data)\n     }\n \n-    pub(crate) fn get_reg_16_with_displacement(&self, reg: RegName16, displacement: i8) -> u16 {\n-        let word = self.get_reg_16(reg);\n-        (word as i32).wrapping_add(displacement as i32) as u16\n+    pub(crate) fn build_addr_with_offset(&mut self, reg: RegName16, displacement: i8) -> u16 {\n+        let word = (self.get_reg_16(reg) as i32).wrapping_add(displacement as i32) as u16;\n+        \/\/ Any (REG + d) access changes MEMPTR to calculated value\n+        self.set_mem_ptr(word);\n+        word\n     }\n \n     pub fn get_pc(&self) -> u16 {\n@@ -273,6 +284,19 @@ impl Regs {\n         self.mem_ptr\n     }\n \n+    pub fn step_q(&mut self) {\n+        self.last_q = self.q;\n+        self.q = 0;\n+    }\n+\n+    pub fn clear_q(&mut self) {\n+        self.q = 0;\n+    }\n+\n+    pub fn get_last_q(&self) -> u8 {\n+        self.last_q\n+    }\n+\n     pub fn dec_pc(&mut self) -> u16 {\n         self.pc = self.pc.wrapping_sub(1);\n         self.pc\n@@ -280,7 +304,7 @@ impl Regs {\n \n     \/\/\/ Displaces program counter with signed value\n     pub fn shift_pc(&mut self, displacement: i8) -> u16 {\n-        self.pc = self.get_reg_16_with_displacement(RegName16::PC, displacement);\n+        self.pc = (self.pc as i32).wrapping_add(displacement as i32) as u16;\n         self.pc\n     }\n \n@@ -388,6 +412,7 @@ impl Regs {\n \n     pub fn set_flags(&mut self, value: u8) -> u8 {\n         self.f = value;\n+        self.q = value;\n         self.f\n     }\n \n@@ -503,4 +528,79 @@ impl Regs {\n         core::mem::swap(&mut self.h, &mut self.h_alt);\n         core::mem::swap(&mut self.l, &mut self.l_alt);\n     }\n+\n+    \/\/\/ Sets F3 and F5 flags to 11th and and 15th bit of PC respectively. This obscurity is used by\n+    \/\/\/ block memory operations when performing repeated execution cycle\n+    pub fn update_flags_block_mem_cycle(&mut self) {\n+        self.f &= !(FLAG_F3 | FLAG_F5);\n+        self.f |= (self.pc >> 8) as u8 & (FLAG_F3 | FLAG_F5);\n+    }\n+\n+    \/\/\/ Obscure logic for changing flags after block io opcode iteration,\n+    \/\/\/ which changes F3, F5, HF and PV.\n+    \/\/\/\n+    \/\/\/ Implementation was derived based on the following\n+    \/\/\/ research: https:\/\/github.com\/MrKWatkins\/ZXSpectrumNextTests\/tree\/develop\/Tests\/ZX48_ZX128\/Z80BlockInstructionFlags\n+    \/\/\/\n+    \/\/\/ ### Original calculation algorithm:\n+    \/\/\/ M is the value written to or read from the I\/O port == (HL), Co\/Lo\/Bo are \"output\" values of\n+    \/\/\/ registers C\/L\/B\n+    \/\/\/ ```text\n+    \/\/\/ if instruction == INIR\n+    \/\/\/     T = M + ((Co + 1) & 0xFF)\n+    \/\/\/ else if instruction == INDR\n+    \/\/\/     T = M + ((Co - 1) & 0xFF)\n+    \/\/\/     WARNING: to verify the \"& 0xFF\" part (ie. bit-width of (C-1) intermediate) one would\n+    \/\/\/     need to read value 00 from port 00, which is not possible on regular ZX machine with\n+    \/\/\/     common peripherals -> giving up.\n+    \/\/\/ else if (instruction == OTIR) || (instruction == OTDR)\n+    \/\/\/     T = M + Lo\n+    \/\/\/\n+    \/\/\/ TMP = Bo + (NF ? -CF : CF);\n+    \/\/\/ HF = (TMP ^ Bo).4;\n+    \/\/\/ PV = ((T & 7) ^ Bo ^ (TMP & 7)).parity\n+    \/\/\/ ```\n+    \/\/\/ ### RustZX notes\n+    \/\/\/ RustZX code improves further, removing need for ternary operator during\n+    \/\/\/ TMP calculation\n+    pub fn update_flags_block_io_cycle(&mut self, opcode: BlockIoOpcode, m: u8) {\n+        let t = match opcode {\n+            BlockIoOpcode::Inir => m.wrapping_add(self.c.wrapping_add(1)),\n+            BlockIoOpcode::Indr => m.wrapping_add(self.c.wrapping_sub(1)),\n+            BlockIoOpcode::Otir | BlockIoOpcode::Otdr => m.wrapping_add(self.l),\n+        };\n+\n+        let cf = self.f & FLAG_CARRY;\n+        let b = self.b;\n+        let f = self.f;\n+        \/\/ Explanation of faster \"TMP = Bo + (NF ? -CF : CF)\" calculation logic without branch:\n+        \/\/\n+        \/\/ Basically, when CF is 1, it either stays 1 if NF is 0, or subtracted by 2 if NF\n+        \/\/ is 1 (Which makes -CF part) - NF and CF shofts will produce bit at position 1 which will\n+        \/\/ result in either 2 or 0.\n+        \/\/\n+        \/\/ When CF is 0, no mater NF result will be 0\n+        let tmp = b.wrapping_add(cf.wrapping_sub(\n+            (f >> flag_pos(FLAG_SIGN.wrapping_sub(1)))\n+                & (cf << flag_pos(FLAG_CARRY.wrapping_add(1))),\n+        ));\n+        \/\/ HF = (TMP ^ Bo).4;\n+        let hf = (tmp ^ b) & FLAG_HALF_CARRY;\n+        \/\/ PV = ((T & 7) ^ Bo ^ (TMP & 7)).parity\n+        let pv = PARITY_TABLE[((t & 0x07) ^ b ^ (tmp & 0x07)) as usize];\n+\n+        \/\/ Set flags\n+        self.f &= !(FLAG_HALF_CARRY | FLAG_PV | FLAG_F3 | FLAG_F5);\n+        let f3f5 = (self.pc >> 8) as u8 & (FLAG_F3 | FLAG_F5);\n+        self.f |= f3f5 | hf | pv;\n+        \/\/ Instruction changes F, therefore update Q\n+        self.q = self.f;\n+    }\n+}\n+\n+pub enum BlockIoOpcode {\n+    Inir,\n+    Indr,\n+    Otir,\n+    Otdr,\n }\ndiff --git a\/rustzx\/Cargo.toml b\/rustzx\/Cargo.toml\nindex 3cc0309..7488be4 100644\n--- a\/rustzx\/Cargo.toml\n+++ b\/rustzx\/Cargo.toml\n@@ -1,32 +1,34 @@\n [package]\n name = \"rustzx\"\n-version = \"0.15.0\"\n-authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n description = \"ZX Spectrum emulator\"\n-repository = \"https:\/\/github.com\/rustzx\/rustzx\"\n readme = \"..\/README.md\"\n keywords = [\"emulator\", \"game\", \"z80\"]\n-license = \"MIT\"\n-edition = \"2018\"\n+\n+version.workspace = true\n+license.workspace = true\n+edition.workspace = true\n+authors.workspace = true\n+repository.workspace = true\n \n # See more keys and their definitions at https:\/\/doc.rust-lang.org\/cargo\/reference\/manifest.html\n \n [dependencies]\n sdl2 = { version = \"0.35\", features = [\"unsafe_textures\", \"bundled\", \"static-link\"] }\n-rustzx-core = { version = \"0.15\", path =  \"..\/rustzx-core\", features = [\"full\"] }\n-rustzx-utils = { version = \"0.15\", path =  \"..\/rustzx-utils\", features = [\"std\"] }\n+rustzx-core = { workspace = true, features = [\"full\"] }\n+rustzx-utils = { workspace = true, features = [\"std\"] }\n log = \"0.4\"\n anyhow = \"1.0\"\n structopt = \"0.3\"\n strum = { version = \"0.22\", default-features = false, features = [\"derive\", \"std\"] }\n simple_logger = \"2\"\n-cpal = { version = \"0.13\", default-features = false, optional = true }\n+cpal = { version = \"0.15\", default-features = false, optional = true }\n+ringbuf = { version = \"0.3\", optional = true }\n \n [features]\n default = [\"sound-cpal\"]\n-# cpal requries ALSA development headers on Linux, if this feature\n+# cpal requires ALSA development headers on Linux, if this feature\n # is disabled, RustZX will be built only with SDL audio backend support\n-sound-cpal = [\"cpal\"]\n+sound-cpal = [\"cpal\", \"ringbuf\"]\n \n \n #[dev-dependencies]\ndiff --git a\/rustzx\/src\/app\/events\/events_sdl.rs b\/rustzx\/src\/app\/events\/events_sdl.rs\nindex 4848074..becb44f 100644\n--- a\/rustzx\/src\/app\/events\/events_sdl.rs\n+++ b\/rustzx\/src\/app\/events\/events_sdl.rs\n@@ -19,7 +19,7 @@ use sdl2::{\n     EventPump,\n };\n \n-\/\/\/ Represents SDL Envets bakend\n+\/\/\/ Represents SDL Envets backend\n pub struct EventsSdl {\n     event_pump: EventPump,\n     mouse: MouseUtil,\n@@ -77,7 +77,7 @@ impl EventsSdl {\n         }\n     }\n \n-    \/\/\/ returns ZX Spectum key form scancode of None if not found\n+    \/\/\/ returns ZX Spectrum key form scancode of None if not found\n     fn scancode_to_zxkey_event(&self, scancode: Option<Scancode>, pressed: bool) -> Option<Event> {\n         let zxkey_event = match scancode? {\n             \/\/ FEFE\n@@ -261,7 +261,7 @@ impl EventDevice for EventsSdl {\n                         .or_else(|| self.scancode_to_compound_key_event(scancode, pressed))\n                 }\n                 SdlEvent::MouseMotion { xrel, yrel, .. } => {\n-                    \/\/ Change of direction  requires counter reset to elimiate lag\n+                    \/\/ Change of direction  requires counter reset to eliminate lag\n                     if self.mouse_x_counter.signum() != xrel.signum() {\n                         self.mouse_x_counter = xrel;\n                     } else {\n@@ -273,7 +273,7 @@ impl EventDevice for EventsSdl {\n                         self.mouse_y_counter += yrel;\n                     }\n \n-                    \/\/ Depending on sensitivity, diffent distance is required to move\n+                    \/\/ Depending on sensitivity, different distance is required to move\n                     \/\/ kempston mouse\n                     let ticks_to_move =\n                         sensitivity_to_mouse_counter_ticks(self.mouse_sensitivity) as i32;\ndiff --git a\/rustzx\/src\/app\/rustzx.rs b\/rustzx\/src\/app\/rustzx.rs\nindex 0a9b064..3617fd7 100644\n--- a\/rustzx\/src\/app\/rustzx.rs\n+++ b\/rustzx\/src\/app\/rustzx.rs\n@@ -146,7 +146,8 @@ impl RustzxApp {\n             let emulator_dt = self\n                 .emulator\n                 .emulate_frames(MAX_FRAME_TIME)\n-                .map_err(|e| anyhow!(\"Emulation step failed: {:#?}\", e))?;\n+                .map_err(|e| anyhow!(\"Emulation step failed: {:#?}\", e))?\n+                .duration;\n             \/\/ if sound enabled sound ganeration allowed then move samples to sound thread\n             if let Some(ref mut snd) = self.snd {\n                 \/\/ if can be turned off even on speed change, so check it everytime\n@@ -214,8 +215,8 @@ impl RustzxApp {\n                     Event::MouseMove { x, y } => {\n                         self.emulator.send_mouse_pos_diff(x, y);\n                     }\n-                    Event::MouseButton(buton, pressed) => {\n-                        self.emulator.send_mouse_button(buton, pressed);\n+                    Event::MouseButton(button, pressed) => {\n+                        self.emulator.send_mouse_button(button, pressed);\n                     }\n                     Event::MouseWheel(direction) => {\n                         self.emulator.send_mouse_wheel(direction);\n@@ -231,7 +232,7 @@ impl RustzxApp {\n             let emulation_dt = frame_start.elapsed();\n             if emulation_dt < frame_target_dt {\n                 let wait_koef = if self.emulator.have_sound() { 9 } else { 10 };\n-                \/\/ sleep untill frame sync\n+                \/\/ sleep until frame sync\n                 thread::sleep((frame_target_dt - emulation_dt) * wait_koef \/ 10);\n             };\n             \/\/ get exceed clocks and use them on next iteration\ndiff --git a\/rustzx\/src\/app\/settings.rs b\/rustzx\/src\/app\/settings.rs\nindex 9f9fe9b..3a3b02c 100644\n--- a\/rustzx\/src\/app\/settings.rs\n+++ b\/rustzx\/src\/app\/settings.rs\n@@ -32,7 +32,7 @@ pub struct Settings {\n     pub machine: ZXMachine,\n     \/\/\/ Set emulation speed at emualtor start-up. Can be specified as deciamal non-zero\n     \/\/\/ value or as a special value `MAX` to run emulator as fast as possible\n-    #[structopt(long, default_value = \"1\", parse(try_from_str = emualtion_speed_from_str))]\n+    #[structopt(long, default_value = \"1\", parse(try_from_str = emulation_speed_from_str))]\n     pub speed: EmulationMode,\n     \/\/\/ Disable fast tape loading\n     #[structopt(long = \"nofastload\")]\n@@ -110,7 +110,7 @@ fn machine_from_str(s: &str) -> Result<ZXMachine, anyhow::Error> {\n     }\n }\n \n-fn emualtion_speed_from_str(s: &str) -> Result<EmulationMode, anyhow::Error> {\n+fn emulation_speed_from_str(s: &str) -> Result<EmulationMode, anyhow::Error> {\n     match s.to_lowercase().as_str() {\n         \"max\" => Ok(EmulationMode::Max),\n         s => {\ndiff --git a\/rustzx\/src\/app\/sound\/mod.rs b\/rustzx\/src\/app\/sound\/mod.rs\nindex 5ae6898..42cb21b 100644\n--- a\/rustzx\/src\/app\/sound\/mod.rs\n+++ b\/rustzx\/src\/app\/sound\/mod.rs\n@@ -19,3 +19,9 @@ pub trait SoundDevice {\n     \/\/\/ Return selected device sample rate\n     fn sample_rate(&self) -> usize;\n }\n+\n+pub fn ringbuf_size_from_sample_rate(sample_rate: usize) -> usize {\n+    \/\/ Around 5 frames of buffering is available\n+    const RINGBUF_LENGTH_MS: usize = 100;\n+    (sample_rate as f32 * (RINGBUF_LENGTH_MS as f32 \/ 1000f32)) as usize\n+}\ndiff --git a\/rustzx\/src\/app\/sound\/sound_cpal.rs b\/rustzx\/src\/app\/sound\/sound_cpal.rs\nindex a8eb87e..dc5e30d 100644\n--- a\/rustzx\/src\/app\/sound\/sound_cpal.rs\n+++ b\/rustzx\/src\/app\/sound\/sound_cpal.rs\n@@ -1,18 +1,17 @@\n \/\/! Real Audio SDL backend\n use crate::app::{\n     settings::Settings,\n-    sound::{SoundDevice, ZXSample, CHANNEL_COUNT},\n+    sound::{ringbuf_size_from_sample_rate, SoundDevice, ZXSample, CHANNEL_COUNT},\n };\n use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};\n-use std::sync::mpsc;\n+use std::sync::Arc;\n \n pub struct SoundCpal {\n-    tx: mpsc::Sender<ZXSample>,\n+    tx: ringbuf::Producer<ZXSample, Arc<ringbuf::HeapRb<ZXSample>>>,\n     sample_rate: usize,\n     \/\/ Keep stream alive until Drop\n     _stream: cpal::Stream,\n }\n-\n impl SoundCpal {\n     \/\/\/ Constructs sound backend from settings\n     pub fn new(settings: &Settings) -> anyhow::Result<SoundCpal> {\n@@ -32,7 +31,8 @@ impl SoundCpal {\n                     }\n                 }\n \n-                c.channels() == CHANNEL_COUNT as u16\n+                \/\/ Find any stereo config\n+                (c.channels() as usize % CHANNEL_COUNT == 0) && c.channels() != 0\n             })\n             .ok_or_else(|| {\n                 anyhow::anyhow!(\"Sound device does not support required configuration\")\n@@ -46,12 +46,24 @@ impl SoundCpal {\n \n         let sample_rate = config.sample_rate().0 as usize;\n \n-        let (tx, rx) = mpsc::channel();\n+        let ringbuf_size = ringbuf_size_from_sample_rate(sample_rate);\n+        let ringbuf = ringbuf::HeapRb::<ZXSample>::new(ringbuf_size);\n+        let (tx, rx) = ringbuf.split();\n \n         let stream = match config.sample_format() {\n             cpal::SampleFormat::I16 => create_stream::<i16>(&device, &config.into(), rx)?,\n             cpal::SampleFormat::U16 => create_stream::<u16>(&device, &config.into(), rx)?,\n             cpal::SampleFormat::F32 => create_stream::<f32>(&device, &config.into(), rx)?,\n+            cpal::SampleFormat::I8 => create_stream::<i8>(&device, &config.into(), rx)?,\n+            cpal::SampleFormat::I32 => create_stream::<i32>(&device, &config.into(), rx)?,\n+            cpal::SampleFormat::I64 => create_stream::<i64>(&device, &config.into(), rx)?,\n+            cpal::SampleFormat::U8 => create_stream::<u8>(&device, &config.into(), rx)?,\n+            cpal::SampleFormat::U32 => create_stream::<u32>(&device, &config.into(), rx)?,\n+            cpal::SampleFormat::U64 => create_stream::<u64>(&device, &config.into(), rx)?,\n+            cpal::SampleFormat::F64 => create_stream::<f64>(&device, &config.into(), rx)?,\n+            _ => {\n+                anyhow::bail!(\"Device has unsupported audio sample format\")\n+            }\n         };\n \n         Ok(SoundCpal {\n@@ -64,7 +76,8 @@ impl SoundCpal {\n \n impl SoundDevice for SoundCpal {\n     fn send_sample(&mut self, sample: ZXSample) {\n-        self.tx.send(sample).unwrap();\n+        \/\/ Ignore buffer overflows\n+        let _ = self.tx.push(sample);\n     }\n \n     fn sample_rate(&self) -> usize {\n@@ -75,10 +88,10 @@ impl SoundDevice for SoundCpal {\n fn create_stream<T>(\n     device: &cpal::Device,\n     config: &cpal::StreamConfig,\n-    samples_rx: mpsc::Receiver<ZXSample>,\n+    mut samples_rx: ringbuf::Consumer<ZXSample, Arc<ringbuf::HeapRb<ZXSample>>>,\n ) -> anyhow::Result<cpal::Stream>\n where\n-    T: cpal::Sample,\n+    T: cpal::FromSample<f32> + cpal::SizedSample,\n {\n     let channels = config.channels as usize;\n \n@@ -86,21 +99,25 @@ where\n         config,\n         move |out: &mut [T], _: &cpal::OutputCallbackInfo| {\n             for frame in out.chunks_mut(channels) {\n-                match samples_rx.try_recv().ok() {\n+                match samples_rx.pop() {\n                     Some(zx_sample) => {\n-                        let left: T = cpal::Sample::from(&zx_sample.left);\n-                        let right: T = cpal::Sample::from(&zx_sample.right);\n+                        let left: T = cpal::Sample::from_sample(zx_sample.left);\n+                        let right: T = cpal::Sample::from_sample(zx_sample.right);\n                         frame[0] = left;\n                         frame[1] = right;\n                     }\n                     None => {\n-                        frame[0] = cpal::Sample::from(&0f32);\n-                        frame[1] = cpal::Sample::from(&0f32);\n+                        frame[0] = cpal::Sample::EQUILIBRIUM;\n+                        frame[1] = cpal::Sample::EQUILIBRIUM;\n                     }\n                 }\n+\n+                \/\/ We use only first stereo channels, other channels should be silent\n+                frame[2..channels].fill(cpal::Sample::EQUILIBRIUM);\n             }\n         },\n         |_| {},\n+        None,\n     )?;\n     stream.play()?;\n     Ok(stream)\ndiff --git a\/rustzx\/src\/app\/sound\/sound_sdl.rs b\/rustzx\/src\/app\/sound\/sound_sdl.rs\nindex be26e57..e74be04 100644\n--- a\/rustzx\/src\/app\/sound\/sound_sdl.rs\n+++ b\/rustzx\/src\/app\/sound\/sound_sdl.rs\n@@ -1,16 +1,19 @@\n use crate::{\n     app::{\n         settings::Settings,\n-        sound::{SoundDevice, ZXSample, CHANNEL_COUNT, DEFAULT_LATENCY, DEFAULT_SAMPLE_RATE},\n+        sound::{\n+            ringbuf_size_from_sample_rate, SoundDevice, ZXSample, CHANNEL_COUNT, DEFAULT_LATENCY,\n+            DEFAULT_SAMPLE_RATE,\n+        },\n     },\n     backends::SDL_CONTEXT,\n };\n use sdl2::audio::{AudioCallback, AudioDevice, AudioSpecDesired};\n-use std::sync::mpsc;\n+use std::sync::Arc;\n \n \/\/\/ Struct which used in SDL audio callback\n struct SdlCallback {\n-    samples: mpsc::Receiver<ZXSample>,\n+    samples: ringbuf::Consumer<ZXSample, Arc<ringbuf::HeapRb<ZXSample>>>,\n }\n \n impl AudioCallback for SdlCallback {\n@@ -19,8 +22,8 @@ impl AudioCallback for SdlCallback {\n     \/\/\/ main callback function\n     fn callback(&mut self, out: &mut [f32]) {\n         for chunk in out.chunks_mut(CHANNEL_COUNT) {\n-            \/\/ recieve samples from channel\n-            if let Ok(sample) = self.samples.try_recv() {\n+            \/\/ receive samples from channel\n+            if let Some(sample) = self.samples.pop() {\n                 chunk[0] = sample.left;\n                 chunk[1] = sample.right;\n             } else {\n@@ -33,7 +36,7 @@ impl AudioCallback for SdlCallback {\n \n \/\/\/ Represents SDL audio backend\n pub struct SoundSdl {\n-    sender: mpsc::Sender<ZXSample>,\n+    sender: ringbuf::Producer<ZXSample, Arc<ringbuf::HeapRb<ZXSample>>>,\n     sample_rate: usize,\n     _device: AudioDevice<SdlCallback>, \/\/ Should be alive until Drop invocation\n }\n@@ -59,7 +62,10 @@ impl SoundSdl {\n             channels: Some(CHANNEL_COUNT as u8),\n             samples: Some(latency as u16),\n         };\n-        let (tx, rx) = mpsc::channel();\n+        let ringbuf_size = ringbuf_size_from_sample_rate(sample_rate);\n+        let ringbuf = ringbuf::HeapRb::<ZXSample>::new(ringbuf_size);\n+        let (tx, rx) = ringbuf.split();\n+\n         let device_handle = audio\n             .open_playback(None, &desired_spec, |_| SdlCallback { samples: rx })\n             .map_err(|e| anyhow::anyhow!(\"Failed to start SDL sound stream: {}\", e))?;\n@@ -75,7 +81,8 @@ impl SoundSdl {\n \n impl SoundDevice for SoundSdl {\n     fn send_sample(&mut self, sample: ZXSample) {\n-        self.sender.send(sample).unwrap();\n+        \/\/ Ignore sample push errors\n+        let _ = self.sender.push(sample);\n     }\n \n     fn sample_rate(&self) -> usize {\ndiff --git a\/rustzx\/src\/app\/video\/mod.rs b\/rustzx\/src\/app\/video\/mod.rs\nindex 81acc48..8a05419 100644\n--- a\/rustzx\/src\/app\/video\/mod.rs\n+++ b\/rustzx\/src\/app\/video\/mod.rs\n@@ -29,13 +29,13 @@ impl Rect {\n     }\n }\n \n-\/\/\/ provides video functionality trough rela backend to emulator\n+\/\/\/ provides video functionality through real backend to emulator\n pub trait VideoDevice {\n     \/\/\/ generates and returns texture handle\n     fn gen_texture(&mut self, width: u32, height: u32) -> TextureInfo;\n     \/\/\/ changes window title\n     fn set_title(&mut self, title: &str);\n-    \/\/\/ udpates texture data\n+    \/\/\/ updates texture data\n     fn update_texture(&mut self, tex: TextureInfo, buffer: &[u8]);\n     \/\/\/ starts render block\n     fn begin(&mut self);\ndiff --git a\/rustzx\/src\/app\/video\/video_sdl.rs b\/rustzx\/src\/app\/video\/video_sdl.rs\nindex 2010794..8443681 100644\n--- a\/rustzx\/src\/app\/video\/video_sdl.rs\n+++ b\/rustzx\/src\/app\/video\/video_sdl.rs\n@@ -36,7 +36,7 @@ impl VideoSdl {\n                 .position_centered()\n                 .opengl()\n                 .build()\n-                .expect(\"[ERROR] Sdl window buil fail\");\n+                .expect(\"[ERROR] Sdl window build fail\");\n             let renderer = window\n                 .into_canvas()\n                 .present_vsync()\ndiff --git a\/rustzx\/src\/host\/mod.rs b\/rustzx\/src\/host\/mod.rs\nindex 3bd936a..2ad0bdf 100644\n--- a\/rustzx\/src\/host\/mod.rs\n+++ b\/rustzx\/src\/host\/mod.rs\n@@ -4,7 +4,8 @@ use anyhow::{anyhow, bail, Context};\n use frame_buffer::{FrameBufferContext, RgbaFrameBuffer};\n use rustzx_core::{\n     host::{\n-        FrameBuffer, Host, HostContext, RomFormat, RomSet, Screen, Snapshot, StubIoExtender, Tape,\n+        FrameBuffer, Host, HostContext, RomFormat, RomSet, Screen, Snapshot, StubDebugInterface,\n+        StubIoExtender, Tape,\n     },\n     zx::machine::ZXMachine,\n };\n@@ -22,6 +23,7 @@ pub struct AppHost;\n \n impl Host for AppHost {\n     type Context = AppHostContext;\n+    type DebugInterface = StubDebugInterface;\n     type EmulationStopwatch = InstantStopwatch;\n     type FrameBuffer = RgbaFrameBuffer;\n     type IoExtender = StubIoExtender;\ndiff --git a\/typos.toml b\/typos.toml\nnew file mode 100644\nindex 0000000..61c3649\n--- \/dev\/null\n+++ b\/typos.toml\n@@ -0,0 +1,9 @@\n+[files]\n+extend-exclude = [\n+    # Ignore third-party software comment typos\n+    \"**\/assets\/*.z80\",\n+]\n+\n+[default.extend-words]\n+# DAA is a valid Z80 instruction word\n+DAA = \"DAA\"\ndiff --git a\/vtx\/Cargo.toml b\/vtx\/Cargo.toml\nindex fd323bf..c2a7cdd 100644\n--- a\/vtx\/Cargo.toml\n+++ b\/vtx\/Cargo.toml\n@@ -1,12 +1,13 @@\n [package]\n name = \"vtx\"\n-version = \"0.15.0\"\n description = \"VTX sound format parsing and playback library\"\n-authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n-edition = \"2018\"\n keywords = [\"ay\", \"sound\", \"vtx\", \"parser\"]\n-license = \"MIT\"\n-repository = \"https:\/\/github.com\/rustzx\/rustzx\"\n+\n+version.workspace = true\n+license.workspace = true\n+edition.workspace = true\n+authors.workspace = true\n+repository.workspace = true\n \n [dependencies]\n delharc = { version = \"0.3\", default-features = false }\n@@ -14,7 +15,7 @@ thiserror = \"1.0\"\n byteorder = \"1.4\"\n num-traits = { version = \"0.2\", default-features = false }\n num-derive = \"0.3\"\n-aym = { version = \"0.15\", path = \"..\/aym\" }\n+aym = { workspace = true }\n \n [dev-dependencies]\n expect-test = \"1.1\"\ndiff --git a\/vtx\/src\/lib.rs b\/vtx\/src\/lib.rs\nindex ad939f0..0f68fee 100644\n--- a\/vtx\/src\/lib.rs\n+++ b\/vtx\/src\/lib.rs\n@@ -91,7 +91,7 @@ pub enum VtxError {\n     Io(#[from] std::io::Error),\n     #[error(\"Invalid VTX header: {}\", message)]\n     InvalidHeader { message: &'static str },\n-    #[error(\"Faield to decode lh5 compressed data\")]\n+    #[error(\"Failed to decode lh5 compressed data\")]\n     DecompressFailure,\n }\n \ndiff --git a\/vtx\/src\/player.rs b\/vtx\/src\/player.rs\nindex fca0573..11fe3cc 100644\n--- a\/vtx\/src\/player.rs\n+++ b\/vtx\/src\/player.rs\n@@ -200,7 +200,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn precise_player_wroks_normally() {\n+    fn precise_player_works_normally() {\n         \/\/ This test also doubles as test for `aym` crate with AymPrecise backend selected\n         expect![[r#\"65127ad0e493b23b43e838b6281d7f8d07a47549efd0c9d1eda3d3ccaf0b7e5c\"#]].assert_eq(\n             &generate_samples_hash_for_vtx::<aym::AymPrecise>(include_bytes!(\"test\/csoon.vtx\")),\ndiff --git a\/vtx\/vtx-bin\/Cargo.toml b\/vtx\/vtx-bin\/Cargo.toml\nindex ebc4b91..1e9f904 100644\n--- a\/vtx\/vtx-bin\/Cargo.toml\n+++ b\/vtx\/vtx-bin\/Cargo.toml\n@@ -1,19 +1,20 @@\n [package]\n name = \"vtx-bin\"\n description = \"VTX sound format toolbox\"\n-version = \"0.15.0\"\n-authors = [\"The RustZX contributors\", \"Vladyslav Nikonov <mail@pacmancoder.xyz>\"]\n-edition = \"2018\"\n-license = \"MIT\"\n-repository = \"https:\/\/github.com\/rustzx\/rustzx\"\n keywords = [\"emulator\", \"ay\", \"sound\", \"vtx\"]\n \n+version.workspace = true\n+license.workspace = true\n+edition.workspace = true\n+authors.workspace = true\n+repository.workspace = true\n+\n [[bin]]\n name = \"vtx\"\n path = \"src\/main.rs\"\n \n [dependencies]\n-vtx = { version = \"0.15\", path = \"..\" }\n+vtx = { workspace = true }\n structopt = \"0.3\"\n wav = \"1.0\"\n anyhow = \"1.0\"\n","test_patch":"diff --git a\/.github\/workflows\/test-rustzx-z80.yml b\/.github\/workflows\/test-rustzx-z80.yml\nindex a691683..d62576d 100644\n--- a\/.github\/workflows\/test-rustzx-z80.yml\n+++ b\/.github\/workflows\/test-rustzx-z80.yml\n@@ -63,3 +63,18 @@ jobs:\n         with:\n           command: test\n           args: -p rustzx-z80 -- --ignored --skip zexall_alu8r zexall\n+  z80test:\n+    name: \"z80test-based tests\"\n+    runs-on: ubuntu-20.04\n+    steps:\n+      - uses: actions\/checkout@v2\n+      - uses: actions-rs\/toolchain@v1\n+        with:\n+          profile: minimal\n+          toolchain: stable\n+          override: true\n+      - name: Test\n+        uses: actions-rs\/cargo@v1\n+        with:\n+          command: test\n+          args: -p rustzx-test -- --nocapture --ignored z80full z80ccf z80memptr\ndiff --git a\/rustzx-test\/Cargo.toml b\/rustzx-test\/Cargo.toml\nindex 9833638..c3ef486 100644\n--- a\/rustzx-test\/Cargo.toml\n+++ b\/rustzx-test\/Cargo.toml\n@@ -1,10 +1,14 @@\n [package]\n name = \"rustzx-test\"\n-version = \"0.15.0\"\n-edition = \"2018\"\n publish = false\n description = \"RustZX emulator integration tests\"\n \n+version.workspace = true\n+license.workspace = true\n+edition.workspace = true\n+authors.workspace = true\n+repository.workspace = true\n+\n [[bench]]\n name = \"z80test\"\n harness = false\n@@ -15,8 +19,8 @@ base64 = \"0.13\"\n expect-test = \"1.1\"\n nanoid = \"0.4\"\n png = \"0.16\"\n-rustzx-core = { version = \"0.15\", path = \"..\/rustzx-core\", features = [\"full\"] }\n-rustzx-utils = { version = \"0.15\", path =  \"..\/rustzx-utils\", features = [\"std\"] }\n+rustzx-core = { workspace = true, features = [\"full\"] }\n+rustzx-utils = { workspace = true, features = [\"std\"] }\n sha2 = \"0.9\"\n wav = \"1.0\"\n \ndiff --git a\/rustzx-test\/benches\/z80test.rs b\/rustzx-test\/benches\/z80test.rs\nindex 8f94c5e..7341e4f 100644\n--- a\/rustzx-test\/benches\/z80test.rs\n+++ b\/rustzx-test\/benches\/z80test.rs\n@@ -7,7 +7,7 @@ fn z80test_setup() -> RustZXTester {\n     let settings = presets::settings_48k();\n     let mut tester = RustZXTester::new(\"z80full\", settings);\n     tester.load_tap(\"z80full.tap.gz\");\n-    tester.send_keypress(ZXKey::Enter);\n+    tester.disable_scroll_message();\n \n     tester\n }\ndiff --git a\/rustzx-test\/src\/framework.rs b\/rustzx-test\/src\/framework.rs\nindex f071d30..aa5ef01 100644\n--- a\/rustzx-test\/src\/framework.rs\n+++ b\/rustzx-test\/src\/framework.rs\n@@ -1,16 +1,17 @@\n use expect_test::Expect;\n use rustzx_core::{\n     host::{\n-        BufferCursor, FrameBuffer, FrameBufferSource, Host, HostContext, IoExtender, RomFormat,\n-        RomSet, Snapshot, Tape,\n+        BufferCursor, DebugInterface, FrameBuffer, FrameBufferSource, Host, HostContext,\n+        IoExtender, RomFormat, RomSet, Snapshot, Tape,\n     },\n+    poke,\n     zx::{\n         keys::ZXKey,\n         machine::ZXMachine,\n         sound::ay::ZXAYMode,\n         video::colors::{ZXBrightness, ZXColor},\n     },\n-    EmulationMode, Emulator, RustzxSettings,\n+    EmulationMode, EmulationStopReason, Emulator, RustzxSettings,\n };\n use rustzx_utils::{\n     io::{DynamicAsset, GzipAsset},\n@@ -145,7 +146,7 @@ impl DebugPort {\n         String::from_utf8(s).expect(\"Invalid debug port stdout\")\n     }\n \n-    pub fn take_bufer(&mut self) -> Vec<u8> {\n+    pub fn take_buffer(&mut self) -> Vec<u8> {\n         Vec::from(std::mem::take(&mut self.stdout))\n     }\n \n@@ -155,10 +156,43 @@ impl DebugPort {\n     }\n }\n \n+\/\/\/ A simple debug interface that allows to set breakpoints and check if they were hit.\n+#[derive(Default)]\n+struct TestDebugInterface {\n+    breakpoints: std::collections::HashSet<u16>,\n+    last_hit: Option<u16>,\n+}\n+\n+impl TestDebugInterface {\n+    pub fn add_breakpoint(&mut self, address: u16) {\n+        self.breakpoints.insert(address);\n+    }\n+\n+    pub fn clear_breakpoints(&mut self) {\n+        self.breakpoints.clear();\n+        self.last_hit = None;\n+    }\n+\n+    pub fn last_breakpoint_hit(&self) -> Option<u16> {\n+        self.last_hit\n+    }\n+}\n+\n+impl DebugInterface for TestDebugInterface {\n+    fn check_pc_breakpoint(&mut self, addr: u16) -> bool {\n+        if self.breakpoints.contains(&addr) {\n+            self.last_hit = Some(addr);\n+            return true;\n+        }\n+        false\n+    }\n+}\n+\n struct TesterHost;\n \n impl Host for TesterHost {\n     type Context = TesterContext;\n+    type DebugInterface = TestDebugInterface;\n     type EmulationStopwatch = InstantStopwatch;\n     type FrameBuffer = FrameContent;\n     type IoExtender = DebugPort;\n@@ -316,21 +350,63 @@ impl RustZXTester {\n         }\n     }\n \n-    pub fn emulate_for(&mut self, duration: Duration) {\n+    \/\/\/ Sets the breakpoint and emulates until it is hit or the timeout is reached\n+    pub fn emulate_until_breakpoint(&mut self, breakpoint_addr: u16, timeout: Duration) {\n+        self.clear_breakpoints();\n+        self.add_breakpoint(breakpoint_addr);\n+\n+        let result = self.emulate_for(timeout);\n+        if let EmulationStopReason::Breakpoint = result {\n+            \/\/ Check if last breakpoint is the one we requested\n+            let last_breakpoint = self.last_breakpoint();\n+            assert_eq!(\n+                last_breakpoint, breakpoint_addr,\n+                \"Emulator stopped at breakpoint {:04X}, expected {:04X}\",\n+                last_breakpoint, breakpoint_addr\n+            );\n+\n+            return;\n+        }\n+        panic!(\"Emulator failed to hit breakpoint before reaching timeout\");\n+    }\n+\n+    \/\/\/  Emulates for the given duration or until the breakpoint is hit\n+    pub fn emulate_for(&mut self, duration: Duration) -> EmulationStopReason {\n         let mut emulated_duration = Duration::from_secs(0);\n         while emulated_duration < duration {\n-            self.emulator\n+            let result = self\n+                .emulator\n                 .emulate_frames(FRAME_HOST_DURATION_LIMIT)\n                 .expect(\"Emulation failed\");\n+\n             self.update_sound();\n             emulated_duration += FRAME_EMULATED_DURATION;\n+\n+            if result.stop_reason == EmulationStopReason::Breakpoint {\n+                eprintln!(\n+                    \"Requested {} duration, emulated for {}\",\n+                    duration.as_millis(),\n+                    emulated_duration.as_millis()\n+                );\n+\n+                return result.stop_reason;\n+            }\n         }\n+        EmulationStopReason::Completed\n     }\n \n     pub fn emulate_frame(&mut self) {\n         self.emulate_for(FRAME_EMULATED_DURATION);\n     }\n \n+    pub fn last_breakpoint(&mut self) -> u16 {\n+        self.emulator\n+            .debug_interface()\n+            .expect(\"no breakpoints were set\")\n+            .last_breakpoint_hit()\n+            .expect(\"No breapoints were triggered\")\n+    }\n+\n     pub fn compare_buffer_with_file(\n         &self,\n         actual: Vec<u8>,\n@@ -450,7 +526,7 @@ impl RustZXTester {\n                 panic!(\"Timeout reached when trying to sync host with target\");\n             }\n \n-            \/\/ Try to consume incomming signal and finish sync\n+            \/\/ Try to consume incoming signal and finish sync\n             if self.debug_port().take_byte().is_some() {\n                 break;\n             }\n@@ -460,6 +536,31 @@ impl RustZXTester {\n     pub fn set_sync_timeout(&mut self, timeout: Duration) {\n         self.sync_timeout = timeout;\n     }\n+\n+    \/\/\/ Disables the message and key press prompt after a few lines of scroll in BASIC\n+    pub fn disable_scroll_message(&mut self) {\n+        self.emulator.execute_poke(poke::DisableScrollMessageRom48);\n+    }\n+\n+    pub fn add_breakpoint(&mut self, address: u16) {\n+        if let Some(interface) = self.emulator.debug_interface() {\n+            interface.add_breakpoint(address);\n+        } else {\n+            let mut interface = TestDebugInterface::default();\n+            interface.add_breakpoint(address);\n+            self.emulator.set_debug_interface(interface);\n+        }\n+    }\n+\n+    pub fn clear_breakpoints(&mut self) {\n+        if let Some(interface) = self.emulator.debug_interface() {\n+            interface.clear_breakpoints();\n+        }\n+    }\n+\n+    pub fn peek(&mut self, addr: u16) -> u8 {\n+        self.emulator.peek(addr)\n+    }\n }\n \n struct TestEnv;\ndiff --git a\/rustzx-test\/test_data\/README.md b\/rustzx-test\/test_data\/README.md\nnew file mode 100644\nindex 0000000..5d851c7\n--- \/dev\/null\n+++ b\/rustzx-test\/test_data\/README.md\n@@ -0,0 +1,10 @@\n+# Used third-party software list\n+\n+All rights to the third-party binaries and sources belong to their authors.\n+\n+| Name | Version | Source |\n+| --- | --- | --- |\n+| z80test | 1.2 | https:\/\/github.com\/raxoft\/z80test |\n+| zmakebas | 1.3 | https:\/\/github.com\/z00m128\/zmakebas |\n+| diag_rom | 56 | http:\/\/www.retroleum.co.uk\/diagrom\/?stub=diagrom |\n+| Z80 Block Flags Test | e05310a | [https:\/\/github.com\/MrKWatkins\/ZXSpectrumNextTests](https:\/\/github.com\/MrKWatkins\/ZXSpectrumNextTests\/tree\/develop\/Tests\/ZX48_ZX128\/Z80BlockInstructionFlags) |\ndiff --git a\/rustzx-test\/test_data\/z80bltst.tap.gz b\/rustzx-test\/test_data\/z80bltst.tap.gz\nnew file mode 100644\nindex 0000000..e6462e0\nBinary files \/dev\/null and b\/rustzx-test\/test_data\/z80bltst.tap.gz differ\ndiff --git a\/rustzx-test\/test_data\/z80ccf.tap.gz b\/rustzx-test\/test_data\/z80ccf.tap.gz\nnew file mode 100644\nindex 0000000..bd6b3d2\nBinary files \/dev\/null and b\/rustzx-test\/test_data\/z80ccf.tap.gz differ\ndiff --git a\/rustzx-test\/test_data\/z80full.tap.gz b\/rustzx-test\/test_data\/z80full.tap.gz\nindex d065b65..c655de5 100644\nBinary files a\/rustzx-test\/test_data\/z80full.tap.gz and b\/rustzx-test\/test_data\/z80full.tap.gz differ\ndiff --git a\/rustzx-test\/test_data\/z80memptr.tap.gz b\/rustzx-test\/test_data\/z80memptr.tap.gz\nnew file mode 100644\nindex 0000000..b196f38\nBinary files \/dev\/null and b\/rustzx-test\/test_data\/z80memptr.tap.gz differ\ndiff --git a\/rustzx-test\/tests\/z80test.rs b\/rustzx-test\/tests\/z80test.rs\nnew file mode 100644\nindex 0000000..860fed4\n--- \/dev\/null\n+++ b\/rustzx-test\/tests\/z80test.rs\n@@ -0,0 +1,133 @@\n+use expect_test::expect;\n+use rustzx_test::framework::{presets, RustZXTester};\n+use std::time::Duration;\n+\n+\/\/\/ Address where emulator loads program from tape\n+const PROG_START: u16 = 0x8000;\n+\n+\/\/\/ Finds the address of pattern in emulator memory via peek method.\n+fn search_pattern(\n+    t: &mut RustZXTester,\n+    pattern: &[u8],\n+    min_search_range: u16,\n+    max_search_range: u16,\n+) -> u16 {\n+    assert!(\n+        min_search_range <= max_search_range,\n+        \"min_search_range must be less or equal to max_search_range\"\n+    );\n+\n+    assert!(\n+        pattern.len() <= (max_search_range - min_search_range) as usize,\n+        \"Pattern is too big\"\n+    );\n+\n+    for mem_offset in min_search_range..max_search_range {\n+        let mut found = true;\n+        for (pattern_offset, expected) in pattern.into_iter().copied().enumerate() {\n+            if t.peek(mem_offset + pattern_offset as u16) != expected {\n+                found = false;\n+                break;\n+            }\n+        }\n+        if found {\n+            return mem_offset;\n+        }\n+    }\n+\n+    panic!(\"Failed to found pattern in loaded program\");\n+}\n+\n+\/\/\/ We are trying to find call opcode of the following `z80test` code (main.asm):\n+\/\/\/ ```text\n+\/\/\/ 65 | .ok    call    print                       ; print success message\n+\/\/\/ 66 |        db      \"all tests passed.\",13,0\n+\/\/\/ ```\n+fn search_success_print_call(t: &mut RustZXTester) -> u16 {\n+    \/\/ Search in first 1k of program\n+    const MAX_SEARCH_BYTES: u16 = 1024;\n+    const SEARCH_PATTERN: &[u8] = b\"all tests passed\";\n+    const CALL_OPCODE_LEN: u16 = 3;\n+\n+    let pattern_offset =\n+        search_pattern(t, SEARCH_PATTERN, PROG_START, PROG_START + MAX_SEARCH_BYTES);\n+\n+    assert!(\n+        pattern_offset >= CALL_OPCODE_LEN,\n+        \"Pattern offset is too small\"\n+    );\n+\n+    pattern_offset - CALL_OPCODE_LEN\n+}\n+\n+\/\/\/ Runs tests based on z80test project tape files.\n+fn run_z80_test(name: &str) {\n+    const TIMEOUT_INIT: Duration = Duration::from_secs(1);\n+    const TIMEOUT_TEST: Duration = Duration::from_secs(350);\n+\n+    let mut t = RustZXTester::new(name, presets::settings_48k_nosound());\n+    \/\/ Disable scroll message to eliminate need for enter key press emulation during test run\n+    t.disable_scroll_message();\n+    t.load_tap(format!(\"{}.tap.gz\", name));\n+\n+    \/\/ Wait until emulator loads program and jumps to PROG_START\n+    t.emulate_until_breakpoint(PROG_START, TIMEOUT_INIT);\n+    let success_breakpoint_addr = search_success_print_call(&mut t);\n+\n+    \/\/ Wait test to succeed\n+    t.emulate_until_breakpoint(success_breakpoint_addr, TIMEOUT_TEST);\n+}\n+\n+macro_rules! z80test {\n+    ($($name:ident),*) => {\n+        $(\n+            #[test]\n+            #[ignore]\n+            fn $name() {\n+                run_z80_test(stringify!($name));\n+            }\n+        )*\n+    };\n+}\n+\n+z80test!(z80full, z80ccf, z80memptr);\n+\n+\/\/\/ This code finds the following opcodes addresses\n+\/\/\/ ```text\n+\/\/\/ 294 | .exit: di             ; F3\n+\/\/\/ 295 | .sp+1: ld    sp,0     ; 0x31 0x00  0x00\n+\/\/\/ ```\n+fn search_exit_address(t: &mut RustZXTester) -> u16 {\n+    \/\/ Opcodes should be around 0x200 offset, lets search for 0x400 bytes\n+    const SEARCH_BYTES: u16 = 1024;\n+    const SEARCH_PATTERN: &[u8] = &[0xF3, 0x31, 0x00, 0x00];\n+    search_pattern(t, SEARCH_PATTERN, PROG_START, PROG_START + SEARCH_BYTES)\n+}\n+\n+\/\/\/ Tests z80 block instructions flags via z80bltst.tap from ZXSpectrumNextTests project\n+#[test]\n+fn z80_block_instruction_flags() {\n+    const TIMEOUT_INIT: Duration = Duration::from_secs(1);\n+    const TIMEOUT_TEST: Duration = Duration::from_secs(30);\n+\n+    let mut t = RustZXTester::new(\n+        \"z80_block_instruction_flags\",\n+        presets::settings_48k_nosound(),\n+    );\n+    t.load_tap(\"z80bltst.tap.gz\");\n+\n+    \/\/ Wait until emulator loads program and jumps to PROG_START\n+    t.emulate_until_breakpoint(PROG_START, TIMEOUT_INIT);\n+    let exit_breakpoint_addr = search_exit_address(&mut t);\n+\n+    \/\/ Wait test to succeed\n+    t.emulate_until_breakpoint(exit_breakpoint_addr, TIMEOUT_TEST);\n+\n+    \/\/ Prepare screen to be compared against expected frame hash\n+    t.emulate_frame();\n+\n+    t.expect_screen(\n+        \"frame1\",\n+        expect![[r#\"KnD\/3IYvk72FtwHyxhia4wNWGwcJKgmnxZfTmaebTlo=\"#]],\n+    );\n+}\ndiff --git a\/rustzx-z80\/tests\/integration\/assets\/zexall.z80 b\/rustzx-z80\/tests\/integration\/assets\/zexall.z80\nindex 740ce76..a537aa1 100644\n--- a\/rustzx-z80\/tests\/integration\/assets\/zexall.z80\n+++ b\/rustzx-z80\/tests\/integration\/assets\/zexall.z80\n@@ -91,7 +91,7 @@ loop:\tld\ta,(hl)\t\t; end of list ?\n \tdec\thl\n \tcall\tstt\n \tjp\tloop\n-\t\n+\n done:\tld\tde,msg2\n \tld\tc,9\n \tcall\tbdos\n@@ -462,7 +462,7 @@ ld162:\tdb\t0ffh\t\t; flag mask\n \ttstr\t0,-1,0,0,0,0,0,0,0,0\t\t\t; (16 cycles)\n \tdb\t05fh,097h,024h,087h\t\t\t; expected crc\n \ttmsg\t'ld hl,(nnnn)'\n-\t\n+\n ; ld sp,(nnnn) (16 cycles)\n ld163:\tdb\t0ffh\t\t; flag mask\n \ttstr\t<0edh,07bh,low msbt,high msbt>,08dfch,057d7h,02161h,0ca18h,0c185h,027dah,083h,01eh,0f460h\n@@ -478,7 +478,7 @@ ld164:\tdb\t0ffh\t\t; flag mask\n \ttstr\t0,-1,0,0,0,0,0,0,0,0\t\t\t; (16 cycles)\n \tdb\t085h,08bh,0f1h,06dh\t\t\t; expected crc\n \ttmsg\t'ld <ix,iy>,(nnnn)'\n-\t\n+\n ; ld (nnnn),<bc,de> (64 cycles)\n ld165:\tdb\t0ffh\t\t; flag mask\n \ttstr\t<0edh,043h,low msbt,high msbt>,01f98h,0844dh,0e8ach,0c9edh,0c95dh,08f61h,080h,03fh,0c7bfh\n@@ -898,7 +898,7 @@ ncb1:\tld\ta,b\n \tret\tz\n \tld\ta,1\n \tret\n-\t\n+\n ; get next shifter bit in low bit of a\n shfbit:\tds\t1\n shfbyt:\tds\t2\n@@ -924,7 +924,7 @@ nsb1:\tld\ta,b\n \tret\tz\n \tld\ta,1\n \tret\n-\t\n+\n \n ; clear memory at hl, bc bytes\n clrmem:\tpush\taf\n@@ -1017,7 +1017,7 @@ cntend:\tpop\tbc\n cntlp1:\tinc\thl\n \tinc\tde\n \tjp\tcntlp\n-\t\n+\n \n ; multi-byte shifter\n shift:\tpush\tbc\n@@ -1073,7 +1073,7 @@ test:\tpush\taf\n \tld\tb,16\n \tld\thl,msbt\n \tcall\thexstr\n-      endif\t\n+      endif\n \tdi\t\t\t; disable interrupts\n \tld\t(spsav),sp\t; save stack pointer\n \tld\tsp,msbt+2\t; point to test-case machine state\n@@ -1170,7 +1170,7 @@ phex2:\tpush\taf\n \trrca\n \tcall\tphex1\n \tpop\taf\n-; fall through\t\n+; fall through\n \n ; display low nibble in a\n phex1:\tpush\taf\n@@ -1543,4 +1543,3 @@ crctab:\tdb\t000h,000h,000h,000h\n \tdb\t0c3h,00ch,08eh,0a1h\n \tdb\t05ah,005h,0dfh,01bh\n \tdb\t02dh,002h,0efh,08dh\n-\n","problem_statement":"raxoft's `z80test` undocumented opcodes\/flags tests fail\nThere are a lot of failures in z80 tests by @raxoft https:\/\/github.com\/raxoft\/z80test\r\n(Found via https:\/\/viva-games.ru\/game\/zilog-z80-cpu-test-suite)\r\n\r\nPassing test tapes: `z80doc.tap` `z80docflags.tap`\r\nFailing test tapes: `z80full.tap`, `z80ccf.tap`, `z80flags.tap`, `z80memptr.tap`\r\n\r\nMost likely `ccf` and `memptr` tests fail because lack of `Q` and `Memptr` hidden undocumented registers emulation.\n","hints_text":"Marked as enhancement at this issue is not really world-breaking for now.\nMemptr was implemented via #132, however the following still be done in scope of this task:\r\n- Memptr integration tests\r\n- Q register implementation\r\n- Q register integration tests","created_at":1678,"merge_commit_sha":"26556991ab07a8b701c1154f81b4cb233acfbbd1","ci_name_list":[]}
{"repo":"linebender\/resvg","pull_number":679,"instance_id":"linebender__resvg-679","issue_numbers":["429"],"base_commit":"96dd39898fc17fe447b9591199ae0d21bbf351c7","patch":"diff --git a\/Cargo.lock b\/Cargo.lock\nindex f3bb8420a..c5eb12075 100644\n--- a\/Cargo.lock\n+++ b\/Cargo.lock\n@@ -312,8 +312,7 @@ dependencies = [\n [[package]]\n name = \"svgtypes\"\n version = \"0.12.0\"\n-source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n-checksum = \"d71499ff2d42f59d26edb21369a308ede691421f79ebc0f001e2b1fd3a7c9e52\"\n+source = \"git+https:\/\/github.com\/RazrFalcon\/svgtypes#f485fb0c009e7a69b78a9fe457ceb7466b1e6b53\"\n dependencies = [\n  \"kurbo\",\n  \"siphasher\",\ndiff --git a\/crates\/resvg\/Cargo.toml b\/crates\/resvg\/Cargo.toml\nindex 1ae9b85de..857153960 100644\n--- a\/crates\/resvg\/Cargo.toml\n+++ b\/crates\/resvg\/Cargo.toml\n@@ -21,7 +21,7 @@ log = \"0.4\"\n pico-args = { version = \"0.5\", features = [\"eq-separator\"] }\n png = { version = \"0.17\", optional = true }\n rgb = \"0.8\"\n-svgtypes = \"0.12\"\n+svgtypes = { git = \"https:\/\/github.com\/RazrFalcon\/svgtypes\" }\n tiny-skia = \"0.11.2\"\n usvg = { path = \"..\/usvg\", version = \"0.36.0\", default-features = false }\n \ndiff --git a\/crates\/usvg-parser\/Cargo.toml b\/crates\/usvg-parser\/Cargo.toml\nindex 7f10efa69..104556537 100644\n--- a\/crates\/usvg-parser\/Cargo.toml\n+++ b\/crates\/usvg-parser\/Cargo.toml\n@@ -22,5 +22,5 @@ log = \"0.4\"\n roxmltree = \"0.18\"\n simplecss = \"0.2\"\n siphasher = \"0.3\" # perfect hash implementation\n-svgtypes = \"0.12\"\n+svgtypes = { git = \"https:\/\/github.com\/RazrFalcon\/svgtypes\" }\n usvg-tree = { path = \"..\/usvg-tree\", version = \"0.36.0\" }\ndiff --git a\/crates\/usvg-parser\/src\/clippath.rs b\/crates\/usvg-parser\/src\/clippath.rs\nindex 45cd1ae66..7c126688a 100644\n--- a\/crates\/usvg-parser\/src\/clippath.rs\n+++ b\/crates\/usvg-parser\/src\/clippath.rs\n@@ -21,7 +21,7 @@ pub(crate) fn convert(\n     }\n \n     \/\/ The whole clip path should be ignored when a transform is invalid.\n-    let transform = resolve_transform(node)?;\n+    let transform = resolve_clip_path_transform(node, state)?;\n \n     \/\/ Check if this element was already converted.\n     if let Some(clip) = cache.clip_paths.get(node.element_id()) {\n@@ -67,7 +67,7 @@ pub(crate) fn convert(\n     }\n }\n \n-fn resolve_transform(node: SvgNode) -> Option<Transform> {\n+fn resolve_clip_path_transform(node: SvgNode, state: &converter::State) -> Option<Transform> {\n     \/\/ Do not use Node::attribute::<Transform>, because it will always\n     \/\/ return a valid transform.\n \n@@ -94,7 +94,7 @@ fn resolve_transform(node: SvgNode) -> Option<Transform> {\n     );\n \n     if ts.is_valid() {\n-        Some(ts)\n+        Some(node.resolve_transform(AId::Transform, state))\n     } else {\n         None\n     }\ndiff --git a\/crates\/usvg-parser\/src\/converter.rs b\/crates\/usvg-parser\/src\/converter.rs\nindex c121de3ee..608577090 100644\n--- a\/crates\/usvg-parser\/src\/converter.rs\n+++ b\/crates\/usvg-parser\/src\/converter.rs\n@@ -7,11 +7,11 @@ use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n use std::str::FromStr;\n \n-use svgtypes::{Length, LengthUnit as Unit, PaintOrderKind};\n+use svgtypes::{Length, LengthUnit as Unit, TransformOrigin, PaintOrderKind};\n use usvg_tree::*;\n \n use crate::svgtree::{self, AId, EId, FromValue, SvgNode};\n-use crate::units;\n+use crate::units::{self, convert_length};\n use crate::{Error, Options};\n \n #[derive(Clone)]\n@@ -560,7 +560,7 @@ pub(crate) fn convert_group(\n         filters\n     };\n \n-    let transform: Transform = node.attribute(AId::Transform).unwrap_or_default();\n+    let transform = node.resolve_transform(AId::Transform, state);\n     let blend_mode: BlendMode = node.attribute(AId::MixBlendMode).unwrap_or_default();\n     let isolation: Isolation = node.attribute(AId::Isolation).unwrap_or_default();\n     let isolate = isolation == Isolation::Isolate;\n@@ -754,3 +754,33 @@ pub fn svg_paint_order_to_usvg(order: svgtypes::PaintOrder) -> PaintOrder {\n         _ => PaintOrder::FillAndStroke,\n     }\n }\n+\n+impl SvgNode<'_, '_> {\n+    pub(crate) fn resolve_transform(&self, transform_aid: AId, state: &State) -> Transform {\n+        let mut transform: Transform = self.attribute(transform_aid).unwrap_or_default();\n+        let transform_origin: Option<TransformOrigin> = self.attribute(AId::TransformOrigin);\n+\n+        if let Some(transform_origin) = transform_origin {\n+            let dx = convert_length(\n+                transform_origin.x_offset,\n+                *self,\n+                AId::Width,\n+                Units::UserSpaceOnUse,\n+                state,\n+            );\n+            let dy = convert_length(\n+                transform_origin.y_offset,\n+                *self,\n+                AId::Height,\n+                Units::UserSpaceOnUse,\n+                state,\n+            );\n+            transform = Transform::default()\n+                .pre_translate(dx, dy)\n+                .pre_concat(transform)\n+                .pre_translate(-dx, -dy);\n+        }\n+\n+        transform\n+    }\n+}\ndiff --git a\/crates\/usvg-parser\/src\/filter.rs b\/crates\/usvg-parser\/src\/filter.rs\nindex e73637ead..680483e2e 100644\n--- a\/crates\/usvg-parser\/src\/filter.rs\n+++ b\/crates\/usvg-parser\/src\/filter.rs\n@@ -16,10 +16,10 @@ use usvg_tree::{\n     Units,\n };\n \n-use crate::converter::SvgColorExt;\n+use crate::converter::{self, SvgColorExt};\n use crate::paint_server::{convert_units, resolve_number};\n use crate::svgtree::{AId, EId, FromValue, SvgNode};\n-use crate::{converter, OptionLog};\n+use crate::OptionLog;\n \n impl<'a, 'input: 'a> FromValue<'a, 'input> for usvg_tree::filter::ColorInterpolation {\n     fn parse(_: SvgNode, _: AId, value: &str) -> Option<Self> {\ndiff --git a\/crates\/usvg-parser\/src\/paint_server.rs b\/crates\/usvg-parser\/src\/paint_server.rs\nindex c09411593..2a6f4915d 100644\n--- a\/crates\/usvg-parser\/src\/paint_server.rs\n+++ b\/crates\/usvg-parser\/src\/paint_server.rs\n@@ -9,9 +9,9 @@ use strict_num::PositiveF32;\n use svgtypes::{Length, LengthUnit as Unit};\n use usvg_tree::*;\n \n-use crate::converter::SvgColorExt;\n+use crate::converter::{self, SvgColorExt};\n use crate::svgtree::{AId, EId, SvgNode};\n-use crate::{converter, OptionLog};\n+use crate::OptionLog;\n \n pub(crate) enum ServerOrColor {\n     Server(Paint),\n@@ -53,9 +53,7 @@ fn convert_linear(node: SvgNode, state: &converter::State) -> Option<ServerOrCol\n     }\n \n     let units = convert_units(node, AId::GradientUnits, Units::ObjectBoundingBox);\n-    let transform = resolve_attr(node, AId::GradientTransform)\n-        .attribute(AId::GradientTransform)\n-        .unwrap_or_default();\n+    let transform = node.resolve_transform(AId::GradientTransform, state);\n \n     let gradient = LinearGradient {\n         id: node.element_id().to_string(),\n@@ -121,9 +119,7 @@ fn convert_radial(node: SvgNode, state: &converter::State) -> Option<ServerOrCol\n     );\n     let fx = resolve_number(node, AId::Fx, units, state, Length::new_number(cx as f64));\n     let fy = resolve_number(node, AId::Fy, units, state, Length::new_number(cy as f64));\n-    let transform = resolve_attr(node, AId::GradientTransform)\n-        .attribute(AId::GradientTransform)\n-        .unwrap_or_default();\n+    let transform = node.resolve_transform(AId::GradientTransform, state);\n \n     let gradient = RadialGradient {\n         id: node.element_id().to_string(),\n@@ -165,9 +161,7 @@ fn convert_pattern(\n     let units = convert_units(node, AId::PatternUnits, Units::ObjectBoundingBox);\n     let content_units = convert_units(node, AId::PatternContentUnits, Units::UserSpaceOnUse);\n \n-    let transform = resolve_attr(node, AId::PatternTransform)\n-        .attribute(AId::PatternTransform)\n-        .unwrap_or_default();\n+    let transform = node.resolve_transform(AId::PatternTransform, state);\n \n     let rect = NonZeroRect::from_xywh(\n         resolve_number(node, AId::X, units, state, Length::zero()),\ndiff --git a\/crates\/usvg-parser\/src\/style.rs b\/crates\/usvg-parser\/src\/style.rs\nindex ccea18f0c..47c341d45 100644\n--- a\/crates\/usvg-parser\/src\/style.rs\n+++ b\/crates\/usvg-parser\/src\/style.rs\n@@ -4,9 +4,9 @@\n \n use usvg_tree::{ApproxEqUlps, Color, Fill, Opacity, Paint, Stroke, StrokeMiterlimit, Units};\n \n-use crate::converter::SvgColorExt;\n+use crate::converter::{self, SvgColorExt};\n+use crate::paint_server;\n use crate::svgtree::{AId, FromValue, SvgNode};\n-use crate::{converter, paint_server};\n \n impl<'a, 'input: 'a> FromValue<'a, 'input> for usvg_tree::LineCap {\n     fn parse(_: SvgNode, _: AId, value: &str) -> Option<Self> {\n@@ -187,6 +187,8 @@ fn convert_paint(\n                 from_fallback(node, fallback, opacity)\n             }\n         }\n+        \/\/ Ignore `context-fill` and `context-stroke for now\n+        _ => None,\n     }\n }\n \ndiff --git a\/crates\/usvg-parser\/src\/svgtree\/mod.rs b\/crates\/usvg-parser\/src\/svgtree\/mod.rs\nindex 71205a07b..3c6fa3fc3 100644\n--- a\/crates\/usvg-parser\/src\/svgtree\/mod.rs\n+++ b\/crates\/usvg-parser\/src\/svgtree\/mod.rs\n@@ -709,6 +709,7 @@ impl AId {\n                 | AId::TextOverflow\n                 | AId::TextRendering\n                 | AId::Transform\n+                | AId::TransformOrigin\n                 | AId::UnicodeBidi\n                 | AId::VectorEffect\n                 | AId::Visibility\n@@ -801,6 +802,7 @@ fn is_non_inheritable(id: AId) -> bool {\n             | AId::StopOpacity\n             | AId::TextDecoration\n             | AId::Transform\n+            | AId::TransformOrigin\n     )\n }\n \n@@ -871,6 +873,12 @@ impl<'a, 'input: 'a> FromValue<'a, 'input> for usvg_tree::Transform {\n     }\n }\n \n+impl<'a, 'input: 'a> FromValue<'a, 'input> for svgtypes::TransformOrigin {\n+    fn parse(_: SvgNode, _: AId, value: &str) -> Option<Self> {\n+        Self::from_str(value).ok()\n+    }\n+}\n+\n impl<'a, 'input: 'a> FromValue<'a, 'input> for svgtypes::ViewBox {\n     fn parse(_: SvgNode, _: AId, value: &str) -> Option<Self> {\n         Self::from_str(value).ok()\ndiff --git a\/crates\/usvg-parser\/src\/text.rs b\/crates\/usvg-parser\/src\/text.rs\nindex 11dad101f..02c5f0e20 100644\n--- a\/crates\/usvg-parser\/src\/text.rs\n+++ b\/crates\/usvg-parser\/src\/text.rs\n@@ -139,20 +139,12 @@ fn collect_text_chunks(\n         chunks: Vec::new(),\n     };\n \n-    collect_text_chunks_impl(\n-        text_node,\n-        text_node,\n-        pos_list,\n-        state,\n-        cache,\n-        &mut iter_state,\n-    );\n+    collect_text_chunks_impl(text_node, pos_list, state, cache, &mut iter_state);\n \n     iter_state.chunks\n }\n \n fn collect_text_chunks_impl(\n-    text_node: SvgNode,\n     parent: SvgNode,\n     pos_list: &[CharacterPosition],\n     state: &converter::State,\n@@ -184,7 +176,7 @@ fn collect_text_chunks_impl(\n                 iter_state.split_chunk = true;\n             }\n \n-            collect_text_chunks_impl(text_node, child, pos_list, state, cache, iter_state);\n+            collect_text_chunks_impl(child, pos_list, state, cache, iter_state);\n \n             iter_state.text_flow = TextFlow::Linear;\n \n@@ -337,9 +329,10 @@ fn resolve_text_flow(node: SvgNode, state: &converter::State) -> Option<TextFlow\n     let path = crate::shapes::convert(linked_node, state)?;\n \n     \/\/ The reference path's transform needs to be applied\n-    let path = if let Some(node_transform) = linked_node.attribute::<Transform>(AId::Transform) {\n+    let transform = linked_node.resolve_transform(AId::Transform, state);\n+    let path = if !transform.is_identity() {\n         let mut path_copy = path.as_ref().clone();\n-        path_copy = path_copy.transform(node_transform)?;\n+        path_copy = path_copy.transform(transform)?;\n         Rc::new(path_copy)\n     } else {\n         path\n@@ -632,7 +625,10 @@ fn resolve_decoration(\n     \/\/ ancestors (i.e. tspans) until we find the text decoration declared. If not, we will\n     \/\/ stop at latest at the text node, and use its fill\/stroke.\n     let mut gen_style = |text_decoration: &str| {\n-        if !tspan.ancestors().any(|n| find_decoration(n, text_decoration)) {\n+        if !tspan\n+            .ancestors()\n+            .any(|n| find_decoration(n, text_decoration))\n+        {\n             return None;\n         }\n \n@@ -641,8 +637,8 @@ fn resolve_decoration(\n \n         for node in tspan.ancestors() {\n             if find_decoration(node, text_decoration) || node.tag_name() == Some(EId::Text) {\n-                fill_node = fill_node.map_or(Some(node), |n| Some(n));\n-                stroke_node = stroke_node.map_or(Some(node), |n| Some(n));\n+                fill_node = fill_node.map_or(Some(node), Some);\n+                stroke_node = stroke_node.map_or(Some(node), Some);\n                 break;\n             }\n         }\ndiff --git a\/crates\/usvg-parser\/src\/use_node.rs b\/crates\/usvg-parser\/src\/use_node.rs\nindex b3bfab2ec..050c988c2 100644\n--- a\/crates\/usvg-parser\/src\/use_node.rs\n+++ b\/crates\/usvg-parser\/src\/use_node.rs\n@@ -29,7 +29,7 @@ pub(crate) fn convert(\n     }\n \n     \/\/ We require an original transformation to setup 'clipPath'.\n-    let mut orig_ts: Transform = node.attribute(AId::Transform).unwrap_or_default();\n+    let mut orig_ts = node.resolve_transform(AId::Transform, state);\n     let mut new_ts = Transform::default();\n \n     {\n@@ -133,7 +133,7 @@ pub(crate) fn convert_svg(\n     parent: &mut Node,\n ) {\n     \/\/ We require original transformation to setup 'clipPath'.\n-    let mut orig_ts: Transform = node.attribute(AId::Transform).unwrap_or_default();\n+    let mut orig_ts = node.resolve_transform(AId::Transform, state);\n     let mut new_ts = Transform::default();\n \n     {\ndiff --git a\/crates\/usvg-tree\/Cargo.toml b\/crates\/usvg-tree\/Cargo.toml\nindex 7ae8b6990..6f0f1d5f4 100644\n--- a\/crates\/usvg-tree\/Cargo.toml\n+++ b\/crates\/usvg-tree\/Cargo.toml\n@@ -15,5 +15,5 @@ workspace = \"..\/..\"\n [dependencies]\n rctree = \"0.5\"\n strict-num = \"0.1.1\"\n-svgtypes = \"0.12\"\n+svgtypes = { git = \"https:\/\/github.com\/RazrFalcon\/svgtypes\" }\n tiny-skia-path = \"0.11.2\"\ndiff --git a\/docs\/svg2-changelog.md b\/docs\/svg2-changelog.md\nindex 6d7385625..a40b03b92 100644\n--- a\/docs\/svg2-changelog.md\n+++ b\/docs\/svg2-changelog.md\n@@ -73,7 +73,7 @@ NOTE: This list is not final. This just things I was able to find so far. Patche\n ### Added\n \n - [ ] A [`transform-box`](https:\/\/www.w3.org\/TR\/css-transforms-1\/#transform-box) property.\n-- [ ] A [`transform-origin`](https:\/\/www.w3.org\/TR\/css-transforms-1\/#transform-origin-property) property.\n+- [x] A [`transform-origin`](https:\/\/www.w3.org\/TR\/css-transforms-1\/#transform-origin-property) property.\n - [ ] A [`vector-effect`](https:\/\/www.w3.org\/TR\/SVG2\/coords.html#VectorEffects) property.\n \n ### Changed\n","test_patch":"diff --git a\/crates\/resvg\/tests\/integration\/render.rs b\/crates\/resvg\/tests\/integration\/render.rs\nindex e997528ba..5c03fe8a5 100644\n--- a\/crates\/resvg\/tests\/integration\/render.rs\n+++ b\/crates\/resvg\/tests\/integration\/render.rs\n@@ -1229,6 +1229,29 @@ use crate::render;\n #[test] fn structure_transform_translate_without_Y() { assert_eq!(render(\"tests\/structure\/transform\/translate-without-Y\"), 0); }\n #[test] fn structure_transform_translate() { assert_eq!(render(\"tests\/structure\/transform\/translate\"), 0); }\n #[test] fn structure_transform_zeroed_matrix() { assert_eq!(render(\"tests\/structure\/transform\/zeroed-matrix\"), 0); }\n+#[test] fn structure_transform_origin_bottom() { assert_eq!(render(\"tests\/structure\/transform-origin\/bottom\"), 0); }\n+#[test] fn structure_transform_origin_center() { assert_eq!(render(\"tests\/structure\/transform-origin\/center\"), 0); }\n+#[test] fn structure_transform_origin_keyword_length() { assert_eq!(render(\"tests\/structure\/transform-origin\/keyword-length\"), 0); }\n+#[test] fn structure_transform_origin_left() { assert_eq!(render(\"tests\/structure\/transform-origin\/left\"), 0); }\n+#[test] fn structure_transform_origin_length_percent() { assert_eq!(render(\"tests\/structure\/transform-origin\/length-percent\"), 0); }\n+#[test] fn structure_transform_origin_length_px() { assert_eq!(render(\"tests\/structure\/transform-origin\/length-px\"), 0); }\n+#[test] fn structure_transform_origin_no_transform() { assert_eq!(render(\"tests\/structure\/transform-origin\/no-transform\"), 0); }\n+#[test] fn structure_transform_origin_on_clippath_objectBoundingBox() { assert_eq!(render(\"tests\/structure\/transform-origin\/on-clippath-objectBoundingBox\"), 0); }\n+#[test] fn structure_transform_origin_on_clippath() { assert_eq!(render(\"tests\/structure\/transform-origin\/on-clippath\"), 0); }\n+#[test] fn structure_transform_origin_on_gradient_object_bounding_box() { assert_eq!(render(\"tests\/structure\/transform-origin\/on-gradient-object-bounding-box\"), 0); }\n+#[test] fn structure_transform_origin_on_gradient_user_space_on_use() { assert_eq!(render(\"tests\/structure\/transform-origin\/on-gradient-user-space-on-use\"), 0); }\n+#[test] fn structure_transform_origin_on_group() { assert_eq!(render(\"tests\/structure\/transform-origin\/on-group\"), 0); }\n+#[test] fn structure_transform_origin_on_image() { assert_eq!(render(\"tests\/structure\/transform-origin\/on-image\"), 0); }\n+#[test] fn structure_transform_origin_on_pattern_object_bounding_box() { assert_eq!(render(\"tests\/structure\/transform-origin\/on-pattern-object-bounding-box\"), 0); }\n+#[test] fn structure_transform_origin_on_pattern_user_space_on_use() { assert_eq!(render(\"tests\/structure\/transform-origin\/on-pattern-user-space-on-use\"), 0); }\n+#[test] fn structure_transform_origin_on_shape() { assert_eq!(render(\"tests\/structure\/transform-origin\/on-shape\"), 0); }\n+#[test] fn structure_transform_origin_on_text_path() { assert_eq!(render(\"tests\/structure\/transform-origin\/on-text-path\"), 0); }\n+#[test] fn structure_transform_origin_on_text() { assert_eq!(render(\"tests\/structure\/transform-origin\/on-text\"), 0); }\n+#[test] fn structure_transform_origin_right_bottom() { assert_eq!(render(\"tests\/structure\/transform-origin\/right-bottom\"), 0); }\n+#[test] fn structure_transform_origin_right() { assert_eq!(render(\"tests\/structure\/transform-origin\/right\"), 0); }\n+#[test] fn structure_transform_origin_top_left() { assert_eq!(render(\"tests\/structure\/transform-origin\/top-left\"), 0); }\n+#[test] fn structure_transform_origin_top() { assert_eq!(render(\"tests\/structure\/transform-origin\/top\"), 0); }\n+#[test] fn structure_transform_origin_transform_on_parent() { assert_eq!(render(\"tests\/structure\/transform-origin\/transform-on-parent\"), 0); }\n #[test] fn structure_use_cSS_rules() { assert_eq!(render(\"tests\/structure\/use\/cSS-rules\"), 0); }\n #[test] fn structure_use_complex_style_resolving_order() { assert_eq!(render(\"tests\/structure\/use\/complex-style-resolving-order\"), 0); }\n #[test] fn structure_use_display_inheritance() { assert_eq!(render(\"tests\/structure\/use\/display-inheritance\"), 0); }\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/bottom.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/bottom.png\nnew file mode 100644\nindex 000000000..264605c47\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/bottom.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/bottom.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/bottom.svg\nnew file mode 100644\nindex 000000000..b0e46de2a\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/bottom.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>`bottom`<\/title>\n+\n+    <!-- should be covered -->\n+    <path id=\"path1\" transform=\"translate(100 200) rotate(45) translate(-100 -200)\" d=\"M 80 80 L 120 80 L 120 120 L 80 120\" fill=\"red\"\/>\n+\n+    <rect id=\"rect1\" transform=\"rotate(45)\" transform-origin=\"bottom\" x=\"80\" y=\"80\" width=\"40\" height=\"40\" fill=\"green\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/center.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/center.png\nnew file mode 100644\nindex 000000000..6dd83e651\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/center.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/center.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/center.svg\nnew file mode 100644\nindex 000000000..aa6df9692\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/center.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>`center`<\/title>\n+\n+    <!-- should be covered -->\n+    <path id=\"path1\" transform=\"translate(100 100) rotate(45) translate(-100 -100)\" d=\"M 80 80 L 120 80 L 120 120 L 80 120\" fill=\"red\"\/>\n+\n+    <rect id=\"rect1\" transform=\"rotate(45)\" transform-origin=\"center\" x=\"80\" y=\"80\" width=\"40\" height=\"40\" fill=\"green\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/keyword-length.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/keyword-length.png\nnew file mode 100644\nindex 000000000..90bdfb8e9\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/keyword-length.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/keyword-length.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/keyword-length.svg\nnew file mode 100644\nindex 000000000..6b7a8e276\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/keyword-length.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>keyword + length<\/title>\n+\n+    <!-- should be covered -->\n+    <path id=\"path1\" transform=\"translate(50 0) rotate(45) translate(-50 0)\" d=\"M 80 80 L 120 80 L 120 120 L 80 120\" fill=\"red\"\/>\n+\n+    <rect id=\"rect1\" transform=\"rotate(45)\" transform-origin=\"25% top\" x=\"80\" y=\"80\" width=\"40\" height=\"40\" fill=\"green\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/left.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/left.png\nnew file mode 100644\nindex 000000000..aa213b80f\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/left.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/left.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/left.svg\nnew file mode 100644\nindex 000000000..9a3e70d79\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/left.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>`left`<\/title>\n+\n+    <!-- should be covered -->\n+    <path id=\"path1\" transform=\"translate(0 100) rotate(45) translate(0 -100)\" d=\"M 80 80 L 120 80 L 120 120 L 80 120\" fill=\"red\"\/>\n+\n+    <rect id=\"rect1\" transform=\"rotate(45)\" transform-origin=\"left\" x=\"80\" y=\"80\" width=\"40\" height=\"40\" fill=\"green\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/length-percent.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/length-percent.png\nnew file mode 100644\nindex 000000000..6dd83e651\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/length-percent.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/length-percent.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/length-percent.svg\nnew file mode 100644\nindex 000000000..debaf6f86\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/length-percent.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>length `percent`<\/title>\n+\n+    <!-- should be covered -->\n+    <path id=\"path1\" transform=\"translate(100 100) rotate(45) translate(-100 -100)\" d=\"M 80 80 L 120 80 L 120 120 L 80 120\" fill=\"red\"\/>\n+\n+    <rect id=\"rect1\" transform=\"rotate(45)\" transform-origin=\"50% 50%\" x=\"80\" y=\"80\" width=\"40\" height=\"40\" fill=\"green\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/length-px.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/length-px.png\nnew file mode 100644\nindex 000000000..6dd83e651\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/length-px.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/length-px.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/length-px.svg\nnew file mode 100644\nindex 000000000..385d26d72\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/length-px.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>length `px`<\/title>\n+\n+    <!-- should be covered -->\n+    <path id=\"path1\" transform=\"translate(100 100) rotate(45) translate(-100 -100)\" d=\"M 80 80 L 120 80 L 120 120 L 80 120\" fill=\"red\"\/>\n+\n+    <rect id=\"rect1\" transform=\"rotate(45)\" transform-origin=\"100px 100px\" x=\"80\" y=\"80\" width=\"40\" height=\"40\" fill=\"green\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/no-transform.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/no-transform.png\nnew file mode 100644\nindex 000000000..f4eec7c22\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/no-transform.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/no-transform.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/no-transform.svg\nnew file mode 100644\nindex 000000000..cc8b5da3d\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/no-transform.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>no transform<\/title>\n+\n+    <!-- should be covered -->\n+    <path id=\"path1\"  d=\"M 80 80 L 120 80 L 120 120 L 80 120\" fill=\"red\"\/>\n+\n+    <rect id=\"rect1\" transform-origin=\"top left\" x=\"80\" y=\"80\" width=\"40\" height=\"40\" fill=\"green\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-clippath-objectBoundingBox.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-clippath-objectBoundingBox.png\nnew file mode 100644\nindex 000000000..c572c8d37\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-clippath-objectBoundingBox.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-clippath-objectBoundingBox.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-clippath-objectBoundingBox.svg\nnew file mode 100644\nindex 000000000..59c38efaa\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-clippath-objectBoundingBox.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>on `clipPath` with `clipPathUnits` `objectBoundingBox`<\/title>\n+\n+    <clipPath id=\"clip1\" clipPathUnits=\"objectBoundingBox\" transform=\"scale(2)\" transform-origin=\"center\">\n+        <rect id=\"rect1\" x=\"0.3\" y=\"0.3\" width=\"0.4\" height=\"0.4\" rx=\"0.1\" ry=\"0.1\"\/>\n+    <\/clipPath>\n+    <rect id=\"rect2\" x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"green\" clip-path=\"url(#clip1)\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-clippath.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-clippath.png\nnew file mode 100644\nindex 000000000..f31e00c9e\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-clippath.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-clippath.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-clippath.svg\nnew file mode 100644\nindex 000000000..c864f8369\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-clippath.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>on `clipPath`<\/title>\n+\n+    <clipPath id=\"clip1\" transform=\"rotate(36)\" transform-origin=\"center\">\n+        <path id=\"path1\" d=\"M 100 15 l 50 160 l -130 -100 l 160 0 l -130 100 z\"\/>\n+    <\/clipPath>\n+    <rect id=\"rect1\" x=\"0\" y=\"0\" width=\"200\" height=\"200\" fill=\"green\" clip-path=\"url(#clip1)\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\n\\ No newline at end of file\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-gradient-object-bounding-box.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-gradient-object-bounding-box.png\nnew file mode 100644\nindex 000000000..4795fee32\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-gradient-object-bounding-box.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-gradient-object-bounding-box.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-gradient-object-bounding-box.svg\nnew file mode 100644\nindex 000000000..c5badf10d\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-gradient-object-bounding-box.svg\n@@ -0,0 +1,13 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>on `gradient` with `gradientUnits` `objectBoundingBox`<\/title>\n+\n+    <radialGradient id=\"rg1\" gradientTransform=\"scale(2)\" transform-origin=\"0.5 0.5\">\n+        <stop offset=\"0\" stop-color=\"black\"\/>\n+        <stop offset=\"0.375\" stop-color=\"green\"\/>\n+    <\/radialGradient>\n+\n+    <rect id=\"rect1\" x=\"20\" y=\"20\" width=\"160\" height=\"160\" fill=\"url(#rg1)\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-gradient-user-space-on-use.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-gradient-user-space-on-use.png\nnew file mode 100644\nindex 000000000..4795fee32\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-gradient-user-space-on-use.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-gradient-user-space-on-use.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-gradient-user-space-on-use.svg\nnew file mode 100644\nindex 000000000..4cbc013d1\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-gradient-user-space-on-use.svg\n@@ -0,0 +1,13 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>on `gradient` with `gradientUnits` `userSpaceOnUse`<\/title>\n+\n+    <radialGradient id=\"rg1\" gradientUnits=\"userSpaceOnUse\" gradientTransform=\"scale(2)\" transform-origin=\"center\">\n+        <stop offset=\"0\" stop-color=\"black\"\/>\n+        <stop offset=\"0.3\" stop-color=\"green\"\/>\n+    <\/radialGradient>\n+\n+    <rect id=\"rect1\" x=\"20\" y=\"20\" width=\"160\" height=\"160\" fill=\"url(#rg1)\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-group.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-group.png\nnew file mode 100644\nindex 000000000..cbc77a5c3\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-group.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-group.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-group.svg\nnew file mode 100644\nindex 000000000..fe88fedbe\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-group.svg\n@@ -0,0 +1,10 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>on `group`<\/title>\n+\n+    <g transform=\"rotate(45)\" transform-origin=\"center\" >\n+        <rect id=\"rect1\" x=\"60\" y=\"60\" width=\"80\" height=\"80\" fill=\"green\"\/>\n+    <\/g>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-image.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-image.png\nnew file mode 100644\nindex 000000000..c38ad3be9\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-image.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-image.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-image.svg\nnew file mode 100644\nindex 000000000..60ae5fa69\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-image.svg\n@@ -0,0 +1,62 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+     xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\">\n+    <title>on `image`<\/title>\n+\n+    <image id=\"image1\" x=\"60\" y=\"60\" width=\"80\" transform=\"rotate(90)\" transform-origin=\"center\" height=\"80\" xlink:href=\"data:image\/png;base64,\n+iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAliAAAJYgFi28+MAAAA\n+BHNCSVQICAgIfAhkiAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAsUSURB\n+VHja3VsDsCvBEp1n27Zt27Zt27Zt27Zt27Ztv\/P\/qfeTt72bTXKDuvf9U9VVuUkP+sxsT3fPXoVF\n+sTNgRernWJsNWJfDu7I6E7AkPjAnLDAzCDBN+ZZ8wXS1CVNUDPVf41943fA1mYFFMYHp\/jm4X5LN\n+yusrvzIVMCMQB\/OL8kV51fhliYHp\/gwDn+qhMLKiQtsCf2RUJYUzPX2HBOW9lU9t2PJbWyukiqGg\n+lG1JG0thR9t\/kAA+4+JRWpsVmBHYOsjvqQo9iiv480dD7Qt1+pT00wRkB5YlBeZH\/p8n12zxGQH\/\n+ePi54cQgA8rQOJ\/JiAp+kYBlSYCZQX00AJ93\/7qVjxgxInr16oVNmzaB0rNnT0SIEEHoBPCvcL63\n+XyGA25sr7sIAJVJJ49OnT49nz55BjydPniBt2rRCt1w6v0AAjZ8T2tDw5WiFBfUVWuVTqJJRoX4O\n+heEVFC70+avzZoxCoAB\/DQoWLBju3bsHM9y6dQtBggSx6gcJqPB+3N\/+zvVSGFaeY3HMP2MvrK\/w\n+arQ3CVgQRTT4PFGhSxGF4IHNn99Cyf4QsbOd\/L5q1apwhIoVK4o2ezsonO2lkD+p+Xghgih0K8a5\n+eZYAPvNC+fFwhYxxxOB2J1U1k\/xuwIABcIR+\/fqJNtUy2SNbSqa4Ck9GeIyA7MLhfZmokDkuB3Jd\n+OnfuDEdo3769W2Okj63waYL7BPCoE4rcYvrB8uXLh2XLluHs2bPYs2cP2rZti6BBg5pOLlWqVPj9\n++zfM8OvXLyRPnty0PX1Iu3btsHfvXnDMpUuXIk+ePAa9XiXcJ0Dj9elkuKXlID169LBpzMmTJxE2\n+bFhTI6ZOnQozTJw40bRduHDhcPr0aejBOXTp0kXohgqq8HasewSISG5+PTmZ\/Pnz213JefPmmRqS\n+JUsWmCFjxoym7RYtWgQJSUKuXLmE\/tJGbhGQXRvh8bgRnS9fvhz28OPHD+4CjxHA1f\/58yfsgASJ\n+Nu0Luk4AY3utEs9c0fm5c+fgAPQPHiOAO84RTp06JdrUyOI6AQx+hFLDnHJCdEKO8PDhQyRKlMht\n+AhInToxHjx7BEbZv3y7aNc\/rrg+YHtCixOhLdM6jinCBBEcEuGQ80bJlS9F2dCV3CZgb1qLEqE5\/\n+HHHLuUCCQwJcMv748eMihKZc7e8OAczn54YXigxv9Y5p\/vz5dHhOkZAwYUKnCXDWeI49Z84chAkT\n+RsytRCp34oAVqbRHoNgF+liAwsHz5s2LBw8eOEOCQwKcMf7+\/ftgABQ6dGjDfEIGUbjc11UCliW2\n+Wbl9N45JCeNy8xA0bty4uHPnDuyBKW+dOnVghmrVqoFE2QOJTpAggRxfen\/OlVmkjwjgyouzn8JC\n+Zek0CoEDOhWHc4Ud7oQvX77Y\/c1146UECch6guOiirJcWGi9Pmt4g8vKSo4U13eCq6DxFj\/ivLCy\n+xAq0IwIWRBVf9iwuO3GRBN81XgjrkiYEcPW1W5+la331lhle5cqV0b9\/f3Ts2BEpU6Z04XHwrvHM\n+NDt16sQ5olKlSoZjkbt5TwcbBPCuTrv1U8eUHadLl86wmkw+mNVlyJDBrlSpUgWfP3+Gq2Bb9uFo\n+nGnTpnFOhvJa6tSp9QUTIwHaEvbJ7sbq7dOnT\/Gv4vHjx4xXhE0X++gJmGk981mLF8osXf\/r6Nq1\n+q7BpfFU9AZo\/WueXBGzZsgX\/OjZs2CBs6lTYDgEpo1Pp\/1p4\/2hOQJZ4Pu6Q3pZi9\/eQIUNaJUSI\n+EGa6Qo8SOHBgU12eTIECBfLxfHMm\/Gvvj8mSAEZONgeiM4wUKZJVeOS0bt0aq1atwu3btyn8zO\/4\n+m9AtWbIkXr9+bZUdO3YgcuTIQocSO3Zs3LhxQ+jmyJFD6DBX4FG3efNm5gO4fv06K0Fo0qQJkiRJ\n+YuiTuYJ\/\/\/6FPSzuWOxl9ViZFT7YkBVaJh0WYd2tYcOGeP78OczA36hDXbYpVKgQy1kigytQoAB\/\n+E1K2bFlo8erVK+TMmdM6LqvBHz9+hBl4VDOXsIxrkWzZsonyXNPcf+19McoOAYy59ca3atVKnrcm\n+oA53A9twAmfOnIEWNWvWNBDQokULocOSNwmg8LLEGXz\/\/p3JlqHv7Nmz83ERBDDmuTfEnABOXHRS\n+oUIFfPv2DYSzk2Ebtp0wYQK0YBlbP8nBgwcLHUZ0\/J4GkVBn8fbtWxQvXlzfPx87QcC7sQq3B5kQ\n+4M+fP9GYq7BgwQLDJcaoUaNQu3ZtCkaOHMmtbqjU8jnmc6vFpEmTkDt3bmv\/1Fm\/fr3Q4XPNcQ8d\n+OgQtvn79yh3BXYT69etjxowZ0GP48OGifwp9jIWAn1O4+j4ggM8xB9aAOYF43vi5Q4cOQoc7pnDh\n+wqhRowa0uHTpEreltS0ny5XTgs6TO0iPBg0aiHFJ0pAhQ\/QRIHVMCXg8nMb7gACyrcXLly+1A4iV\n+1DvIWrVqsawtCOSWLlKkiKUdb4T1FR\/2RZ+jr\/0J4ixCkrkjtShdurRNAupko+E+JIBeXYsjR44g\n+a9asNglgJkajLVK0aFH6E+zfvx9a1KtXz9quTZs20IJ1PhLMy1T9o0N9G+NyZ\/CxsQhJsUlAjcwu\n+EKC\/1\/\/06ZM8ypwQ+gst+FqM5bcRI0ZAC+Yg\/F7vO+hMfTKmxwigvHnzBlpMnjzZRxPgOa7FzJkz\n+rcckb5a1oHPzdQIYBFkkWbJkGDZsGPTYvXs3J8ntx4KJJXCxJfxdH7hw6\/IKjXm\/8A98bBwQQPIY\n+OzDesCnsw1UCKC5dUTEkpr+IHj06oy+Go\/yMOHHisDiB9+\/fGzw9ozctrl69yl3hiACeHHYjw+rV\n+q3uWAArr\/zyuHGHt2rWsCxrar1u3TuiVL18ejRo1Mji6TJkycYX9HgEUTo7JiCOsXr2au8DwUoUW\n+jBv0EWDTpk2t+npyxowZw52EzJkzkyDfIYASPHhwFCxYkCtE744DBw4w9IUedevWFe1Y39PH+ydO\n+nIAWDLos+vQt+gjP8htfrKQjXbhwISNO+hHvE2AmAQIEYKqKo0ePQouLFy+SLKseC5j2wFA6Xrx4\n+ThAghYnOzZs3hS6NZu2BRMWIEYO70VsEyKtvGmF248sCJaNIM3A3BAwY0BME0Efo9VwngFUdFhcs\n+EipUKNOJ6F9kYmbm7Ls+9AfU8XME8Hlnnd0iDFxYKbJFFBMdDRjzCx2dZ9cHQEKXz7HesdqaX7Ro\n+0fQOkTvPcwTwJWZ9wcPG+3lkXZ+782JF6JQrVw4S5qvGcFsfgqdJk4a\/2e2TiRednscI4GozAdLi\n+8uXLzPKsBUx+1q\/+sWPH2NZwhWULnHTMmDEdXszwxGEixn75bgKDKaa\/WvDFDbb3GAEUhrJmd3cU\n+W2AbW5Vfprt67Nq1y1DApDRr1gy2wIKofO1eHqUeJ4BHCs9dZzFr1izTEjjv8vTo06ePTV3uAv5T\n+hZNgKY1O0TUCGueikrlEjRpVlKBMQB3qmvYj8n9NodRMn7HBmjVr4AiDBg3SR58GqZXVDgEDyzgV\n+BbJUxUxQODx+5nf8jTr2+ihRogT0YAJkrw0NY4GF7yLrgyfmGMWKFXPqoqRrUTsE3ByoEDQQFR0L\n+AxamykxnKfzs7E1NlChReLQK0b\/pZe9GiPkAnS5PImapjESdaUvb9nW0QwDldE+F2lkVssVXyBDH\n+O5I8mkKscApRQlP4md\/Z1k0TUyFlDPeE\/0NQMb3CppY02kjAFxru1+TXVFG99YrcGfyHgM1+yfDf\n+0\/iKm6Vu7115PEw9V\/wXcpLgmzvhx2ReVPKuThruzZWn8W9Hqgz\/ATHEBLdMj9BLAAAAAElFTkSu\n+QmCC\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-pattern-object-bounding-box.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-pattern-object-bounding-box.png\nnew file mode 100644\nindex 000000000..32c531e6c\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-pattern-object-bounding-box.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-pattern-object-bounding-box.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-pattern-object-bounding-box.svg\nnew file mode 100644\nindex 000000000..2c1e17a79\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-pattern-object-bounding-box.svg\n@@ -0,0 +1,13 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>on `pattern` with `patternUnits` and `patternContentUnits` `objectBoundingBox`<\/title>\n+\n+    <pattern id=\"patt1\" patternUnits=\"objectBoundingBox\" patternContentUnits=\"objectBoundingBox\" width=\"1\" height=\"1\" patternTransform=\"scale(2)\" transform-origin=\"center\">\n+        <rect id=\"rect1\" x=\"0\" y=\"0\" width=\"0.5\" height=\"0.5\" fill=\"grey\"\/>\n+        <rect id=\"rect2\" x=\"0.5\" y=\"0.5\" width=\"0.5\" height=\"0.5\" fill=\"green\"\/>\n+    <\/pattern>\n+    <rect id=\"rect3\" x=\"20\" y=\"20\" width=\"160\" height=\"160\"\n+          fill=\"url(#patt1)\" stroke=\"darkblue\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-pattern-user-space-on-use.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-pattern-user-space-on-use.png\nnew file mode 100644\nindex 000000000..32c531e6c\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-pattern-user-space-on-use.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-pattern-user-space-on-use.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-pattern-user-space-on-use.svg\nnew file mode 100644\nindex 000000000..91c673393\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-pattern-user-space-on-use.svg\n@@ -0,0 +1,13 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>on `pattern` with `userSpaceOnUse`<\/title>\n+\n+    <pattern id=\"patt1\" patternUnits=\"userSpaceOnUse\" width=\"200\" height=\"200\" patternTransform=\"scale(2)\" transform-origin=\"center\">\n+        <rect id=\"rect1\" x=\"50\" y=\"50\" width=\"50\" height=\"50\" fill=\"grey\"\/>\n+        <rect id=\"rect2\" x=\"100\" y=\"100\" width=\"50\" height=\"50\" fill=\"green\"\/>\n+    <\/pattern>\n+    <rect id=\"rect3\" x=\"20\" y=\"20\" width=\"160\" height=\"160\"\n+          fill=\"url(#patt1)\" stroke=\"darkblue\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-shape.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-shape.png\nnew file mode 100644\nindex 000000000..cbc77a5c3\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-shape.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-shape.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-shape.svg\nnew file mode 100644\nindex 000000000..a3bcdaecd\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-shape.svg\n@@ -0,0 +1,8 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>on `shape`<\/title>\n+\n+    <rect id=\"rect1\" transform=\"rotate(45)\" transform-origin=\"center\" x=\"60\" y=\"60\" width=\"80\" height=\"80\" fill=\"green\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-text-path.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-text-path.png\nnew file mode 100644\nindex 000000000..b40c1f299\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-text-path.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-text-path.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-text-path.svg\nnew file mode 100644\nindex 000000000..db4dca30c\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-text-path.svg\n@@ -0,0 +1,16 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+     xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\">\n+    <title>on `text-path`<\/title>\n+\n+    <path id=\"pathForText1\" d=\"M 30 100 A 40 30 20 1 1 160 100\"\n+          fill=\"none\" stroke=\"gray\" transform=\"rotate(90)\" transform-origin=\"center\"\/>\n+\n+    <text id=\"text1\" font-family=\"Noto Sans\" font-size=\"24\">\n+        <textPath id=\"textPath1\" xlink:href=\"#pathForText1\" >\n+            abcdefghijklmnopqrstuvwxyz\n+        <\/textPath>\n+    <\/text>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-text.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-text.png\nnew file mode 100644\nindex 000000000..6df1fa985\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-text.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-text.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-text.svg\nnew file mode 100644\nindex 000000000..a8b929b20\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/on-text.svg\n@@ -0,0 +1,12 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\"\n+     font-family=\"Noto Sans\" font-size=\"64\">\n+    <title>on `text`<\/title>\n+\n+    <path id=\"crosshair\" d=\"M 20 100 L 180 100 M 100 20 L 100 180\"\n+          stroke=\"gray\" stroke-width=\"0.5\"\/>\n+\n+    <text id=\"text1\" x=\"32\" y=\"100\" transform=\"rotate(90)\" transform-origin=\"center\">Text<\/text>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/right-bottom.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/right-bottom.png\nnew file mode 100644\nindex 000000000..b061b7dc7\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/right-bottom.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/right-bottom.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/right-bottom.svg\nnew file mode 100644\nindex 000000000..c8ca71152\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/right-bottom.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>`right` + `bottom`<\/title>\n+\n+    <!-- should be covered -->\n+    <path id=\"path1\" transform=\"translate(200 200) rotate(45) translate(-200 -200)\" d=\"M 80 80 L 120 80 L 120 120 L 80 120\" fill=\"red\"\/>\n+\n+    <rect id=\"rect1\" transform=\"rotate(45)\" transform-origin=\"right bottom\" x=\"80\" y=\"80\" width=\"40\" height=\"40\" fill=\"green\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/right.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/right.png\nnew file mode 100644\nindex 000000000..aa475c7bc\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/right.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/right.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/right.svg\nnew file mode 100644\nindex 000000000..39bd1ef4d\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/right.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>`right`<\/title>\n+\n+    <!-- should be covered -->\n+    <path id=\"path1\" transform=\"translate(200 100) rotate(45) translate(-200 -100)\" d=\"M 80 80 L 120 80 L 120 120 L 80 120\" fill=\"red\"\/>\n+\n+    <rect id=\"rect1\" transform=\"rotate(45)\" transform-origin=\"right\" x=\"80\" y=\"80\" width=\"40\" height=\"40\" fill=\"green\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/top-left.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/top-left.png\nnew file mode 100644\nindex 000000000..a80726cdd\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/top-left.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/top-left.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/top-left.svg\nnew file mode 100644\nindex 000000000..d7e31b8ea\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/top-left.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>`top` + `left`<\/title>\n+\n+    <!-- should be covered -->\n+    <path id=\"path1\" transform=\"translate(0 0) rotate(45) translate(0 0)\" d=\"M 80 80 L 120 80 L 120 120 L 80 120\" fill=\"red\"\/>\n+\n+    <rect id=\"rect1\" transform=\"rotate(45)\" transform-origin=\"top left\" x=\"80\" y=\"80\" width=\"40\" height=\"40\" fill=\"green\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/top.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/top.png\nnew file mode 100644\nindex 000000000..337452d0f\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/top.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/top.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/top.svg\nnew file mode 100644\nindex 000000000..0996f02ee\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/top.svg\n@@ -0,0 +1,11 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>`top`<\/title>\n+\n+    <!-- should be covered -->\n+    <path id=\"path1\" transform=\"translate(100 0) rotate(45) translate(-100 0)\" d=\"M 80 80 L 120 80 L 120 120 L 80 120\" fill=\"red\"\/>\n+\n+    <rect id=\"rect1\" transform=\"rotate(45)\" transform-origin=\"top\" x=\"80\" y=\"80\" width=\"40\" height=\"40\" fill=\"green\"\/>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/transform-on-parent.png b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/transform-on-parent.png\nnew file mode 100644\nindex 000000000..f4eec7c22\nBinary files \/dev\/null and b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/transform-on-parent.png differ\ndiff --git a\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/transform-on-parent.svg b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/transform-on-parent.svg\nnew file mode 100644\nindex 000000000..cc19ca32a\n--- \/dev\/null\n+++ b\/crates\/resvg\/tests\/tests\/structure\/transform-origin\/transform-on-parent.svg\n@@ -0,0 +1,13 @@\n+<svg id=\"svg1\" viewBox=\"0 0 200 200\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <title>no transform<\/title>\n+\n+    <!-- should be covered -->\n+    <path id=\"path1\"  d=\"M 80 80 L 120 80 L 120 120 L 80 120\" fill=\"red\"\/>\n+\n+    <g transform=\"scale(2 2)\">\n+        <rect id=\"rect1\" transform-origin=\"bottom right\" x=\"40\" y=\"40\" width=\"20\" height=\"20\" fill=\"green\"\/>\n+    <\/g>\n+\n+    <!-- image frame -->\n+    <rect id=\"frame\" x=\"1\" y=\"1\" width=\"198\" height=\"198\" fill=\"none\" stroke=\"black\"\/>\n+<\/svg>\n","problem_statement":"Support `transform-origin`\nTransform origin is a part of SVG2 https:\/\/svgwg.org\/svg2-draft\/styling.html#PresentationAttributes\n","hints_text":"This is also important for me. As a workaround, I'm adding an extra `translate` to compensate. Support for `transform-origin` would be much appreciated.","created_at":1698,"merge_commit_sha":"9101f30a70398cf7acd6def11f0743d3fc69757e","ci_name_list":[]}
{"repo":"linebender\/resvg","pull_number":137,"instance_id":"linebender__resvg-137","issue_numbers":["134"],"base_commit":"d576d6d2e1efc2d319886016f337439f61257f5d","patch":"diff --git a\/.travis.yml b\/.travis.yml\nindex 2498625ac..6be7327f4 100644\n--- a\/.travis.yml\n+++ b\/.travis.yml\n@@ -13,3 +13,4 @@ env:\n   matrix:\n     - RESVG_QT_BACKEND=true\n     - RESVG_CAIRO_BACKEND=true\n+    - RESVG_RAQOTE_BACKEND=true\ndiff --git a\/BUILD.adoc b\/BUILD.adoc\nindex 8ba66a30d..e187b13ad 100755\n--- a\/BUILD.adoc\n+++ b\/BUILD.adoc\n@@ -3,15 +3,14 @@\n \n = How to build *resvg*\n \n-== Into\n+== Intro\n \n-*resvg* doesn't include a 2D graphics library and uses external ones via\n-https:\/\/en.wikipedia.org\/wiki\/Foreign_function_interface[FFI].\n+*resvg* doesn't include a 2D graphics library and uses external ones.\n Their support is implemented separately, therefore we call them _backends_.\n You can build them separately or together. +\n-At the moment, there are only two backends: *Qt* and *cairo*.\n-The first one uses the https:\/\/www.qt.io\/[Qt framework] and the second one uses the\n-https:\/\/www.cairographics.org\/[cairo] library.\n+At the moment, there are only three backends: https:\/\/www.qt.io\/[Qt],\n+https:\/\/www.cairographics.org\/[cairo] and\n+https:\/\/github.com\/jrmuizel\/raqote[raqote] (experimental).\n \n Since *resvg* is a https:\/\/www.rust-lang.org\/[Rust] library, you should build it via `cargo`. +\n To enable a backend use the `--features` option:\n@@ -21,19 +20,25 @@ To enable a backend use the `--features` option:\n cargo build --release --features=\"qt-backend\"\n # or with a cairo backend\n cargo build --release --features=\"cairo-backend\"\n-# or with both\n-cargo build --release --features=\"qt-backend cairo-backend\"\n+# or with a raqote backend\n+cargo build --release --features=\"raqote-backend\"\n+# or with all\n+cargo build --release --features=\"qt-backend cairo-backend raqote-backend\"\n ```\n \n == Dependencies\n \n * The library requires the latest stable\n   https:\/\/www.rust-lang.org\/tools\/install[Rust].\n+* All backends depend on https:\/\/github.com\/harfbuzz\/harfbuzz[harfbuzz],\n+  which will be built automatically by `cargo` and will be linked statically.\n+  https:\/\/cmake.org\/download\/[CMake] is required as a build-time dependency.\n * The _Qt backend_ requires only `QtCore` and `QtGui` libraries\n   and the JPEG image format plugin (aka `plugins\/imageformats\/qjpeg`). +\n   Technically, any Qt 5 version should work, but we only support Qt >= 5.6.\n * The _cairo backend_ requires https:\/\/www.cairographics.org\/[cairo] and `gdk-pixbuf` (part of GTK). +\n   cairo >= 1.12 and gdk-pixbuf >= 2.30\n+* The _raqote backend_ doesn't require any external dependencies.\n * (Linux, runtime) _fontconfig_. Specifically `fc-match`.\n \n == Windows\n@@ -46,7 +51,7 @@ Install:\n * https:\/\/cmake.org\/download\/[CMake] (required to build harfbuzz).\n * Qt built with MSVC via an http:\/\/download.qt.io\/official_releases\/online_installers\/qt-unified-windows-x86-online.exe[official installer].\n \n-Build using MSVC `cmd.exe` shell:\n+Build using `x64 Native Tools Command Prompt for VS 2017` shell:\n \n ```batch\n set PATH=%userprofile%\\.cargo\\bin;%PATH%\n@@ -89,21 +94,50 @@ pacman -S mingw-w64-x86_64-cmake mingw-w64-x86_64-cairo mingw-w64-x86_64-gdk-pix\n cargo.exe build --release --features \"cairo-backend\"\n ```\n \n-You can use x86\/i686 target in the same way.\n+You can use i686 target in the same way.\n \n-== Linux\n+=== raqote backend via MSVC\n \n-For all backends we need `freetype` and `fontconfig` dev libraries.\n+Install:\n \n-On Ubuntu you can install them via:\n+* `stable-x86_64-pc-windows-msvc` https:\/\/www.rust-lang.org\/tools\/install[Rust] target.\n+* https:\/\/cmake.org\/download\/[CMake] (required to build harfbuzz).\n+\n+Build using `x64 Native Tools Command Prompt for VS 2017` shell:\n+\n+```batch\n+set PATH=%userprofile%\\.cargo\\bin;C:\\Program Files\\CMake\\bin;%PATH%\n+\n+cargo.exe build --release --features \"raqote-backend\"\n+```\n+\n+=== raqote backend via MSYS2\n+\n+Install `stable-x86_64-pc-windows-gnu` https:\/\/www.rust-lang.org\/tools\/install[Rust] target.\n+And then:\n \n ```bash\n-sudo apt install pkg-config libfreetype6-dev libfontconfig1-dev\n+# install harfbuzz dependencies:\n+pacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-cmake\n+\n+cargo.exe build --release --features \"raqote-backend\"\n ```\n \n+You can use i686 target in the same way.\n+\n+== Linux\n+\n === Qt backend\n \n-Install Qt 5 using your distributive's package manager and then build *resvg*:\n+Install Qt 5 and `harfbuzz` using your distributive's package manager.\n+\n+On Ubuntu you can install them via:\n+\n+```\n+sudo apt install qtbase5-dev libharfbuzz-dev\n+```\n+\n+Build `resvg`:\n \n ```bash\n cargo build --release --features \"qt-backend\"\n@@ -117,12 +151,12 @@ PKG_CONFIG_PATH='\/path_to_qt\/lib\/pkgconfig' cargo build --release --features \"qt\n \n === cairo backend\n \n-Install `cairo` and `gdk-pixbuf` using your distributive's package manager.\n+Install `cairo`, `gdk-pixbuf` and `harfbuzz` using your distributive's package manager.\n \n On Ubuntu you can install them via:\n \n ```\n-sudo apt install libcairo2-dev libgdk-pixbuf2.0-dev\n+sudo apt install libcairo2-dev libgdk-pixbuf2.0-dev libharfbuzz-dev\n ```\n \n Build `resvg`:\n@@ -131,6 +165,22 @@ Build `resvg`:\n cargo build --release --features \"cairo-backend\"\n ```\n \n+=== raqote backend\n+\n+Install `harfbuzz` using your distributive's package manager.\n+\n+On Ubuntu you can install it via:\n+\n+```\n+sudo apt install libharfbuzz-dev\n+```\n+\n+Build `resvg`:\n+\n+```bash\n+cargo build --release --features \"raqote-backend\"\n+```\n+\n == macOS\n \n === Qt backend\n@@ -162,6 +212,12 @@ brew install cairo gdk-pixbuf\n cargo build --release --features \"cairo-backend\"\n ```\n \n+=== raqote backend\n+\n+```bash\n+cargo build --release --features \"raqote-backend\"\n+```\n+\n == For maintainers\n \n *resvg* consists of 4 parts:\ndiff --git a\/CHANGELOG.md b\/CHANGELOG.md\nindex 9b1a48e2c..f8928d4f2 100644\n--- a\/CHANGELOG.md\n+++ b\/CHANGELOG.md\n@@ -21,6 +21,8 @@ This changelog also contains important changes in dependencies.\n - (usvg) `--quiet` argument.\n - (c-api) `resvg_get_image_bbox`.\n - (qt-api) `ResvgRenderer::boundingBox`.\n+- (resvg) A [raqote](https:\/\/github.com\/jrmuizel\/raqote) backend thanks to\n+  [jrmuizel](https:\/\/github.com\/jrmuizel). Still experimental.\n \n ### Changed\n - Text will be converted into paths on the `usvg` side now.\ndiff --git a\/Cargo.lock b\/Cargo.lock\nindex 35849e8b8..50a444dda 100644\n--- a\/Cargo.lock\n+++ b\/Cargo.lock\n@@ -21,6 +21,11 @@ dependencies = [\n  \"nodrop 0.1.13 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"autocfg\"\n+version = \"0.1.4\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+\n [[package]]\n name = \"base64\"\n version = \"0.10.1\"\n@@ -142,11 +147,39 @@ dependencies = [\n  \"matches 0.1.8 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"deflate\"\n+version = \"0.7.19\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"adler32 1.0.3 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"byteorder 1.3.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"difference\"\n version = \"2.0.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n \n+[[package]]\n+name = \"euclid\"\n+version = \"0.19.9\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"euclid_macros 0.1.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"num-traits 0.2.8 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"euclid_macros\"\n+version = \"0.1.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"proc-macro2 0.4.30 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"quote 0.6.12 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"syn 0.15.36 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"fern\"\n version = \"0.5.8\"\n@@ -310,6 +343,36 @@ dependencies = [\n  \"harfbuzz-sys 0.3.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"image\"\n+version = \"0.21.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"byteorder 1.3.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"jpeg-decoder 0.1.15 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"lzw 0.10.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"num-iter 0.1.39 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"num-rational 0.2.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"num-traits 0.2.8 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"png 0.14.1 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"inflate\"\n+version = \"0.4.5\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"adler32 1.0.3 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"jpeg-decoder\"\n+version = \"0.1.15\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"byteorder 1.3.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"kurbo\"\n version = \"0.2.3\"\n@@ -346,6 +409,21 @@ dependencies = [\n  \"cfg-if 0.1.9 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"lyon_geom\"\n+version = \"0.12.6\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"arrayvec 0.4.10 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"euclid 0.19.9 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"num-traits 0.2.8 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"lzw\"\n+version = \"0.10.0\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+\n [[package]]\n name = \"matches\"\n version = \"0.1.8\"\n@@ -365,6 +443,43 @@ name = \"nodrop\"\n version = \"0.1.13\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n \n+[[package]]\n+name = \"num-integer\"\n+version = \"0.1.41\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"autocfg 0.1.4 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"num-traits 0.2.8 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"num-iter\"\n+version = \"0.1.39\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"autocfg 0.1.4 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"num-integer 0.1.41 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"num-traits 0.2.8 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"num-rational\"\n+version = \"0.2.2\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"autocfg 0.1.4 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"num-integer 0.1.41 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"num-traits 0.2.8 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"num-traits\"\n+version = \"0.2.8\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"autocfg 0.1.4 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"output_vt100\"\n version = \"0.1.2\"\n@@ -394,6 +509,17 @@ name = \"pkg-config\"\n version = \"0.3.14\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n \n+[[package]]\n+name = \"png\"\n+version = \"0.14.1\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"bitflags 1.1.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"deflate 0.7.19 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"inflate 0.4.5 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"num-iter 0.1.39 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"pretty_assertions\"\n version = \"0.6.1\"\n@@ -421,6 +547,18 @@ dependencies = [\n  \"proc-macro2 0.4.30 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"raqote\"\n+version = \"0.5.1\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+dependencies = [\n+ \"euclid 0.19.9 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"lyon_geom 0.12.6 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"png 0.14.1 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"sw-composite 0.5.10 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"typed-arena 1.4.1 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rctree\"\n version = \"0.3.2\"\n@@ -448,7 +586,9 @@ version = \"0.6.1\"\n dependencies = [\n  \"cairo-rs 0.6.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n  \"gdk-pixbuf 0.6.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"image 0.21.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n  \"log 0.4.6 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"raqote 0.5.1 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n  \"resvg-qt 0.6.1\",\n  \"rgb 0.8.13 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n  \"usvg 0.6.1\",\n@@ -530,6 +670,11 @@ dependencies = [\n  \"phf 0.7.24 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"sw-composite\"\n+version = \"0.5.10\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+\n [[package]]\n name = \"syn\"\n version = \"0.14.9\"\n@@ -565,6 +710,11 @@ name = \"ttf-parser\"\n version = \"0.1.0\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n \n+[[package]]\n+name = \"typed-arena\"\n+version = \"1.4.1\"\n+source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n+\n [[package]]\n name = \"unicode-bidi\"\n version = \"0.3.4\"\n@@ -646,6 +796,7 @@ source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n \"checksum adler32 1.0.3 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"7e522997b529f05601e05166c07ed17789691f562762c7f3b987263d2dedee5c\"\n \"checksum ansi_term 0.11.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n \"checksum arrayvec 0.4.10 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"92c7fb76bc8826a8b33b4ee5bb07a247a81e76764ab4d55e8f73e3a4d8808c71\"\n+\"checksum autocfg 0.1.4 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"0e49efa51329a5fd37e7c79db4621af617cd4e3e5bc224939808d076077077bf\"\n \"checksum base64 0.10.1 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"0b25d992356d2eb0ed82172f5248873db5560c4721f564b13cb5193bda5e668e\"\n \"checksum bitflags 1.1.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"3d155346769a6855b86399e9bc3814ab343cd3d62c7e985113d46a0ec3c281fd\"\n \"checksum byteorder 1.3.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"a7c3dd8985a7111efc5c80b44e23ecdd8c007de8ade3b96595387e812b957cf5\"\n@@ -661,7 +812,10 @@ source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n \"checksum crc32fast 1.2.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"ba125de2af0df55319f41944744ad91c71113bf74a4646efff39afe1f6842db1\"\n \"checksum ctor 0.1.9 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"3b4c17619643c1252b5f690084b82639dd7fac141c57c8e77a00e0148132092c\"\n \"checksum data-url 0.1.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"d33fe99ccedd6e84bc035f1931bb2e6be79739d6242bd895e7311c886c50dc9c\"\n+\"checksum deflate 0.7.19 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"8a6abb26e16e8d419b5c78662aa9f82857c2386a073da266840e474d5055ec86\"\n \"checksum difference 2.0.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n+\"checksum euclid 0.19.9 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"596b99621b9477e7a5f94d2d8dd13a9c5c302ac358b822c67a42b6f1054450e1\"\n+\"checksum euclid_macros 0.1.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"fdcb84c18ea5037a1c5a23039b4ff29403abce2e0d6b1daa11cf0bde2b30be15\"\n \"checksum fern 0.5.8 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"29d26fa0f4d433d1956746e66ec10d6bf4d6c8b93cd39965cceea7f7cc78c7dd\"\n \"checksum float-cmp 0.5.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"17ae3a6394183450225f33d9419cbd627b3cfc831e14f3f1146d5bcaf984e00c\"\n \"checksum foreign-types 0.3.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1\"\n@@ -679,21 +833,32 @@ source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n \"checksum gumdrop_derive 0.5.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"04c43663fd6604d9065f5cd26ae7a0301491fd941ad29b0a01665a6be3a1ddbd\"\n \"checksum harfbuzz-sys 0.3.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"e1042ab0b3e7bc1ff64f7f5935778b644ff2194a1cae5ec52167127d3fd23961\"\n \"checksum harfbuzz_rs 1.0.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"534c8e9b15d8db6e69654b07dad955f4132757194e7d2bba620d38cf08996088\"\n+\"checksum image 0.21.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"99198e595d012efccf12abf4abc08da2d97be0b0355a2b08d101347527476ba4\"\n+\"checksum inflate 0.4.5 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"1cdb29978cc5797bd8dcc8e5bf7de604891df2a8dc576973d71a281e916db2ff\"\n+\"checksum jpeg-decoder 0.1.15 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"c8b7d43206b34b3f94ea9445174bda196e772049b9bddbc620c9d29b2d20110d\"\n \"checksum kurbo 0.2.3 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"2e6076333105a72e8d2c227ba6a6da0dc3c8e5f53f02053f598a6087a1ea8991\"\n \"checksum lazy_static 1.3.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"bc5729f27f159ddd61f4df6228e827e86643d4d3e7c32183cb30a1c08f604a14\"\n \"checksum libc 0.2.58 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"6281b86796ba5e4366000be6e9e18bf35580adf9e63fbe2294aadb587613a319\"\n \"checksum libflate 0.1.23 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"76912aa0196b6f0e06d9c43ee877be45369157c06172ade12fe20ac3ee5ffa15\"\n \"checksum log 0.4.6 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"c84ec4b527950aa83a329754b01dbe3f58361d1c5efacd1f6d68c494d08a17c6\"\n+\"checksum lyon_geom 0.12.6 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"0638070e85f0e8b5da3909d8c5c0a66785b18da96a1e8dc30acb0aea9770529a\"\n+\"checksum lzw 0.10.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"7d947cbb889ed21c2a84be6ffbaebf5b4e0f4340638cba0444907e38b56be084\"\n \"checksum matches 0.1.8 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n \"checksum memmap 0.7.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"6585fd95e7bb50d6cc31e20d4cf9afb4e2ba16c5846fc76793f11218da9c475b\"\n \"checksum nodrop 0.1.13 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"2f9667ddcc6cc8a43afc9b7917599d7216aa09c463919ea32c59ed6cac8bc945\"\n+\"checksum num-integer 0.1.41 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"b85e541ef8255f6cf42bbfe4ef361305c6c135d10919ecc26126c4e5ae94bc09\"\n+\"checksum num-iter 0.1.39 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"76bd5272412d173d6bf9afdf98db8612bbabc9a7a830b7bfc9c188911716132e\"\n+\"checksum num-rational 0.2.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"f2885278d5fe2adc2f75ced642d52d879bffaceb5a2e0b1d4309ffdfb239b454\"\n+\"checksum num-traits 0.2.8 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"6ba9a427cfca2be13aa6f6403b0b7e7368fe982bfa16fccc450ce74c46cd9b32\"\n \"checksum output_vt100 0.1.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"53cdc5b785b7a58c5aad8216b3dfa114df64b0b06ae6e1501cef91df2fbdf8f9\"\n \"checksum phf 0.7.24 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"b3da44b85f8e8dfaec21adae67f95d93244b2ecf6ad2a692320598dcc8e6dd18\"\n \"checksum phf_shared 0.7.24 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"234f71a15de2288bcb7e3b6515828d22af7ec8598ee6d24c3b526fa0a80b67a0\"\n \"checksum pkg-config 0.3.14 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"676e8eb2b1b4c9043511a9b7bea0915320d7e502b0a079fb03f9635a5252b18c\"\n+\"checksum png 0.14.1 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"63daf481fdd0defa2d1d2be15c674fbfa1b0fd71882c303a91f9a79b3252c359\"\n \"checksum pretty_assertions 0.6.1 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"3f81e1644e1b54f5a68959a29aa86cde704219254669da328ecfdf6a1f09d427\"\n \"checksum proc-macro2 0.4.30 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"cf3d2011ab5c909338f7887f4fc896d35932e29146c12c8d01da6b22a80ba759\"\n \"checksum quote 0.6.12 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"faf4799c5d274f3868a4aae320a0a182cbd2baee377b378f080e16a23e9d80db\"\n+\"checksum raqote 0.5.1 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"1eb5325b144c13515099d844aea5df836234f64542fdeff41513c1929d2a8e09\"\n \"checksum rctree 0.3.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"193d11923532b462b7231e2d7fb785a9c0d580b03c0eccac460a1e9ee0e87fda\"\n \"checksum redox_syscall 0.1.54 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"12229c14a0f65c4f1cb046a3b52047cdd9da1f4b30f8a39c5063c8bae515e252\"\n \"checksum rgb 0.8.13 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"4f089652ca87f5a82a62935ec6172a534066c7b97be003cc8f702ee9a7a59c92\"\n@@ -704,10 +869,12 @@ source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n \"checksum slab 0.4.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n \"checksum svgdom 0.17.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"9ddce601e49ed213b0126ff4172cd9f5f8dba5f1df2277ecbe0e298f9865baba\"\n \"checksum svgtypes 0.4.4 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"444c882c28925ae0585df228a90f9951569588646ceca4753560de93cdd02258\"\n+\"checksum sw-composite 0.5.10 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"5eba1755094da86216f071f7a28b0453345c3e6e558ea2fd7821c55eef8fb9b2\"\n \"checksum syn 0.14.9 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"261ae9ecaa397c42b960649561949d69311f08eeaea86a65696e6e46517cf741\"\n \"checksum syn 0.15.36 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"8b4f551a91e2e3848aeef8751d0d4eec9489b6474c720fd4c55958d8d31a430c\"\n \"checksum time 0.1.42 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"db8dcfca086c1143c9270ac42a2bbd8a7ee477b78ac8e45b19abfb0cbede4b6f\"\n \"checksum ttf-parser 0.1.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"29637063e570f7e5260924119666113215386c1b94e1d1ceb4525e269dfbe2d0\"\n+\"checksum typed-arena 1.4.1 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"c6c06a92aef38bb4dc5b0df00d68496fc31307c5344c867bb61678c6e1671ec5\"\n \"checksum unicode-bidi 0.3.4 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"49f2bd0c6468a8230e1db229cff8029217cf623c767ea5d60bfbd42729ea54d5\"\n \"checksum unicode-script 0.3.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"09f03ad95feb4fde244d79985bfd79eb34ff2702fedb441d2ba3f4ff813efd19\"\n \"checksum unicode-vo 0.1.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"b1d386ff53b415b7fe27b50bb44679e2cc4660272694b7b6f3326d8480823a94\"\ndiff --git a\/Cargo.toml b\/Cargo.toml\nindex ec6e0ddd2..8b7c3f1bf 100644\n--- a\/Cargo.toml\n+++ b\/Cargo.toml\n@@ -35,9 +35,20 @@ gdk-pixbuf = { version = \"0.6\", optional = true }\n # qt backend\n resvg-qt = { path = \"resvg-qt\", version = \"0.6\", optional = true }\n \n+# raqote backend\n+raqote = { version = \"0.5.1\", default-features = false, optional = true }\n+\n+[dependencies.image]\n+version = \"0.21\"\n+default-features = false\n+features = [\"jpeg\", \"png_codec\"]\n+optional = true\n+\n+\n [features]\n cairo-backend = [\"cairo-rs\", \"gdk-pixbuf\"]\n qt-backend = [\"resvg-qt\"]\n+raqote-backend = [\"raqote\", \"image\"]\n \n [package.metadata.docs.rs]\n all-features = true\ndiff --git a\/capi\/Cargo.toml b\/capi\/Cargo.toml\nindex 0e97050d3..8740e05d3 100644\n--- a\/capi\/Cargo.toml\n+++ b\/capi\/Cargo.toml\n@@ -21,3 +21,4 @@ cairo-sys-rs = { version = \"0.8.0\", optional = true }\n [features]\n cairo-backend = [\"resvg\/cairo-backend\", \"cairo-sys-rs\"]\n qt-backend = [\"resvg\/qt-backend\"]\n+raqote-backend = [\"resvg\/raqote-backend\"]\ndiff --git a\/capi\/include\/resvg.h b\/capi\/include\/resvg.h\nindex 8702978ff..1f1796b67 100644\n--- a\/capi\/include\/resvg.h\n+++ b\/capi\/include\/resvg.h\n@@ -464,4 +464,24 @@ void resvg_qt_render_to_canvas_by_id(const resvg_render_tree *tree,\n                                      void *painter);\n #endif \/* RESVG_QT_BACKEND *\/\n \n+#ifdef RESVG_RAQOTE_BACKEND\n+\/**\n+ * @brief Renders the #resvg_render_tree to file.\n+ *\n+ * @param tree Render tree.\n+ * @param opt Rendering options.\n+ * @param file_path File path.\n+ * @return #resvg_error\n+ *\/\n+int resvg_raqote_render_to_image(const resvg_render_tree *tree,\n+                                 const resvg_options *opt,\n+                                 const char *file_path);\n+\n+\/**\n+ * Raqote backend doesn't have render_to_canvas and render_to_canvas_by_id\n+ * methods since it's a Rust library.\n+ *\/\n+\n+#endif \/* RESVG_RAQOTE_BACKEND *\/\n+\n #endif \/* RESVG_H *\/\ndiff --git a\/capi\/src\/lib.rs b\/capi\/src\/lib.rs\nindex 08d5dac71..c0f75f432 100644\n--- a\/capi\/src\/lib.rs\n+++ b\/capi\/src\/lib.rs\n@@ -260,6 +260,17 @@ pub extern \"C\" fn resvg_cairo_render_to_image(\n     render_to_image(tree, opt, file_path, backend)\n }\n \n+#[cfg(feature = \"raqote-backend\")]\n+#[no_mangle]\n+pub extern \"C\" fn resvg_raqote_render_to_image(\n+    tree: *const resvg_render_tree,\n+    opt: *const resvg_options,\n+    file_path: *const c_char,\n+) -> i32 {\n+    let backend = Box::new(resvg::backend_raqote::Backend);\n+    render_to_image(tree, opt, file_path, backend)\n+}\n+\n fn render_to_image(\n     tree: *const resvg_render_tree,\n     opt: *const resvg_options,\ndiff --git a\/src\/backend_raqote\/clip_and_mask.rs b\/src\/backend_raqote\/clip_and_mask.rs\nnew file mode 100644\nindex 000000000..bb6b255ab\n--- \/dev\/null\n+++ b\/src\/backend_raqote\/clip_and_mask.rs\n@@ -0,0 +1,166 @@\n+\/\/ This Source Code Form is subject to the terms of the Mozilla Public\n+\/\/ License, v. 2.0. If a copy of the MPL was not distributed with this\n+\/\/ file, You can obtain one at http:\/\/mozilla.org\/MPL\/2.0\/.\n+\n+use usvg::try_opt;\n+\n+use crate::{prelude::*, backend_utils::*};\n+use super::{path, RaqoteLayers, RaqoteDrawTargetExt};\n+\n+\n+pub fn clip(\n+    node: &usvg::Node,\n+    cp: &usvg::ClipPath,\n+    opt: &Options,\n+    bbox: Rect,\n+    layers: &mut RaqoteLayers,\n+    dt: &mut raqote::DrawTarget,\n+) {\n+    let clip_dt = try_opt!(layers.get());\n+    let mut clip_dt = clip_dt.borrow_mut();\n+\n+    clip_dt.clear(raqote::SolidSource { r: 0, g: 0, b: 0, a: 255 });\n+    clip_dt.set_transform(dt.get_transform());\n+    clip_dt.transform(&cp.transform.to_native());\n+\n+    if cp.units == usvg::Units::ObjectBoundingBox {\n+        clip_dt.transform(&usvg::Transform::from_bbox(bbox).to_native());\n+    }\n+\n+    let ts = *clip_dt.get_transform();\n+    for node in node.children() {\n+        clip_dt.transform(&node.transform().to_native());\n+\n+        match *node.borrow() {\n+            usvg::NodeKind::Path(ref p) => {\n+                let draw_opt = raqote::DrawOptions {\n+                    blend_mode: raqote::BlendMode::Clear,\n+                    ..Default::default()\n+                };\n+\n+                path::draw(&node.tree(), p, opt, draw_opt, &mut clip_dt);\n+            }\n+            usvg::NodeKind::Group(ref g) => {\n+                clip_group(&node, g, opt, bbox, layers, &mut clip_dt);\n+            }\n+            _ => {}\n+        }\n+\n+        clip_dt.set_transform(&ts);\n+    }\n+\n+    if let Some(ref id) = cp.clip_path {\n+        if let Some(ref clip_node) = node.tree().defs_by_id(id) {\n+            if let usvg::NodeKind::ClipPath(ref cp) = *clip_node.borrow() {\n+                clip(clip_node, cp, opt, bbox, layers, dt);\n+            }\n+        }\n+    }\n+\n+    dt.set_transform(&raqote::Transform::identity());\n+    dt.draw_image_at(0.0, 0.0, &clip_dt.as_image(), &raqote::DrawOptions {\n+        blend_mode: raqote::BlendMode::DstOut,\n+        ..Default::default()\n+    });\n+}\n+\n+fn clip_group(\n+    node: &usvg::Node,\n+    g: &usvg::Group,\n+    opt: &Options,\n+    bbox: Rect,\n+    layers: &mut RaqoteLayers,\n+    dt: &mut raqote::DrawTarget,\n+) {\n+    if let Some(ref id) = g.clip_path {\n+        if let Some(ref clip_node) = node.tree().defs_by_id(id) {\n+            if let usvg::NodeKind::ClipPath(ref cp) = *clip_node.borrow() {\n+                \/\/ If a `clipPath` child also has a `clip-path`\n+                \/\/ then we should render this child on a new canvas,\n+                \/\/ clip it, and only then draw it to the `clipPath`.\n+\n+                let clip_dt = try_opt!(layers.get());\n+                let mut clip_dt = clip_dt.borrow_mut();\n+                clip_dt.set_transform(dt.get_transform());\n+\n+                draw_group_child(&node, opt, raqote::DrawOptions::default(), &mut clip_dt);\n+                clip(clip_node, cp, opt, bbox, layers, &mut clip_dt);\n+\n+                dt.set_transform(&raqote::Transform::identity());\n+                dt.draw_image_at(0.0, 0.0, &clip_dt.as_image(), &raqote::DrawOptions {\n+                    blend_mode: raqote::BlendMode::Xor,\n+                    ..Default::default()\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+\n+fn draw_group_child(\n+    node: &usvg::Node,\n+    opt: &Options,\n+    draw_options: raqote::DrawOptions,\n+    dt: &mut raqote::DrawTarget,\n+) {\n+    if let Some(child) = node.first_child() {\n+        dt.transform(&child.transform().to_native());\n+\n+        match *child.borrow() {\n+            usvg::NodeKind::Path(ref path_node) => {\n+                path::draw(&child.tree(), path_node, opt, draw_options, dt);\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+\n+pub fn mask(\n+    node: &usvg::Node,\n+    mask: &usvg::Mask,\n+    opt: &Options,\n+    bbox: Rect,\n+    layers: &mut RaqoteLayers,\n+    sub_dt: &mut raqote::DrawTarget,\n+) {\n+    let mask_dt = try_opt!(layers.get());\n+    let mut mask_dt = mask_dt.borrow_mut();\n+\n+    {\n+        mask_dt.set_transform(sub_dt.get_transform());\n+\n+        let r = if mask.units == usvg::Units::ObjectBoundingBox {\n+            mask.rect.bbox_transform(bbox)\n+        } else {\n+            mask.rect\n+        };\n+\n+        let mut pb = raqote::PathBuilder::new();\n+        pb.rect(r.x() as f32, r.y() as f32, r.width() as f32, r.height() as f32);\n+        mask_dt.push_clip(&pb.finish());\n+\n+        if mask.content_units == usvg::Units::ObjectBoundingBox {\n+            mask_dt.transform(&usvg::Transform::from_bbox(bbox).to_native());\n+        }\n+\n+        super::render_group(node, opt, layers, &mut mask_dt);\n+        mask_dt.pop_clip();\n+    }\n+\n+    image_to_mask(mask_dt.get_data_u8_mut(), layers.image_size());\n+\n+    if let Some(ref id) = mask.mask {\n+        if let Some(ref mask_node) = node.tree().defs_by_id(id) {\n+            if let usvg::NodeKind::Mask(ref mask) = *mask_node.borrow() {\n+                self::mask(mask_node, mask, opt, bbox, layers, sub_dt);\n+            }\n+        }\n+    }\n+\n+    sub_dt.set_transform(&raqote::Transform::identity());\n+    sub_dt.draw_image_at(0.0, 0.0, &mask_dt.as_image(), &raqote::DrawOptions {\n+        blend_mode: raqote::BlendMode::DstIn,\n+        ..Default::default()\n+    });\n+}\ndiff --git a\/src\/backend_raqote\/filter.rs b\/src\/backend_raqote\/filter.rs\nnew file mode 100644\nindex 000000000..9c93c8181\n--- \/dev\/null\n+++ b\/src\/backend_raqote\/filter.rs\n@@ -0,0 +1,450 @@\n+\/\/ This Source Code Form is subject to the terms of the Mozilla Public\n+\/\/ License, v. 2.0. If a copy of the MPL was not distributed with this\n+\/\/ file, You can obtain one at http:\/\/mozilla.org\/MPL\/2.0\/.\n+\n+use std::cmp;\n+use std::rc::Rc;\n+\n+use rgb::FromSlice;\n+use log::warn;\n+\n+use usvg::{try_opt_or, ColorInterpolation as ColorSpace};\n+\n+use crate::{prelude::*, backend_utils::*};\n+use crate::backend_utils::filter::{Error, Filter, ImageExt};\n+use super::{ColorExt, RaqoteDrawTargetExt};\n+\n+type Image = filter::Image<raqote::DrawTarget>;\n+type FilterResult = filter::FilterResult<raqote::DrawTarget>;\n+\n+\n+pub fn apply(\n+    filter: &usvg::Filter,\n+    bbox: Option<Rect>,\n+    ts: &usvg::Transform,\n+    opt: &Options,\n+    canvas: &mut raqote::DrawTarget,\n+) {\n+    RaqoteFilter::apply(filter, bbox, ts, opt, canvas);\n+}\n+\n+\n+impl ImageExt for raqote::DrawTarget {\n+    fn width(&self) -> u32 {\n+        self.width() as u32\n+    }\n+\n+    fn height(&self) -> u32 {\n+        self.height() as u32\n+    }\n+\n+    fn try_clone(&self) -> Result<Self, Error> {\n+        let mut dt = raqote::DrawTarget::new(self.width(), self.height());\n+        dt.draw_image_at(0.0, 0.0, &self.as_image(), &raqote::DrawOptions {\n+            blend_mode: raqote::BlendMode::Src,\n+            ..raqote::DrawOptions::default()\n+        });\n+\n+        Ok(dt)\n+    }\n+\n+    fn clip(&mut self, region: ScreenRect) {\n+        let mut pb = raqote::PathBuilder::new();\n+        pb.rect(0.0, 0.0, self.width() as f32, region.y() as f32);\n+        pb.rect(0.0, 0.0, region.x() as f32, self.height() as f32);\n+        pb.rect(region.right() as f32, 0.0, self.width() as f32, self.height() as f32);\n+        pb.rect(0.0, region.bottom() as f32, self.width() as f32, self.height() as f32);\n+\n+        self.fill(&pb.finish(), &raqote::Source::Solid(raqote::SolidSource {\n+            r: 0,\n+            g: 0,\n+            b: 0,\n+            a: 0,\n+        }), &raqote::DrawOptions {\n+            blend_mode: raqote::BlendMode::Clear,\n+            ..Default::default()\n+        });\n+    }\n+\n+    fn clear(&mut self) {\n+        self.make_transparent();\n+    }\n+\n+    fn into_srgb(&mut self) {\n+        let data =  self.get_data_u8_mut();\n+        from_premultiplied(data);\n+\n+        for p in data.as_bgra_mut() {\n+            p.r = filter::LINEAR_RGB_TO_SRGB_TABLE[p.r as usize];\n+            p.g = filter::LINEAR_RGB_TO_SRGB_TABLE[p.g as usize];\n+            p.b = filter::LINEAR_RGB_TO_SRGB_TABLE[p.b as usize];\n+        }\n+\n+        into_premultiplied(data);\n+    }\n+\n+    fn into_linear_rgb(&mut self) {\n+        let data =  self.get_data_u8_mut();\n+        from_premultiplied(data);\n+\n+        for p in data.as_bgra_mut() {\n+            p.r = filter::SRGB_TO_LINEAR_RGB_TABLE[p.r as usize];\n+            p.g = filter::SRGB_TO_LINEAR_RGB_TABLE[p.g as usize];\n+            p.b = filter::SRGB_TO_LINEAR_RGB_TABLE[p.b as usize];\n+        }\n+\n+        into_premultiplied(data);\n+    }\n+}\n+\n+fn create_image(width: u32, height: u32) -> Result<raqote::DrawTarget, Error> {\n+    Ok(raqote::DrawTarget::new(width as i32, height as i32))\n+}\n+\n+fn copy_image(\n+    image: &raqote::DrawTarget,\n+    region: ScreenRect,\n+) -> Result<raqote::DrawTarget, Error> {\n+    let x = cmp::max(0, region.x()) as f32;\n+    let y = cmp::max(0, region.y()) as f32;\n+\n+    let mut new_image = create_image(region.width(), region.height())?;\n+\n+    new_image.draw_image_at(-x, -y, &image.as_image(), &raqote::DrawOptions {\n+        blend_mode: raqote::BlendMode::Src,\n+        ..raqote::DrawOptions::default()\n+    });\n+\n+    Ok(new_image)\n+}\n+\n+fn from_premultiplied(data: &mut [u8]) {\n+    \/\/ https:\/\/www.cairographics.org\/manual\/cairo-Image-Surfaces.html#cairo-format-t\n+\n+    for p in data.as_bgra_mut() {\n+        let a = p.a as f64 \/ 255.0;\n+        p.b = (p.b as f64 \/ a + 0.5) as u8;\n+        p.g = (p.g as f64 \/ a + 0.5) as u8;\n+        p.r = (p.r as f64 \/ a + 0.5) as u8;\n+    }\n+}\n+\n+fn into_premultiplied(data: &mut [u8]) {\n+    \/\/ https:\/\/www.cairographics.org\/manual\/cairo-Image-Surfaces.html#cairo-format-t\n+\n+    for p in data.as_bgra_mut() {\n+        let a = p.a as f64 \/ 255.0;\n+        p.b = (p.b as f64 * a + 0.5) as u8;\n+        p.g = (p.g as f64 * a + 0.5) as u8;\n+        p.r = (p.r as f64 * a + 0.5) as u8;\n+    }\n+}\n+\n+struct RaqoteFilter;\n+\n+impl Filter<raqote::DrawTarget> for RaqoteFilter {\n+    fn get_input(\n+        input: &usvg::FilterInput,\n+        region: ScreenRect,\n+        results: &[FilterResult],\n+        canvas: &raqote::DrawTarget,\n+    ) -> Result<Image, Error> {\n+        match input {\n+            usvg::FilterInput::SourceGraphic => {\n+                let image = copy_image(canvas, region)?;\n+\n+                Ok(Image {\n+                    image: Rc::new(image),\n+                    region: region.translate_to(0, 0),\n+                    color_space: ColorSpace::SRGB,\n+                })\n+            }\n+            usvg::FilterInput::SourceAlpha => {\n+                let mut image = copy_image(canvas, region)?;\n+\n+                \/\/ Set RGB to black. Keep alpha as is.\n+                let data = image.get_data_u8_mut();\n+                for p in data.chunks_mut(4) {\n+                    p[0] = 0;\n+                    p[1] = 0;\n+                    p[2] = 0;\n+                }\n+\n+                Ok(Image {\n+                    image: Rc::new(image),\n+                    region: region.translate_to(0, 0),\n+                    color_space: ColorSpace::SRGB,\n+                })\n+            }\n+            usvg::FilterInput::Reference(ref name) => {\n+                if let Some(ref v) = results.iter().rev().find(|v| v.name == *name) {\n+                    Ok(v.image.clone())\n+                } else {\n+                    \/\/ Technically unreachable.\n+                    warn!(\"Unknown filter primitive reference '{}'.\", name);\n+                    Self::get_input(&usvg::FilterInput::SourceGraphic, region, results, canvas)\n+                }\n+            }\n+            _ => {\n+                warn!(\"Filter input '{}' is not supported.\", input.to_string());\n+                Self::get_input(&usvg::FilterInput::SourceGraphic, region, results, canvas)\n+            }\n+        }\n+    }\n+\n+    fn apply_blur(\n+        fe: &usvg::FeGaussianBlur,\n+        units: usvg::Units,\n+        cs: ColorSpace,\n+        bbox: Option<Rect>,\n+        ts: &usvg::Transform,\n+        input: Image,\n+    ) -> Result<Image, Error> {\n+        let (std_dx, std_dy) = try_opt_or!(Self::resolve_std_dev(fe, units, bbox, ts), Ok(input));\n+\n+        let input = input.into_color_space(cs)?;\n+        let mut buffer = input.take()?;\n+\n+        let (w, h) = (buffer.width() as u32, buffer.height() as u32);\n+\n+        let data = buffer.get_data_u8_mut();\n+        from_premultiplied(data);\n+        filter::blur::apply(data, w, h, std_dx, std_dy, 4);\n+        into_premultiplied(data);\n+\n+        Ok(Image::from_image(buffer, cs))\n+    }\n+\n+    fn apply_offset(\n+        fe: &usvg::FeOffset,\n+        units: usvg::Units,\n+        bbox: Option<Rect>,\n+        ts: &usvg::Transform,\n+        input: Image,\n+    ) -> Result<Image, Error> {\n+        let (dx, dy) = try_opt_or!(Self::resolve_offset(fe, units, bbox, ts), Ok(input));\n+\n+        \/\/ TODO: do not use an additional buffer\n+        let mut dt = create_image(input.width(), input.height())?;\n+        dt.draw_image_at(\n+            dx as f32, dy as f32, &input.as_ref().as_image(), &raqote::DrawOptions::default(),\n+        );\n+\n+        Ok(Image::from_image(dt, input.color_space))\n+    }\n+\n+    fn apply_blend(\n+        fe: &usvg::FeBlend,\n+        cs: ColorSpace,\n+        region: ScreenRect,\n+        input1: Image,\n+        input2: Image,\n+    ) -> Result<Image, Error> {\n+        let input1 = input1.into_color_space(cs)?;\n+        let input2 = input2.into_color_space(cs)?;\n+\n+        let mut dt = create_image(region.width(), region.height())?;\n+        let draw_opt = raqote::DrawOptions {\n+            blend_mode: raqote::BlendMode::Src,\n+            ..raqote::DrawOptions::default()\n+        };\n+        dt.draw_image_at(0.0, 0.0, &input2.as_ref().as_image(), &draw_opt);\n+\n+        let blend_mode = match fe.mode {\n+            usvg::FeBlendMode::Normal => raqote::BlendMode::SrcOver,\n+            usvg::FeBlendMode::Multiply => raqote::BlendMode::Multiply,\n+            usvg::FeBlendMode::Screen => raqote::BlendMode::Screen,\n+            usvg::FeBlendMode::Darken => raqote::BlendMode::Darken,\n+            usvg::FeBlendMode::Lighten => raqote::BlendMode::Lighten,\n+        };\n+\n+        let draw_opt = raqote::DrawOptions { blend_mode, ..raqote::DrawOptions::default() };\n+        dt.draw_image_at(0.0, 0.0, &input1.as_ref().as_image(), &draw_opt);\n+\n+        Ok(Image::from_image(dt, cs))\n+    }\n+\n+    fn apply_composite(\n+        fe: &usvg::FeComposite,\n+        cs: ColorSpace,\n+        region: ScreenRect,\n+        input1: Image,\n+        input2: Image,\n+    ) -> Result<Image, Error> {\n+        use rgb::alt::BGRA8;\n+\n+        let mut input1 = input1.into_color_space(cs)?.take()?;\n+        let mut input2 = input2.into_color_space(cs)?.take()?;\n+\n+        let mut dt = create_image(region.width(), region.height())?;\n+\n+        if let Operator::Arithmetic { k1, k2, k3, k4 } = fe.operator {\n+            let data1 = input1.get_data_u8_mut();\n+            let data2 = input2.get_data_u8_mut();\n+\n+            let calc = |i1, i2, max| {\n+                let i1 = i1 as f64 \/ 255.0;\n+                let i2 = i2 as f64 \/ 255.0;\n+                let result = k1.value() * i1 * i2 + k2.value() * i1 + k3.value() * i2 + k4.value();\n+                f64_bound(0.0, result, max)\n+            };\n+\n+            {\n+                let mut i = 0;\n+                let data3 = dt.get_data_u8_mut();\n+                let data3 = data3.as_bgra_mut();\n+                for (c1, c2) in data1.as_bgra().iter().zip(data2.as_bgra()) {\n+                    let a = calc(c1.a, c2.a, 1.0);\n+                    if a.is_fuzzy_zero() {\n+                        continue;\n+                    }\n+\n+                    let r = (calc(c1.r, c2.r, a) * 255.0) as u8;\n+                    let g = (calc(c1.g, c2.g, a) * 255.0) as u8;\n+                    let b = (calc(c1.b, c2.b, a) * 255.0) as u8;\n+                    let a = (a * 255.0) as u8;\n+\n+                    data3[i] = BGRA8 { r, g, b, a };\n+\n+                    i += 1;\n+                }\n+            }\n+\n+            return Ok(Image::from_image(dt, cs));\n+        }\n+\n+        let draw_opt = raqote::DrawOptions {\n+            blend_mode: raqote::BlendMode::Src,\n+            ..raqote::DrawOptions::default()\n+        };\n+        dt.draw_image_at(0.0, 0.0, &input2.as_image(), &draw_opt);\n+\n+        use usvg::FeCompositeOperator as Operator;\n+        let blend_mode = match fe.operator {\n+            Operator::Over => raqote::BlendMode::SrcOver,\n+            Operator::In => raqote::BlendMode::SrcIn,\n+            Operator::Out => raqote::BlendMode::SrcOut,\n+            Operator::Atop => raqote::BlendMode::SrcAtop,\n+            Operator::Xor => raqote::BlendMode::Xor,\n+            Operator::Arithmetic { .. } => raqote::BlendMode::SrcOver,\n+        };\n+\n+        let draw_opt = raqote::DrawOptions { blend_mode, ..raqote::DrawOptions::default() };\n+        dt.draw_image_at(0.0, 0.0, &input1.as_image(), &draw_opt);\n+\n+        Ok(Image::from_image(dt, cs))\n+    }\n+\n+    fn apply_merge(\n+        fe: &usvg::FeMerge,\n+        cs: ColorSpace,\n+        region: ScreenRect,\n+        results: &[FilterResult],\n+        canvas: &raqote::DrawTarget,\n+    ) -> Result<Image, Error> {\n+        let mut dt = create_image(region.width(), region.height())?;\n+\n+        for input in &fe.inputs {\n+            let input = Self::get_input(input, region, &results, canvas)?;\n+            let input = input.into_color_space(cs)?;\n+            dt.draw_image_at(0.0, 0.0, &input.as_ref().as_image(), &raqote::DrawOptions::default());\n+        }\n+\n+        Ok(Image::from_image(dt, cs))\n+    }\n+\n+    fn apply_flood(\n+        fe: &usvg::FeFlood,\n+        region: ScreenRect,\n+    ) -> Result<Image, Error> {\n+        let mut dt = create_image(region.width(), region.height())?;\n+\n+        let alpha = (fe.opacity.value() * 255.0) as u8;\n+        dt.clear(fe.color.to_solid(alpha));\n+\n+        Ok(Image::from_image(dt, ColorSpace::SRGB))\n+    }\n+\n+    fn apply_tile(\n+        input: Image,\n+        region: ScreenRect,\n+    ) -> Result<Image, Error> {\n+        let mut dt = create_image(region.width(), region.height())?;\n+\n+        let subregion = input.region.translate(-region.x(), -region.y());\n+\n+        let tile = copy_image(&input.image, subregion)?;\n+        let brush_ts = usvg::Transform::new_translate(subregion.x() as f64, subregion.y() as f64);\n+\n+        let ts: raqote::Transform = brush_ts.to_native();\n+        let ts = ts.inverse().unwrap();\n+        let patt = raqote::Source::Image(\n+            tile.as_image(),\n+            raqote::ExtendMode::Repeat,\n+            raqote::FilterMode::Bilinear,\n+            ts,\n+        );\n+\n+        let mut pb = raqote::PathBuilder::new();\n+        pb.rect(0.0, 0.0, region.width() as f32, region.height() as f32);\n+        dt.fill(&pb.finish(), &patt, &raqote::DrawOptions::default());\n+\n+        dt.set_transform(&raqote::Transform::default());\n+        Ok(Image::from_image(dt, ColorSpace::SRGB))\n+    }\n+\n+    fn apply_image(\n+        fe: &usvg::FeImage,\n+        region: ScreenRect,\n+        subregion: ScreenRect,\n+        opt: &Options,\n+    ) -> Result<Image, Error> {\n+        let mut dt = create_image(region.width(), region.height())?;\n+\n+        match fe.data {\n+            usvg::FeImageKind::None => {}\n+            usvg::FeImageKind::Image(ref data, format) => {\n+                let dx = (subregion.x() - region.x()) as f64;\n+                let dy = (subregion.y() - region.y()) as f64;\n+                let ctm = dt.get_transform().pre_translate(raqote::Vector::new(dx as f32, dy as f32));\n+                dt.set_transform(&ctm);\n+\n+                let view_box = usvg::ViewBox {\n+                    rect: subregion.translate_to(0, 0).to_rect(),\n+                    aspect: fe.aspect,\n+                };\n+\n+                if format == usvg::ImageFormat::SVG {\n+                    super::image::draw_svg(data, view_box, opt, &mut dt);\n+                } else {\n+                    super::image::draw_raster(data, view_box, fe.rendering_mode, opt, &mut dt);\n+                }\n+            }\n+            usvg::FeImageKind::Use(..) => {}\n+        }\n+\n+        dt.set_transform(&raqote::Transform::default());\n+        Ok(Image::from_image(dt, ColorSpace::SRGB))\n+    }\n+\n+    fn apply_to_canvas(\n+        input: Image,\n+        region: ScreenRect,\n+        canvas: &mut raqote::DrawTarget,\n+    ) -> Result<(), Error> {\n+        let input = input.into_color_space(ColorSpace::SRGB)?;\n+\n+        canvas.set_transform(&raqote::Transform::identity());\n+        canvas.make_transparent();\n+\n+        let draw_opt = raqote::DrawOptions {\n+            blend_mode: raqote::BlendMode::SrcOver,\n+            ..raqote::DrawOptions::default()\n+        };\n+        canvas.draw_image_at(\n+            region.x() as f32, region.y() as f32, &input.as_ref().as_image(), &draw_opt,\n+        );\n+\n+        Ok(())\n+    }\n+}\ndiff --git a\/src\/backend_raqote\/image.rs b\/src\/backend_raqote\/image.rs\nnew file mode 100644\nindex 000000000..eae91d53e\n--- \/dev\/null\n+++ b\/src\/backend_raqote\/image.rs\n@@ -0,0 +1,150 @@\n+\/\/ This Source Code Form is subject to the terms of the Mozilla Public\n+\/\/ License, v. 2.0. If a copy of the MPL was not distributed with this\n+\/\/ file, You can obtain one at http:\/\/mozilla.org\/MPL\/2.0\/.\n+\n+use image::GenericImageView;\n+use usvg::{try_opt, try_opt_warn};\n+\n+use crate::{prelude::*, backend_utils, backend_utils::ConvTransform};\n+use super::RaqoteDrawTargetExt;\n+\n+\n+pub fn draw(\n+    image: &usvg::Image,\n+    opt: &Options,\n+    dt: &mut raqote::DrawTarget,\n+) -> Rect {\n+    if image.visibility != usvg::Visibility::Visible {\n+        return image.view_box.rect;\n+    }\n+\n+    if image.format == usvg::ImageFormat::SVG {\n+        draw_svg(&image.data, image.view_box, opt, dt);\n+    } else {\n+        draw_raster(&image.data, image.view_box, image.rendering_mode, opt, dt);\n+    }\n+\n+    image.view_box.rect\n+}\n+\n+pub fn draw_raster(\n+    data: &usvg::ImageData,\n+    view_box: usvg::ViewBox,\n+    rendering_mode: usvg::ImageRendering,\n+    opt: &Options,\n+    dt: &mut raqote::DrawTarget,\n+) {\n+    let img = match data {\n+        usvg::ImageData::Path(ref path) => {\n+            let path = backend_utils::image::get_abs_path(path, opt);\n+            try_opt_warn!(\n+                image::open(path.clone()).ok(),\n+                \"Failed to load an external image: {:?}.\", path\n+            )\n+        }\n+        usvg::ImageData::Raw(ref data) => {\n+            match image::load_from_memory(data) {\n+                Ok(img) => img,\n+                Err(e) => {\n+                    log::warn!(\"{}\", e.to_string());\n+                    return;\n+                }\n+            }\n+        }\n+    };\n+\n+    let img_size = img.dimensions();\n+    let img_size = ScreenSize::new(img_size.0, img_size.1);\n+    let img_size = try_opt!(img_size);\n+\n+    let sub_dt = try_opt!(image_to_surface(img, img_size));\n+\n+    let (ts, clip) = backend_utils::image::prepare_sub_svg_geom(view_box, img_size);\n+\n+    let mut pb = raqote::PathBuilder::new();\n+    if let Some(clip) = clip {\n+        pb.rect(clip.x() as f32, clip.y() as f32, clip.width() as f32, clip.height() as f32);\n+    } else {\n+        \/\/ We have to clip the image before rendering because we use `Extend::Pad`.\n+        let r = backend_utils::image::image_rect(&view_box, img_size);\n+        pb.rect(r.x() as f32, r.y() as f32, r.width() as f32, r.height() as f32);\n+    }\n+\n+    let filter_mode = if rendering_mode == usvg::ImageRendering::OptimizeSpeed {\n+        raqote::FilterMode::Nearest\n+    } else {\n+        raqote::FilterMode::Bilinear\n+    };\n+\n+    let t: raqote::Transform = ts.to_native();\n+    let patt = raqote::Source::Image(\n+        sub_dt.as_image(),\n+        raqote::ExtendMode::Pad,\n+        filter_mode,\n+        t.inverse().unwrap(),\n+    );\n+\n+    dt.fill(&pb.finish(), &patt, &raqote::DrawOptions::default());\n+}\n+\n+fn image_to_surface(\n+    img: image::DynamicImage,\n+    img_size: ScreenSize,\n+) -> Option<raqote::DrawTarget> {\n+    let mut surface = raqote::DrawTarget::new(img_size.width() as i32, img_size.height() as i32);\n+    let surface_data = surface.get_data_u8_mut();\n+\n+    let w = img.dimensions().0 as u32;\n+    let h = img.dimensions().1 as u32;\n+    let pixels = img.to_rgba();\n+    \/\/ We can't iterate over pixels directly, because width may not be equal to stride.\n+    let mut i = 0;\n+    for y in 0..h {\n+        for x in 0..w {\n+            let pixel = pixels[(x,y)];\n+            let r = pixel[0] as u32;\n+            let g = pixel[1] as u32;\n+            let b = pixel[2] as u32;\n+            let a = pixel[3] as u32;\n+\n+            let tr = a * r + 0x80;\n+            let tg = a * g + 0x80;\n+            let tb = a * b + 0x80;\n+            surface_data[i + 0] = (((tb >> 8) + tb) >> 8) as u8;\n+            surface_data[i + 1] = (((tg >> 8) + tg) >> 8) as u8;\n+            surface_data[i + 2] = (((tr >> 8) + tr) >> 8) as u8;\n+            surface_data[i + 3] = a as u8; \/\/ TODO: is needed?\n+\n+            \/\/ Surface is always ARGB.\n+            i += 4;\n+        }\n+    }\n+\n+    Some(surface)\n+}\n+\n+pub fn draw_svg(\n+    data: &usvg::ImageData,\n+    view_box: usvg::ViewBox,\n+    opt: &Options,\n+    dt: &mut raqote::DrawTarget,\n+) {\n+    let (tree, sub_opt) = try_opt!(backend_utils::image::load_sub_svg(data, opt));\n+\n+    let img_size = tree.svg_node().size.to_screen_size();\n+    let (ts, clip) = backend_utils::image::prepare_sub_svg_geom(view_box, img_size);\n+\n+    if let Some(clip) = clip {\n+        let mut pb = raqote::PathBuilder::new();\n+\n+        pb.rect(clip.x() as f32, clip.y() as f32, clip.width() as f32, clip.height() as f32);\n+        dt.push_clip(&pb.finish());\n+    }\n+\n+    dt.transform(&ts.to_native());\n+    super::render_to_canvas(&tree, &sub_opt, img_size, dt);\n+\n+    if let Some(_) = clip {\n+        dt.pop_clip();\n+    }\n+}\ndiff --git a\/src\/backend_raqote\/mod.rs b\/src\/backend_raqote\/mod.rs\nnew file mode 100644\nindex 000000000..31f003160\n--- \/dev\/null\n+++ b\/src\/backend_raqote\/mod.rs\n@@ -0,0 +1,354 @@\n+\/\/ This Source Code Form is subject to the terms of the Mozilla Public\n+\/\/ License, v. 2.0. If a copy of the MPL was not distributed with this\n+\/\/ file, You can obtain one at http:\/\/mozilla.org\/MPL\/2.0\/.\n+\n+\/\/! Raqote backend implementation.\n+\n+use log::warn;\n+\n+use crate::{prelude::*, layers, backend_utils::ConvTransform};\n+\n+mod clip_and_mask;\n+mod filter;\n+mod image;\n+mod path;\n+mod style;\n+\n+\n+type RaqoteLayers = layers::Layers<raqote::DrawTarget>;\n+\n+\n+impl ConvTransform<raqote::Transform> for usvg::Transform {\n+    fn to_native(&self) -> raqote::Transform {\n+        raqote::Transform::row_major(self.a as f32, self.b as f32, self.c as f32,\n+                                     self.d as f32, self.e as f32, self.f as f32)\n+    }\n+\n+    fn from_native(ts: &raqote::Transform) -> Self {\n+        Self::new(ts.m11 as f64, ts.m12 as f64, ts.m21 as f64,\n+                  ts.m22 as f64, ts.m31 as f64, ts.m32 as f64)\n+    }\n+}\n+\n+\n+pub(crate) trait RaqoteDrawTargetExt {\n+    fn transform(&mut self, ts: &raqote::Transform);\n+    fn as_image(&self) -> raqote::Image;\n+    fn make_transparent(&mut self);\n+}\n+\n+impl RaqoteDrawTargetExt for raqote::DrawTarget {\n+    fn transform(&mut self, ts: &raqote::Transform) {\n+        self.set_transform(&self.get_transform().pre_mul(ts));\n+    }\n+\n+    fn as_image(&self) -> raqote::Image {\n+        raqote::Image {\n+            width: self.width() as i32,\n+            height: self.height() as i32,\n+            data: self.get_data(),\n+        }\n+    }\n+\n+    fn make_transparent(&mut self) {\n+        \/\/ This is faster than DrawTarget::clear.\n+        for i in self.get_data_u8_mut() {\n+            *i = 0;\n+        }\n+    }\n+}\n+\n+pub(crate) trait ColorExt {\n+    fn to_solid(&self, a: u8) -> raqote::SolidSource;\n+    fn to_u32(&self, a: u8) -> u32;\n+}\n+\n+impl ColorExt for usvg::Color {\n+    fn to_solid(&self, a: u8) -> raqote::SolidSource {\n+        raqote::SolidSource {\n+            r: premultiply(self.red, a),\n+            g: premultiply(self.green, a),\n+            b: premultiply(self.blue, a),\n+            a,\n+        }\n+    }\n+\n+    fn to_u32(&self, a: u8) -> u32 {\n+        let r = self.red as u32;\n+        let g = self.green as u32;\n+        let b = self.blue as u32;\n+\n+        ((a as u32 & 0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff)\n+    }\n+}\n+\n+fn premultiply(c: u8, a: u8) -> u8 {\n+    let c = a as u32 * c as u32 + 0x80;\n+    (((c >> 8) + c) >> 8) as u8\n+}\n+\n+\n+\/\/\/ Raqote backend handle.\n+#[derive(Clone, Copy)]\n+pub struct Backend;\n+\n+impl Render for Backend {\n+    fn render_to_image(\n+        &self,\n+        tree: &usvg::Tree,\n+        opt: &Options,\n+    ) -> Option<Box<OutputImage>> {\n+        let img = render_to_image(tree, opt)?;\n+        Some(Box::new(img))\n+    }\n+\n+    fn render_node_to_image(\n+        &self,\n+        node: &usvg::Node,\n+        opt: &Options,\n+    ) -> Option<Box<OutputImage>> {\n+        let img = render_node_to_image(node, opt)?;\n+        Some(Box::new(img))\n+    }\n+}\n+\n+impl OutputImage for raqote::DrawTarget {\n+    fn save(&self, path: &::std::path::Path) -> bool {\n+        self.write_png(path).is_ok()\n+    }\n+}\n+\n+\n+\/\/\/ Renders SVG to image.\n+pub fn render_to_image(\n+    tree: &usvg::Tree,\n+    opt: &Options,\n+) -> Option<raqote::DrawTarget> {\n+    let (mut dt, img_view) = create_target(\n+        tree.svg_node().size.to_screen_size(),\n+        opt,\n+    )?;\n+\n+    \/\/ Fill background.\n+    if let Some(c) = opt.background {\n+        dt.clear(raqote::SolidSource { r: c.red, g: c.green, b: c.blue, a: 255 });\n+    }\n+\n+    render_to_canvas(tree, opt, img_view, &mut dt);\n+\n+    Some(dt)\n+}\n+\n+\/\/\/ Renders SVG to image.\n+pub fn render_node_to_image(\n+    node: &usvg::Node,\n+    opt: &Options,\n+) -> Option<raqote::DrawTarget> {\n+    let node_bbox = if let Some(bbox) = node.calculate_bbox() {\n+        bbox\n+    } else {\n+        warn!(\"Node '{}' has a zero size.\", node.id());\n+        return None;\n+    };\n+\n+    let (mut dt, img_size) = create_target(node_bbox.to_screen_size(), opt)?;\n+\n+    let vbox = usvg::ViewBox {\n+        rect: node_bbox,\n+        aspect: usvg::AspectRatio::default(),\n+    };\n+\n+    \/\/ Fill background.\n+    if let Some(c) = opt.background {\n+        dt.clear(raqote::SolidSource { r: c.red, g: c.green, b: c.blue, a: 255 });\n+    }\n+\n+    render_node_to_canvas(node, opt, vbox, img_size, &mut dt);\n+\n+    Some(dt)\n+}\n+\n+\/\/\/ Renders SVG to canvas.\n+pub fn render_to_canvas(\n+    tree: &usvg::Tree,\n+    opt: &Options,\n+    img_size: ScreenSize,\n+    dt: &mut raqote::DrawTarget,\n+) {\n+    render_node_to_canvas(&tree.root(), opt, tree.svg_node().view_box, img_size, dt);\n+}\n+\n+\/\/\/ Renders SVG node to canvas.\n+pub fn render_node_to_canvas(\n+    node: &usvg::Node,\n+    opt: &Options,\n+    view_box: usvg::ViewBox,\n+    img_size: ScreenSize,\n+    dt: &mut raqote::DrawTarget,\n+) {\n+    let mut layers = create_layers(img_size);\n+\n+    apply_viewbox_transform(view_box, img_size, dt);\n+\n+    let curr_ts = *dt.get_transform();\n+    let mut ts = node.abs_transform();\n+    ts.append(&node.transform());\n+\n+    dt.transform(&ts.to_native());\n+    render_node(node, opt, &mut layers, dt);\n+    dt.set_transform(&curr_ts);\n+}\n+\n+fn create_target(\n+    size: ScreenSize,\n+    opt: &Options,\n+) -> Option<(raqote::DrawTarget, ScreenSize)> {\n+    let img_size = utils::fit_to(size, opt.fit_to)?;\n+\n+    let dt = raqote::DrawTarget::new(img_size.width() as i32, img_size.height() as i32);\n+\n+    Some((dt, img_size))\n+}\n+\n+\/\/\/ Applies viewbox transformation to the painter.\n+fn apply_viewbox_transform(\n+    view_box: usvg::ViewBox,\n+    img_size: ScreenSize,\n+    dt: &mut raqote::DrawTarget,\n+) {\n+    let ts = utils::view_box_to_transform(view_box.rect, view_box.aspect, img_size.to_size());\n+    dt.transform(&ts.to_native());\n+}\n+\n+fn render_node(\n+    node: &usvg::Node,\n+    opt: &Options,\n+    layers: &mut RaqoteLayers,\n+    dt: &mut raqote::DrawTarget,\n+) -> Option<Rect> {\n+    match *node.borrow() {\n+        usvg::NodeKind::Svg(_) => {\n+            render_group(node, opt, layers, dt)\n+        }\n+        usvg::NodeKind::Path(ref path) => {\n+            path::draw(&node.tree(), path, opt, raqote::DrawOptions::default(), dt)\n+        }\n+        usvg::NodeKind::Image(ref img) => {\n+            Some(image::draw(img, opt, dt))\n+        }\n+        usvg::NodeKind::Group(ref g) => {\n+            render_group_impl(node, g, opt, layers, dt)\n+        }\n+        _ => None,\n+    }\n+}\n+\n+fn render_group(\n+    parent: &usvg::Node,\n+    opt: &Options,\n+    layers: &mut RaqoteLayers,\n+    dt: &mut raqote::DrawTarget,\n+) -> Option<Rect> {\n+    let curr_ts = *dt.get_transform();\n+    let mut g_bbox = Rect::new_bbox();\n+\n+    for node in parent.children() {\n+        dt.transform(&node.transform().to_native());\n+\n+        let bbox = render_node(&node, opt, layers, dt);\n+\n+        if let Some(bbox) = bbox {\n+            let bbox = bbox.transform(&node.transform()).unwrap();\n+            g_bbox = g_bbox.expand(bbox);\n+        }\n+\n+        \/\/ Revert transform.\n+        dt.set_transform(&curr_ts);\n+    }\n+\n+    \/\/ Check that bbox was changed, otherwise we will have a rect with x\/y set to f64::MAX.\n+    if g_bbox.fuzzy_ne(&Rect::new_bbox()) {\n+        Some(g_bbox)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn render_group_impl(\n+    node: &usvg::Node,\n+    g: &usvg::Group,\n+    opt: &Options,\n+    layers: &mut RaqoteLayers,\n+    dt: &mut raqote::DrawTarget,\n+) -> Option<Rect> {\n+    let sub_dt = layers.get()?;\n+    let mut sub_dt = sub_dt.borrow_mut();\n+\n+    let curr_ts = *dt.get_transform();\n+\n+    let bbox = {\n+        sub_dt.set_transform(&curr_ts);\n+        render_group(node, opt, layers, &mut sub_dt)\n+    };\n+\n+    \/\/ Filter can be rendered on an object without a bbox,\n+    \/\/ as long as filter uses `userSpaceOnUse`.\n+    if let Some(ref id) = g.filter {\n+        if let Some(filter_node) = node.tree().defs_by_id(id) {\n+            if let usvg::NodeKind::Filter(ref filter) = *filter_node.borrow() {\n+                let ts = usvg::Transform::from_native(&curr_ts);\n+                filter::apply(filter, bbox, &ts, opt, &mut sub_dt);\n+            }\n+        }\n+    }\n+\n+    \/\/ Clipping and masking can be done only for objects with a valid bbox.\n+    if let Some(bbox) = bbox {\n+        if let Some(ref id) = g.clip_path {\n+            if let Some(clip_node) = node.tree().defs_by_id(id) {\n+                if let usvg::NodeKind::ClipPath(ref cp) = *clip_node.borrow() {\n+                    sub_dt.set_transform(&curr_ts);\n+\n+                    clip_and_mask::clip(&clip_node, cp, opt, bbox, layers, &mut sub_dt);\n+                }\n+            }\n+        }\n+\n+        if let Some(ref id) = g.mask {\n+            if let Some(mask_node) = node.tree().defs_by_id(id) {\n+                if let usvg::NodeKind::Mask(ref mask) = *mask_node.borrow() {\n+                    sub_dt.set_transform(&curr_ts);\n+\n+                    clip_and_mask::mask(&mask_node, mask, opt, bbox, layers, &mut sub_dt);\n+                }\n+            }\n+        }\n+    }\n+\n+    dt.set_transform(&raqote::Transform::default());\n+\n+    dt.draw_image_at(0.0, 0.0, &sub_dt.as_image(), &raqote::DrawOptions {\n+        blend_mode: raqote::BlendMode::SrcOver,\n+        alpha: g.opacity.value() as f32,\n+        antialias: raqote::AntialiasMode::Gray,\n+    });\n+\n+    dt.set_transform(&curr_ts);\n+\n+    bbox\n+}\n+\n+fn create_layers(img_size: ScreenSize) -> RaqoteLayers {\n+    layers::Layers::new(img_size, create_subsurface, clear_subsurface)\n+}\n+\n+fn create_subsurface(\n+    size: ScreenSize,\n+) -> Option<raqote::DrawTarget> {\n+    Some(raqote::DrawTarget::new(size.width() as i32, size.height() as i32))\n+}\n+\n+fn clear_subsurface(dt: &mut raqote::DrawTarget) {\n+    dt.set_transform(&raqote::Transform::identity());\n+    dt.make_transparent();\n+}\ndiff --git a\/src\/backend_raqote\/path.rs b\/src\/backend_raqote\/path.rs\nnew file mode 100644\nindex 000000000..dbbfa1632\n--- \/dev\/null\n+++ b\/src\/backend_raqote\/path.rs\n@@ -0,0 +1,133 @@\n+\/\/ This Source Code Form is subject to the terms of the Mozilla Public\n+\/\/ License, v. 2.0. If a copy of the MPL was not distributed with this\n+\/\/ file, You can obtain one at http:\/\/mozilla.org\/MPL\/2.0\/.\n+\n+use crate::{prelude::*, backend_utils};\n+use super::style;\n+\n+\n+pub fn draw(\n+    tree: &usvg::Tree,\n+    path: &usvg::Path,\n+    opt: &Options,\n+    draw_opt: raqote::DrawOptions,\n+    dt: &mut raqote::DrawTarget,\n+) -> Option<Rect> {\n+    let mut is_butt_cap = true;\n+    if let Some(ref stroke) = path.stroke {\n+        is_butt_cap = stroke.linecap == usvg::LineCap::Butt;\n+    }\n+\n+    let mut segments = conv_path(&path.segments, is_butt_cap);\n+\n+    let bbox = utils::path_bbox(&path.segments, None, None);\n+\n+    \/\/ `usvg` guaranties that path without a bbox will not use\n+    \/\/ a paint server with ObjectBoundingBox,\n+    \/\/ so we can pass whatever rect we want, because it will not be used anyway.\n+    let style_bbox = bbox.unwrap_or_else(|| Rect::new(0.0, 0.0, 1.0, 1.0).unwrap());\n+\n+    if path.visibility != usvg::Visibility::Visible {\n+        return bbox;\n+    }\n+\n+    if let Some(ref fill) = path.fill {\n+        match fill.rule {\n+            usvg::FillRule::NonZero => segments.winding = raqote::Winding::NonZero,\n+            usvg::FillRule::EvenOdd => segments.winding = raqote::Winding::EvenOdd,\n+        }\n+    }\n+\n+    let mut draw_opt = draw_opt.clone();\n+    if !backend_utils::use_shape_antialiasing(path.rendering_mode) {\n+        draw_opt.antialias = raqote::AntialiasMode::None;\n+    }\n+\n+    style::fill(tree, &segments, &path.fill, opt, style_bbox, &draw_opt, dt);\n+    style::stroke(tree, &segments, &path.stroke, opt, style_bbox, &draw_opt, dt);\n+\n+    bbox\n+}\n+\n+fn conv_path(\n+    segments: &[usvg::PathSegment],\n+    is_butt_cap: bool,\n+) -> raqote::Path {\n+    let mut pb = raqote::PathBuilder::new();\n+\n+    let mut i = 0;\n+    loop {\n+        let subpath = get_subpath(i, segments);\n+        if subpath.is_empty() {\n+            break;\n+        }\n+\n+        conv_subpath(subpath, is_butt_cap, &mut pb);\n+        i += subpath.len();\n+    }\n+\n+    pb.finish()\n+}\n+\n+fn get_subpath(\n+    start: usize,\n+    segments: &[usvg::PathSegment],\n+) -> &[usvg::PathSegment] {\n+    let mut i = start;\n+    while i < segments.len() {\n+        match segments[i] {\n+            usvg::PathSegment::MoveTo { .. } => {\n+                if i != start {\n+                    break;\n+                }\n+            }\n+            usvg::PathSegment::ClosePath => {\n+                i += 1;\n+                break;\n+            }\n+            _ => {}\n+        }\n+\n+        i += 1;\n+    }\n+\n+    &segments[start..i]\n+}\n+\n+fn conv_subpath(\n+    segments: &[usvg::PathSegment],\n+    is_butt_cap: bool,\n+    pb: &mut raqote::PathBuilder,\n+) {\n+    assert_ne!(segments.len(), 0);\n+\n+    \/\/ Raqote doesn't support line caps on zero-length subpaths,\n+    \/\/ so we have to implement them manually.\n+    let is_zero_path = !is_butt_cap && utils::path_length(segments).is_fuzzy_zero();\n+\n+    if !is_zero_path {\n+        for seg in segments {\n+            match *seg {\n+                usvg::PathSegment::MoveTo { x, y } => {\n+                    pb.move_to(x as f32, y as f32);\n+                }\n+                usvg::PathSegment::LineTo { x, y } => {\n+                    pb.line_to(x as f32, y as f32);\n+                }\n+                usvg::PathSegment::CurveTo { x1, y1, x2, y2, x, y } => {\n+                    pb.cubic_to(x1 as f32, y1 as f32, x2 as f32, y2 as f32, x as f32, y as f32);\n+                }\n+                usvg::PathSegment::ClosePath => {\n+                    pb.close();\n+                }\n+            }\n+        }\n+    } else {\n+        if let usvg::PathSegment::MoveTo { x, y } = segments[0] {\n+            \/\/ Draw zero length path.\n+            let shift = 0.002; \/\/ Purely empirical.\n+            pb.move_to(x as f32, y as f32);\n+            pb.line_to(x as f32 + shift, y as f32);\n+        }\n+    }\n+}\ndiff --git a\/src\/backend_raqote\/style.rs b\/src\/backend_raqote\/style.rs\nnew file mode 100644\nindex 000000000..ea97d11ed\n--- \/dev\/null\n+++ b\/src\/backend_raqote\/style.rs\n@@ -0,0 +1,313 @@\n+\/\/ This Source Code Form is subject to the terms of the Mozilla Public\n+\/\/ License, v. 2.0. If a copy of the MPL was not distributed with this\n+\/\/ file, You can obtain one at http:\/\/mozilla.org\/MPL\/2.0\/.\n+\n+use usvg::try_opt;\n+\n+use crate::{prelude::*, backend_utils::ConvTransform};\n+use super::{ColorExt, RaqoteDrawTargetExt};\n+\n+\n+pub fn fill(\n+    tree: &usvg::Tree,\n+    path: &raqote::Path,\n+    fill: &Option<usvg::Fill>,\n+    opt: &Options,\n+    bbox: Rect,\n+    draw_opt: &raqote::DrawOptions,\n+    dt: &mut raqote::DrawTarget,\n+) {\n+    if let Some(ref fill) = fill {\n+        let patt_dt;\n+        let source = match fill.paint {\n+            usvg::Paint::Color(c) => {\n+                let alpha = (fill.opacity.value() * 255.0) as u8;\n+                raqote::Source::Solid(c.to_solid(alpha))\n+            }\n+            usvg::Paint::Link(ref id) => {\n+                if let Some(node) = tree.defs_by_id(id) {\n+                    match *node.borrow() {\n+                        usvg::NodeKind::LinearGradient(ref lg) => {\n+                            prepare_linear(lg, fill.opacity, bbox)\n+                        }\n+                        usvg::NodeKind::RadialGradient(ref rg) => {\n+                            prepare_radial(rg, fill.opacity, bbox)\n+                        }\n+                        usvg::NodeKind::Pattern(ref pattern) => {\n+                            let ts = *dt.get_transform();\n+                            let (sub_dt, patt_ts) = try_opt!(\n+                                prepare_pattern(&node, pattern, opt, ts, bbox, fill.opacity)\n+                            );\n+                            patt_dt = sub_dt;\n+                            create_pattern_image(&patt_dt, patt_ts)\n+                        }\n+                        _ => {\n+                            return;\n+                        }\n+                    }\n+                } else {\n+                    return;\n+                }\n+            }\n+        };\n+\n+        dt.fill(\n+            path,\n+            &source,\n+            draw_opt,\n+        );\n+    }\n+}\n+\n+pub fn stroke(\n+    tree: &usvg::Tree,\n+    path: &raqote::Path,\n+    stroke: &Option<usvg::Stroke>,\n+    opt: &Options,\n+    bbox: Rect,\n+    draw_opt: &raqote::DrawOptions,\n+    dt: &mut raqote::DrawTarget,\n+) {\n+    if let Some(ref stroke) = stroke {\n+        let cap = match stroke.linecap {\n+            usvg::LineCap::Butt => raqote::LineCap::Butt,\n+            usvg::LineCap::Round => raqote::LineCap::Round,\n+            usvg::LineCap::Square => raqote::LineCap::Square,\n+        };\n+\n+        let join = match stroke.linejoin {\n+            usvg::LineJoin::Miter => raqote::LineJoin::Miter,\n+            usvg::LineJoin::Round => raqote::LineJoin::Round,\n+            usvg::LineJoin::Bevel => raqote::LineJoin::Bevel,\n+        };\n+\n+        let mut dash_array = Vec::new();\n+        if let Some(ref list) = stroke.dasharray {\n+            dash_array = list.iter().map(|n| *n as f32).collect();\n+        }\n+\n+        let style = raqote::StrokeStyle {\n+            cap,\n+            join,\n+            width: stroke.width.value() as f32,\n+            miter_limit: stroke.miterlimit.value() as f32,\n+            dash_array,\n+            dash_offset: stroke.dashoffset,\n+        };\n+\n+        let patt_dt;\n+        let source = match stroke.paint {\n+            usvg::Paint::Color(c) => {\n+                let alpha = (stroke.opacity.value() * 255.0) as u8;\n+                raqote::Source::Solid(c.to_solid(alpha))\n+            }\n+            usvg::Paint::Link(ref id) => {\n+                if let Some(node) = tree.defs_by_id(id) {\n+                    match *node.borrow() {\n+                        usvg::NodeKind::LinearGradient(ref lg) => {\n+                            prepare_linear(lg, stroke.opacity, bbox)\n+                        }\n+                        usvg::NodeKind::RadialGradient(ref rg) => {\n+                            prepare_radial(rg, stroke.opacity, bbox)\n+                        }\n+                        usvg::NodeKind::Pattern(ref pattern) => {\n+                            let ts = *dt.get_transform();\n+                            let (sub_dt, patt_ts) = try_opt!(\n+                                prepare_pattern(&node, pattern, opt, ts, bbox, stroke.opacity)\n+                            );\n+                            patt_dt = sub_dt;\n+                            create_pattern_image(&patt_dt, patt_ts)\n+                        }\n+                        _ => {\n+                            return;\n+                        }\n+                    }\n+                } else {\n+                    return;\n+                }\n+            }\n+        };\n+\n+        dt.stroke(\n+            &path,\n+            &source,\n+            &style,\n+            draw_opt,\n+        );\n+    }\n+}\n+\n+fn prepare_linear<'a>(\n+    g: &usvg::LinearGradient,\n+    opacity: usvg::Opacity,\n+    bbox: Rect,\n+) -> raqote::Source<'a> {\n+    let ts = if g.units == usvg::Units::ObjectBoundingBox {\n+        let mut ts = usvg::Transform::from_bbox(bbox);\n+        ts.append(&g.transform);\n+        ts\n+    } else {\n+        g.transform\n+    };\n+\n+    let mut grad = raqote::Source::new_linear_gradient(\n+        raqote::Gradient { stops: conv_stops(g, opacity) },\n+        raqote::Point::new(g.x1 as f32, g.y1 as f32),\n+        raqote::Point::new(g.x2 as f32, g.y2 as f32),\n+        conv_spread(g.base.spread_method),\n+    );\n+\n+    if let raqote::Source::LinearGradient(_, _, ref mut transform) = grad {\n+        let ts: raqote::Transform = ts.to_native();\n+        if let Some(ts) = ts.inverse() {\n+            *transform = transform.pre_mul(&ts);\n+        }\n+    }\n+\n+    grad\n+}\n+\n+fn prepare_radial<'a>(\n+    g: &usvg::RadialGradient,\n+    opacity: usvg::Opacity,\n+    bbox: Rect,\n+) -> raqote::Source<'a> {\n+    let ts = if g.units == usvg::Units::ObjectBoundingBox {\n+        let mut ts = usvg::Transform::from_bbox(bbox);\n+        ts.append(&g.transform);\n+        ts\n+    } else {\n+        g.transform\n+    };\n+\n+    let mut grad;\n+\n+    if g.fx == g.cx && g.fy == g.cy {\n+        grad = raqote::Source::new_radial_gradient(\n+            raqote::Gradient { stops: conv_stops(g, opacity) },\n+            raqote::Point::new(g.cx as f32, g.cy as f32),\n+            g.r.value() as f32,\n+            conv_spread(g.base.spread_method),\n+        );\n+    } else {\n+        grad = raqote::Source::new_two_circle_radial_gradient(\n+            raqote::Gradient { stops: conv_stops(g, opacity) },\n+            raqote::Point::new(g.fx as f32, g.fy as f32),\n+            0.0,\n+            raqote::Point::new(g.cx as f32, g.cy as f32),\n+            g.r.value() as f32,\n+            conv_spread(g.base.spread_method),\n+        );\n+    }\n+\n+    match grad {\n+        raqote::Source::RadialGradient(_, _, ref mut transform)\n+        | raqote::Source::TwoCircleRadialGradient(_, _, _, _, _, _, ref mut transform) => {\n+            let ts: raqote::Transform = ts.to_native();\n+            if let Some(ts) = ts.inverse() {\n+                *transform = transform.pre_mul(&ts);\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    grad\n+}\n+\n+fn conv_spread(v: usvg::SpreadMethod) -> raqote::Spread {\n+    match v {\n+        usvg::SpreadMethod::Pad => raqote::Spread::Pad,\n+        usvg::SpreadMethod::Reflect => raqote::Spread::Reflect,\n+        usvg::SpreadMethod::Repeat => raqote::Spread::Repeat,\n+    }\n+}\n+\n+fn conv_stops(\n+    g: &usvg::BaseGradient,\n+    opacity: usvg::Opacity,\n+) -> Vec<raqote::GradientStop> {\n+    let mut stops = Vec::new();\n+\n+    for stop in &g.stops {\n+        let alpha = stop.opacity.value() * opacity.value();\n+        stops.push(raqote::GradientStop {\n+            position: stop.offset.value() as f32,\n+            color: stop.color.to_u32((alpha * 255.0) as u8),\n+        });\n+    }\n+\n+    stops\n+}\n+\n+fn prepare_pattern<'a>(\n+    pattern_node: &usvg::Node,\n+    pattern: &usvg::Pattern,\n+    opt: &Options,\n+    global_ts: raqote::Transform,\n+    bbox: Rect,\n+    opacity: usvg::Opacity,\n+) -> Option<(raqote::DrawTarget, usvg::Transform)> {\n+    let r = if pattern.units == usvg::Units::ObjectBoundingBox {\n+        pattern.rect.bbox_transform(bbox)\n+    } else {\n+        pattern.rect\n+    };\n+\n+    let global_ts = usvg::Transform::from_native(&global_ts);\n+    let (sx, sy) = global_ts.get_scale();\n+\n+    let img_size = Size::new(r.width() * sx, r.height() * sy)?.to_screen_size();\n+    let mut dt = raqote::DrawTarget::new(img_size.width() as i32, img_size.height() as i32);\n+\n+    dt.transform(&raqote::Transform::create_scale(sx as f32, sy as f32));\n+    if let Some(vbox) = pattern.view_box {\n+        let ts = utils::view_box_to_transform(vbox.rect, vbox.aspect, r.size());\n+        dt.transform(&ts.to_native());\n+    } else if pattern.content_units == usvg::Units::ObjectBoundingBox {\n+        \/\/ 'Note that this attribute has no effect if attribute `viewBox` is specified.'\n+\n+        \/\/ We don't use Transform::from_bbox(bbox) because `x` and `y` should be\n+        \/\/ ignored for some reasons...\n+        dt.transform(&raqote::Transform::create_scale(bbox.width() as f32, bbox.height() as f32));\n+    }\n+\n+    let mut layers = super::create_layers(img_size);\n+    super::render_group(pattern_node, opt, &mut layers, &mut dt);\n+\n+    let img = if !opacity.is_default() {\n+        \/\/ If `opacity` isn't `1` then we have to make image semitransparent.\n+        \/\/ The only way to do this is by making a new image and rendering\n+        \/\/ the pattern on it with transparency.\n+\n+        let mut img2 = raqote::DrawTarget::new(img_size.width() as i32, img_size.height() as i32);\n+        img2.draw_image_at(0.0, 0.0, &dt.as_image(), &raqote::DrawOptions {\n+            blend_mode: raqote::BlendMode::Src,\n+            alpha: opacity.value() as f32,\n+            ..raqote::DrawOptions::default()\n+        });\n+\n+        img2\n+    } else {\n+        dt\n+    };\n+\n+    let mut ts = usvg::Transform::default();\n+    ts.append(&pattern.transform);\n+    ts.translate(r.x(), r.y());\n+    ts.scale(1.0 \/ sx, 1.0 \/ sy);\n+\n+    Some((img, ts))\n+}\n+\n+fn create_pattern_image(\n+    dt: &raqote::DrawTarget,\n+    ts: usvg::Transform,\n+) -> raqote::Source {\n+    let ts: raqote::Transform = ts.to_native();\n+    raqote::Source::Image(\n+        dt.as_image(),\n+        raqote::ExtendMode::Repeat,\n+        raqote::FilterMode::Bilinear,\n+        ts.inverse().unwrap(),\n+    )\n+}\ndiff --git a\/src\/lib.rs b\/src\/lib.rs\nindex 877947aad..08588d5f5 100644\n--- a\/src\/lib.rs\n+++ b\/src\/lib.rs\n@@ -25,6 +25,9 @@ pub use cairo;\n #[cfg(feature = \"qt-backend\")]\n pub use resvg_qt as qt;\n \n+#[cfg(feature = \"raqote-backend\")]\n+pub use raqote;\n+\n pub use usvg::{self, svgdom, Error};\n \n \n@@ -34,6 +37,9 @@ pub mod backend_cairo;\n #[cfg(feature = \"qt-backend\")]\n pub mod backend_qt;\n \n+#[cfg(feature = \"raqote-backend\")]\n+pub mod backend_raqote;\n+\n pub mod utils;\n mod backend_utils;\n mod geom;\n@@ -101,5 +107,10 @@ pub fn default_backend() -> Box<Render> {\n         return Box::new(backend_qt::Backend);\n     }\n \n+    #[cfg(feature = \"raqote-backend\")]\n+    {\n+        return Box::new(backend_raqote::Backend);\n+    }\n+\n     unreachable!(\"at least one backend must be enabled\")\n }\ndiff --git a\/tools\/rendersvg\/Cargo.toml b\/tools\/rendersvg\/Cargo.toml\nindex 860bb1ae2..9efee47f3 100644\n--- a\/tools\/rendersvg\/Cargo.toml\n+++ b\/tools\/rendersvg\/Cargo.toml\n@@ -17,3 +17,4 @@ time = \"0.1\"\n [features]\n cairo-backend = [\"resvg\/cairo-backend\"]\n qt-backend = [\"resvg\/qt-backend\"]\n+raqote-backend = [\"resvg\/raqote-backend\"]\ndiff --git a\/tools\/rendersvg\/src\/args.rs b\/tools\/rendersvg\/src\/args.rs\nindex c93868653..58e315116 100644\n--- a\/tools\/rendersvg\/src\/args.rs\n+++ b\/tools\/rendersvg\/src\/args.rs\n@@ -301,6 +301,9 @@ fn default_backend() -> &'static str {\n     #[cfg(feature = \"qt-backend\")]\n     { return \"qt\" }\n \n+    #[cfg(feature = \"raqote-backend\")]\n+    { return \"raqote\" }\n+\n     unreachable!();\n }\n \n@@ -313,5 +316,8 @@ fn backends() -> Vec<&'static str> {\n     #[cfg(feature = \"qt-backend\")]\n     { list.push(\"qt\"); }\n \n+    #[cfg(feature = \"raqote-backend\")]\n+    { list.push(\"raqote\"); }\n+\n     list\n }\ndiff --git a\/tools\/rendersvg\/src\/main.rs b\/tools\/rendersvg\/src\/main.rs\nindex 52657227a..811255922 100644\n--- a\/tools\/rendersvg\/src\/main.rs\n+++ b\/tools\/rendersvg\/src\/main.rs\n@@ -33,7 +33,9 @@ fn main() {\n }\n \n fn process() -> Result<(), String> {\n-    #[cfg(all(not(feature = \"cairo-backend\"), not(feature = \"qt-backend\")))]\n+    #[cfg(all(not(feature = \"cairo-backend\"),\n+              not(feature = \"qt-backend\"),\n+              not(feature = \"raqote-backend\")))]\n     {\n         bail!(\"rendersvg has been built without any backends\")\n     }\n@@ -64,6 +66,8 @@ fn process() -> Result<(), String> {\n         \"cairo\" => Box::new(resvg::backend_cairo::Backend),\n         #[cfg(feature = \"qt-backend\")]\n         \"qt\" => Box::new(resvg::backend_qt::Backend),\n+        #[cfg(feature = \"raqote-backend\")]\n+        \"raqote\" => Box::new(resvg::backend_raqote::Backend),\n         _ => bail!(\"unknown backend\"),\n     };\n \n","test_patch":"diff --git a\/testing-tools\/regression\/allow-raqote.txt b\/testing-tools\/regression\/allow-raqote.txt\nnew file mode 100644\nindex 000000000..e69de29bb\ndiff --git a\/testing-tools\/regression\/regression.py b\/testing-tools\/regression\/regression.py\nindex 459aa3115..f4f69633f 100755\n--- a\/testing-tools\/regression\/regression.py\n+++ b\/testing-tools\/regression\/regression.py\n@@ -67,7 +67,7 @@ def rm_file(file_path):\n \n if __name__ == '__main__':\n     parser = argparse.ArgumentParser()\n-    parser.add_argument('--backend', help='Sets resvg backend', choices=['qt', 'cairo'])\n+    parser.add_argument('--backend', help='Sets resvg backend', choices=['qt', 'cairo', 'raqote'])\n     parser.add_argument('--use-prev-commit', help='Use previous git commit as a reference',\n                         action='store_true')\n     parser.add_argument('in_dir', type=Path, help='Sets input directory')\ndiff --git a\/testing-tools\/run-tests.py b\/testing-tools\/run-tests.py\nindex 4185efe2c..adfe7559d 100755\n--- a\/testing-tools\/run-tests.py\n+++ b\/testing-tools\/run-tests.py\n@@ -98,6 +98,20 @@ def regression_testing(backend):\n                 exit(1)\n \n \n+if 'RESVG_RAQOTE_BACKEND' in os.environ:\n+    # build raqote backend\n+    with cd('tools\/rendersvg'):\n+        run(['cargo', 'build', '--features', 'raqote-backend'], check=True)\n+\n+    # regression testing of the cairo backend\n+    if not args.no_regression:\n+        with cd('testing-tools\/regression'):\n+            try:\n+                regression_testing('raqote')\n+            except subprocess.CalledProcessError:\n+                exit(1)\n+\n+\n # # try to build with all backends\n # with cd('tools\/rendersvg'):\n #     run(['cargo', 'build', '--all-features'], check=True)\n@@ -150,3 +164,12 @@ def regression_testing(backend):\n     # build cairo-rs example\n     with cd('examples\/cairo-rs'):\n         run(['cargo', 'build'], check=True)\n+\n+\n+if 'RESVG_RAQOTE_BACKEND' in os.environ:\n+    # build C-API\n+    # with cd('capi'):\n+    #     run(['cargo', 'build', '--features', 'raqote-backend'], check=True)\n+\n+    # run tests and build examples\n+    run(['cargo', 'test', '--features', 'raqote-backend'], check=True)\n","problem_statement":"Implement a raqote backend\n@RazrFalcon have you started on this?\n","hints_text":"Yeap. Nothing to show yet, since I waiting for https:\/\/github.com\/jrmuizel\/raqote\/issues\/14\r\n\r\nI will try the latest version now.\nGreat. I'm looking forward to doing some performance and correctness work on raqote and having the ability to get real content will help with that a lot.","created_at":1557,"merge_commit_sha":"53f1cdfcf69c6849cf642249d60b8e93ca8c0feb","ci_name_list":[]}
{"repo":"linebender\/resvg","pull_number":150,"instance_id":"linebender__resvg-150","issue_numbers":["145"],"base_commit":"287619c7a7cebb19441ef307ef04483d5ab2849a","patch":"diff --git a\/Cargo.lock b\/Cargo.lock\nindex 51b3a9301..ea651e30b 100644\n--- a\/Cargo.lock\n+++ b\/Cargo.lock\n@@ -549,7 +549,7 @@ dependencies = [\n \n [[package]]\n name = \"raqote\"\n-version = \"0.5.3\"\n+version = \"0.5.5\"\n source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n dependencies = [\n  \"euclid 0.19.9 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n@@ -588,7 +588,7 @@ dependencies = [\n  \"gdk-pixbuf 0.6.0 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n  \"image 0.21.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n  \"log 0.4.6 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n- \"raqote 0.5.3 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n+ \"raqote 0.5.5 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n  \"resvg-qt 0.7.0\",\n  \"rgb 0.8.13 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\",\n  \"usvg 0.7.0\",\n@@ -858,7 +858,7 @@ source = \"registry+https:\/\/github.com\/rust-lang\/crates.io-index\"\n \"checksum pretty_assertions 0.6.1 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"3f81e1644e1b54f5a68959a29aa86cde704219254669da328ecfdf6a1f09d427\"\n \"checksum proc-macro2 0.4.30 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"cf3d2011ab5c909338f7887f4fc896d35932e29146c12c8d01da6b22a80ba759\"\n \"checksum quote 0.6.12 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"faf4799c5d274f3868a4aae320a0a182cbd2baee377b378f080e16a23e9d80db\"\n-\"checksum raqote 0.5.3 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"2ed2f21df4a18a45dfc4c5d71b18b23618c63db12e3cfc21ad2a3318049ff83d\"\n+\"checksum raqote 0.5.5 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"ff42701d43ddf150660ee0a108fb09bb4355be1e0405d9404eaf824fa3e5975f\"\n \"checksum rctree 0.3.2 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"193d11923532b462b7231e2d7fb785a9c0d580b03c0eccac460a1e9ee0e87fda\"\n \"checksum redox_syscall 0.1.54 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"12229c14a0f65c4f1cb046a3b52047cdd9da1f4b30f8a39c5063c8bae515e252\"\n \"checksum rgb 0.8.13 (registry+https:\/\/github.com\/rust-lang\/crates.io-index)\" = \"4f089652ca87f5a82a62935ec6172a534066c7b97be003cc8f702ee9a7a59c92\"\ndiff --git a\/Cargo.toml b\/Cargo.toml\nindex c163f648d..638e76958 100644\n--- a\/Cargo.toml\n+++ b\/Cargo.toml\n@@ -36,7 +36,7 @@ gdk-pixbuf = { version = \"0.6\", optional = true }\n resvg-qt = { path = \"resvg-qt\", version = \"0.7\", optional = true }\n \n # raqote backend\n-raqote = { version = \"0.5.3\", default-features = false, optional = true }\n+raqote = { version = \"0.5.5\", default-features = false, optional = true }\n \n [dependencies.image]\n version = \"0.21\"\n","test_patch":"diff --git a\/testing-tools\/regression\/allow-raqote.txt b\/testing-tools\/regression\/allow-raqote.txt\nindex e69de29bb..4e992417f 100644\n--- a\/testing-tools\/regression\/allow-raqote.txt\n+++ b\/testing-tools\/regression\/allow-raqote.txt\n@@ -0,0 +1,57 @@\n+a-clip-path-001.svg\n+a-clip-rule-001.svg\n+a-display-004.svg\n+a-display-008.svg\n+a-overflow-002.svg\n+a-systemLanguage-008.svg\n+a-visibility-007.svg\n+e-clipPath-001.svg\n+e-clipPath-002.svg\n+e-clipPath-003.svg\n+e-clipPath-004.svg\n+e-clipPath-005.svg\n+e-clipPath-006.svg\n+e-clipPath-007.svg\n+e-clipPath-008.svg\n+e-clipPath-009.svg\n+e-clipPath-010.svg\n+e-clipPath-011.svg\n+e-clipPath-012.svg\n+e-clipPath-013.svg\n+e-clipPath-014.svg\n+e-clipPath-015.svg\n+e-clipPath-016.svg\n+e-clipPath-017.svg\n+e-clipPath-018.svg\n+e-clipPath-019.svg\n+e-clipPath-020.svg\n+e-clipPath-021.svg\n+e-clipPath-029.svg\n+e-clipPath-030.svg\n+e-clipPath-031.svg\n+e-clipPath-034.svg\n+e-clipPath-035.svg\n+e-clipPath-036.svg\n+e-clipPath-037.svg\n+e-clipPath-038.svg\n+e-clipPath-039.svg\n+e-clipPath-040.svg\n+e-clipPath-041.svg\n+e-clipPath-042.svg\n+e-clipPath-044.svg\n+e-marker-002.svg\n+e-marker-003.svg\n+e-marker-004.svg\n+e-marker-008.svg\n+e-marker-009.svg\n+e-marker-036.svg\n+e-svg-024.svg\n+e-svg-025.svg\n+e-svg-026.svg\n+e-svg-027.svg\n+e-svg-030.svg\n+e-symbol-004.svg\n+e-symbol-005.svg\n+e-symbol-006.svg\n+e-symbol-008.svg\n+e-symbol-009.svg\n","problem_statement":"Panic on rendering certain files with raqote\nThe attached file causes a panic when rendering with the raqote backend. It renders fine with cairo backend. The file is zipped so that github would accept the upload. \r\n\r\nBacktrace:\r\n```\r\n> env RUST_BACKTRACE=1 \/home\/shnatsel\/Code\/resvg\/target\/release\/rendersvg --backend=raqote status\/48\/night-light-symbolic.svg ~\/out.png\r\nthread 'main' panicked at 'index 2313 out of range for slice of length 2304', src\/libcore\/slice\/mod.rs:2560:5\r\nstack backtrace:\r\n   0: std::sys::unix::backtrace::tracing::imp::unwind_backtrace\r\n             at src\/libstd\/sys\/unix\/backtrace\/tracing\/gcc_s.rs:39\r\n   1: std::sys_common::backtrace::_print\r\n             at src\/libstd\/sys_common\/backtrace.rs:71\r\n   2: std::panicking::default_hook::{{closure}}\r\n             at src\/libstd\/sys_common\/backtrace.rs:59\r\n             at src\/libstd\/panicking.rs:197\r\n   3: std::panicking::default_hook\r\n             at src\/libstd\/panicking.rs:211\r\n   4: std::panicking::rust_panic_with_hook\r\n             at src\/libstd\/panicking.rs:474\r\n   5: std::panicking::continue_panic_fmt\r\n             at src\/libstd\/panicking.rs:381\r\n   6: rust_begin_unwind\r\n             at src\/libstd\/panicking.rs:308\r\n   7: core::panicking::panic_fmt\r\n             at src\/libcore\/panicking.rs:85\r\n   8: core::slice::slice_index_len_fail\r\n             at src\/libcore\/slice\/mod.rs:2560\r\n   9: <raqote::blitter::ImagePadAlphaShader as raqote::blitter::Shader>::shade_span\r\n  10: <raqote::blitter::ShaderBlendBlitter as raqote::blitter::Blitter>::blit_span\r\n  11: raqote::draw_target::DrawTarget::composite\r\n  12: raqote::draw_target::DrawTarget::fill\r\n  13: raqote::draw_target::DrawTarget::draw_image_at\r\n  14: resvg::backend_raqote::filter::copy_image\r\n  15: <resvg::backend_raqote::filter::RaqoteFilter as resvg::backend_utils::filter::Filter<raqote::draw_target::DrawTarget>>::get_input\r\n  16: resvg::backend_raqote::filter::apply\r\n  17: resvg::backend_raqote::render_node\r\n  18: resvg::backend_raqote::render_group\r\n  19: resvg::backend_raqote::render_node\r\n  20: resvg::backend_raqote::render_node_to_canvas\r\n  21: resvg::backend_raqote::render_to_canvas\r\n  22: resvg::backend_raqote::render_to_image\r\n  23: <resvg::backend_raqote::Backend as resvg::Render>::render_to_image\r\n  24: rendersvg::main\r\n  25: std::rt::lang_start::{{closure}}\r\n  26: std::panicking::try::do_call\r\n             at src\/libstd\/rt.rs:49\r\n             at src\/libstd\/panicking.rs:293\r\n  27: __rust_maybe_catch_panic\r\n             at src\/libpanic_unwind\/lib.rs:87\r\n  28: std::rt::lang_start_internal\r\n             at src\/libstd\/panicking.rs:272\r\n             at src\/libstd\/panic.rs:388\r\n             at src\/libstd\/rt.rs:48\r\n  29: main\r\n  30: __libc_start_main\r\n  31: _start\r\n```\r\n[night-light-symbolic.svg.zip](https:\/\/github.com\/RazrFalcon\/resvg\/files\/3311845\/night-light-symbolic.svg.zip)\n","hints_text":"I'm using raqote 0.5.3 and resvg from it at commit ec197b40db61256dedd9372d986a9c21c3cf2694\r\nHere's the Cargo.lock: [Cargo.lock.zip](https:\/\/github.com\/RazrFalcon\/resvg\/files\/3311851\/Cargo.lock.zip)\r\n\r\n\r\n\ncc @jrmuizel since the backtrace points to raqote itself","created_at":1561,"merge_commit_sha":"2d5cbbd39fb17f30af074f4f8eb44efbd974a2e2","ci_name_list":[]}
