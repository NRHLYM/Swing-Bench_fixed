{"problem_statement": "Support pickling Geography objects\nAt the moment we didn't implement this, so you will get `TypeError: cannot pickle 'spherely.Point' object`, but it would be useful to support it.\r\n\r\nTo provide a full exact roundtrip through pickling, we should maybe pickle the raw unit vector (x, y, z) of the `S2Point`, instead of going through latitude/longitude like other conversions (eg WKB), because there can always be some floating point difference in this conversion.\r\n\r\n\n", "patch": "diff --git a/src/geography.cpp b/src/geography.cpp\nindex d84c177..bd527fc 100644\n--- a/src/geography.cpp\n+++ b/src/geography.cpp\n@@ -7,6 +7,7 @@\n #include <s2/s2loop.h>\n #include <s2/s2point.h>\n #include <s2/s2polygon.h>\n+#include <s2/util/coding/coder.h>\n #include <s2geography/geography.h>\n #include <s2geography/predicates.h>\n #include <s2geography/wkt-writer.h>\n@@ -171,6 +172,53 @@ void Geography::extract_geog_properties() {\n     }\n }\n \n+py::tuple Geography::encode() const {\n+    // encode geography type\n+    using IntType = std::underlying_type_t<GeographyType>;\n+    auto encoded_geog_type = static_cast<IntType>(geog_type());\n+\n+    // encode empty\n+    // (note: this is already handled internally by s2geography::Geography::EncodeTagged() but\n+    // there no current way to get the that information externally when/after decoding)\n+    auto empty = m_is_empty;\n+\n+    // encode geog\n+    Encoder geog_encoder;\n+    s2geog::EncodeOptions encode_opts;\n+    geog().EncodeTagged(&geog_encoder, encode_opts);\n+\n+    std::string encoded_geog;\n+    encoded_geog.assign(geog_encoder.base(), geog_encoder.base() + geog_encoder.length());\n+\n+    return py::make_tuple(encoded_geog_type, empty, py::bytes(encoded_geog));\n+}\n+\n+Geography Geography::decode(const py::tuple &encoded) {\n+    auto decoded = Geography();\n+\n+    // decode geography type\n+    using IntType = std::underlying_type_t<GeographyType>;\n+    GeographyType geog_type{encoded[0].cast<IntType>()};\n+    decoded.m_geog_type = geog_type;\n+\n+    // decode empty\n+    decoded.m_is_empty = encoded[1].cast<bool>();\n+\n+    // decode geog() (s2geography::Geography)\n+    auto encoded_geog = encoded[2].cast<std::string>();\n+    Decoder geog_decoder(encoded_geog.c_str(), encoded_geog.size());\n+    auto decoded_geog_ptr = s2geog::Geography::DecodeTagged(&geog_decoder);\n+\n+    // TODO: remove this quick & dirty fix (https://github.com/paleolimbot/s2geography/issues/54)\n+    if (decoded_geog_ptr->kind() == s2geog::GeographyKind::GEOGRAPHY_COLLECTION) {\n+        decoded.m_s2geog_ptr = clone_s2geography(*decoded_geog_ptr);\n+    } else {\n+        decoded.m_s2geog_ptr = std::move(decoded_geog_ptr);\n+    }\n+\n+    return decoded;\n+}\n+\n /*\n ** Geography properties\n */\n@@ -267,6 +315,9 @@ void init_geography(py::module &m) {\n         return s2geog::s2_equals(idx1, idx2, options);\n     });\n \n+    pygeography.def(py::pickle([](Geography &geog) { return geog.encode(); },\n+                               [](py::tuple &encoded) { return Geography::decode(encoded); }));\n+\n     // Geography properties\n \n     m.def(\"get_type_id\",\ndiff --git a/src/geography.hpp b/src/geography.hpp\nindex bc116ca..c703647 100644\n--- a/src/geography.hpp\n+++ b/src/geography.hpp\n@@ -107,6 +107,9 @@ class Geography {\n     Geography clone() const;\n     std::unique_ptr<s2geog::Geography> clone_geog() const;\n \n+    py::tuple encode() const;\n+    static Geography decode(const py::tuple& encoded);\n+\n private:\n     S2GeographyPtr m_s2geog_ptr;\n     S2GeographyIndexPtr m_s2geog_index_ptr;\n", "instance_id": "benbovy__spherely-82", "clarity": 2, "difficulty": 0.55, "clarity_explanation": "The problem statement is mostly clear in its intent to support pickling of Geography objects in a C++ codebase using the s2geography library. It specifies the current issue (TypeError when pickling) and suggests a solution (pickling raw unit vectors to avoid floating-point conversion issues). However, it lacks critical details such as explicit input/output formats for the pickling process, specific constraints or requirements for compatibility with Python's pickle protocol, and any mention of edge cases or performance considerations. Additionally, there are no examples provided to illustrate the expected behavior or potential challenges. While the goal is understandable, these missing details prevent it from being comprehensive.", "difficulty_explanation": "The difficulty of this problem falls into the medium range due to several factors. First, the scope of code changes is relatively contained, primarily affecting a single class (Geography) in two files (geography.cpp and geography.hpp), with the addition of encoding and decoding methods for pickling support. The changes involve a moderate amount of code (around 50 lines added), focusing on serialization using the s2 library's Encoder/Decoder utilities and integration with Python's pickle protocol via pybind11. \n\nSecond, the technical concepts required include familiarity with C++ (specifically with pybind11 for Python bindings), the s2geography library's encoding mechanisms, and Python's pickling process. Understanding how to serialize and deserialize complex geographic data structures (like S2Point) while maintaining data integrity (e.g., avoiding floating-point conversion issues) adds a layer of complexity. The code also includes a workaround for a specific issue with GeographyCollection (noted with a TODO), indicating some nuanced handling of library-specific behavior.\n\nThird, while the problem statement does not explicitly mention edge cases, the code changes suggest potential challenges, such as ensuring correct handling of empty geographies and different geography types. Error handling is implicitly required to ensure robust decoding, though not extensively detailed in the diff.\n\nFinally, the changes do not appear to impact the broader system architecture significantly, as they are localized to the Geography class and its Python interface. However, the need to understand library-specific encoding (s2/util/coding/coder.h) and manage memory ownership (e.g., cloning vs. moving geography pointers) adds moderate complexity. Overall, this task requires a solid understanding of multiple concepts and careful implementation, placing it in the medium difficulty range at 0.55.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "WebFrameMain frames and name field access SIGSEGV\n### Preflight Checklist\n\n- [x] I have read the [Contributing Guidelines](https://github.com/electron/electron/blob/main/CONTRIBUTING.md) for this project.\n- [x] I agree to follow the [Code of Conduct](https://github.com/electron/electron/blob/main/CODE_OF_CONDUCT.md) that this project adheres to.\n- [x] I have searched the [issue tracker](https://www.github.com/electron/electron/issues) for a bug report that matches the one I want to file, without success.\n\n### Electron Version\n\n33.3.0\n\n### What operating system(s) are you using?\n\nmacOS\n\n### Operating System Version\n\nmacOS Sonoma 14.3\n\n### What arch are you using?\n\narm64 (including Apple Silicon)\n\n### Last Known Working Electron version\n\n_No response_\n\n### Expected Behavior\n\nAccessing WebFrameMain `frames` and `name` attributes on destroyed frames previously threw an error.\n\n### Actual Behavior\n\nAccessing WebFrameMain `frames` and `name` attributes on destroyed frames now segfaults.\n\n```checked if frame is alive 0.8441429125447275\nchecking if frame is alive 0.7526827941185381\nchecked if frame is destroyed 0.7526827941185381\nchecking if frame is detached 0.7526827941185381\nchecked if frame is detached 0.7526827941185381\nchecking .frames 0.7526827941185381\n.../app/node_modules/electron/dist/Electron.app/Contents/MacOS/Electron exited with signal SIGSEGV```\n\nThe trace:\n\n```\nThread 0 (crashed)\n0 Electron Framework!content::FrameTree::SubtreeAndInnerTreeNodes(content::RenderFrameHostImpl*, bool) [frame_tree.cc : 353 + 0x0]\nx0 = 0xefefefefefefefef x1 = 0x0000000000000000\nx2 = 0x000000010c47eb00 x3 = 0x0000000000000000\nx4 = 0x0000000000000000 x5 = 0x000000000000000f\nx6 = 0x0000000000000180 x7 = 0x0000000000000004\nx8 = 0xaaaaaaaaaaaaaaaa x9 = 0x000000010eb2cd94\nx10 = 0xffffffffffff1e48  x11 = 0x00000d6300100000\nx12 = 0x0000000000001685  x13 = 0x0000000000000044\nx14 = 0x0000000000000010  x15 = 0x0000000000000003\nx16 = 0x000000000089cb29  x17 = 0x0000000157e0f6cc\nx18 = 0x0000000000000000  x19 = 0x000000016d59b710\nx20 = 0x0000000000000000  x21 = 0x00000104009d7e00\nx22 = 0x0000000000000000  x23 = 0x000000011528a000\nx24 = 0x00000001153b8000  x25 = 0xefefefefefefefef\nx26 = 0x0000010400510100  x27 = 0x00000d63002cdf65\nx28 = 0x00000d6300000000 fp = 0x000000016d59b680\nlr = 0x000000010eaf767c sp = 0x000000016d59b600\npc = 0x000000010ea57460\nFound by: given as instruction pointer in context\n1 Electron Framework!content::RenderFrameHostImpl::ForEachRenderFrameHostImpl(base::FunctionRef&lt;content::RenderFrameHost::FrameIterationAction (content::RenderFrameHostImpl*)&gt;, bool) [render_frame_host_impl.cc : 2713 + 0xc]\nx19 = 0x0000000000000000  x20 = 0x000000010eb2cd9c\nx21 = 0x000000016d59b790  x22 = 0x00000104009d7e00\nx23 = 0xaaaaaaaaaaaaaaaa  x24 = 0x00000001153b8000\nx25 = 0x00000104000f0280  x26 = 0x0000010400510100\nx27 = 0x00000d63002cdf65  x28 = 0x00000d6300000000\nfp = 0x000000016d59b770 sp = 0x000000016d59b690\npc = 0x000000010eaf767c\nFound by: call frame info\n2 Electron Framework!content::RenderFrameHostImpl::ForEachRenderFrameHost(base::FunctionRef&lt;void (content::RenderFrameHost*)&gt;) [render_frame_host_impl.cc : 2638 + 0x8]\nx19 = 0x00000104067ccfa0  x20 = 0x000000016d59b7e8\nx21 = 0x000000016d59b8a8  x22 = 0x0000000000000001\nx23 = 0x0000000000000015  x24 = 0x00000001153b8000\nx25 = 0x00000104000f0280  x26 = 0x0000010400510100\nx27 = 0x00000d63002cdf65  x28 = 0x00000d6300000000\nfp = 0x000000016d59b7a0 sp = 0x000000016d59b780\npc = 0x000000010eaf75c0\nFound by: call frame info\n3 Electron Framework!electron::api::WebFrameMain::Frames() const [electron_api_web_frame_main.cc : 412 + 0x4]\nx19 = 0x00000104067ccfa0  x20 = 0x000000016d59b7e8\nx21 = 0x000000016d59b8a8  x22 = 0x0000000000000001\nx23 = 0x0000000000000015  x24 = 0x00000001153b8000\nx25 = 0x00000104000f0280  x26 = 0x0000010400510100\nx27 = 0x00000d63002cdf65  x28 = 0x00000d6300000000\nfp = 0x000000016d59b7d0 sp = 0x000000016d59b7b0\npc = 0x000000010c47bf8c\nFound by: call frame info```\n\n### Testcase Gist URL\n\n_No response_\n\n### Additional Information\n\nThis may be related to [#43473](https://github.com/electron/electron/pull/43473) @samuelmaddock \n", "patch": "diff --git a/shell/browser/api/electron_api_web_frame_main.cc b/shell/browser/api/electron_api_web_frame_main.cc\nindex 3e800659a48c3..cc3d142eef049 100644\n--- a/shell/browser/api/electron_api_web_frame_main.cc\n+++ b/shell/browser/api/electron_api_web_frame_main.cc\n@@ -183,7 +183,7 @@ void WebFrameMain::UpdateRenderFrameHost(content::RenderFrameHost* rfh) {\n }\n \n bool WebFrameMain::CheckRenderFrame() const {\n-  if (render_frame_disposed_) {\n+  if (!HasRenderFrame()) {\n     v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n     v8::HandleScope scope(isolate);\n     gin_helper::ErrorThrower(isolate).ThrowError(\n@@ -435,7 +435,7 @@ v8::Local<v8::Promise> WebFrameMain::CollectDocumentJSCallStack(\n   gin_helper::Promise<base::Value> promise(args->isolate());\n   v8::Local<v8::Promise> handle = promise.GetHandle();\n \n-  if (render_frame_disposed_) {\n+  if (!HasRenderFrame()) {\n     promise.RejectWithErrorMessage(\n         \"Render frame was disposed before WebFrameMain could be accessed\");\n     return handle;\n@@ -463,7 +463,7 @@ void WebFrameMain::CollectedJavaScriptCallStack(\n     gin_helper::Promise<base::Value> promise,\n     const std::string& untrusted_javascript_call_stack,\n     const std::optional<blink::LocalFrameToken>& remote_frame_token) {\n-  if (render_frame_disposed_) {\n+  if (!HasRenderFrame()) {\n     promise.RejectWithErrorMessage(\n         \"Render frame was disposed before call stack was received\");\n     return;\ndiff --git a/shell/browser/api/electron_api_web_frame_main.h b/shell/browser/api/electron_api_web_frame_main.h\nindex 9191e6f346217..de984aee5db69 100644\n--- a/shell/browser/api/electron_api_web_frame_main.h\n+++ b/shell/browser/api/electron_api_web_frame_main.h\n@@ -101,8 +101,14 @@ class WebFrameMain final : public gin::Wrappable<WebFrameMain>,\n   void TeardownMojoConnection();\n   void OnRendererConnectionError();\n \n-  // WebFrameMain can outlive its RenderFrameHost pointer so we need to check\n-  // whether its been disposed of prior to accessing it.\n+  [[nodiscard]] constexpr bool HasRenderFrame() const {\n+    return !render_frame_disposed_ && render_frame_ != nullptr;\n+  }\n+\n+  // Throws a JS error if HasRenderFrame() is false.\n+  // WebFrameMain can outlive its RenderFrameHost pointer,\n+  // so we need to check whether its been disposed of\n+  // prior to accessing it.\n   bool CheckRenderFrame() const;\n \n   v8::Local<v8::Promise> ExecuteJavaScript(gin::Arguments* args,\n", "instance_id": "electron__electron-45487", "clarity": 2, "difficulty": 0.65, "clarity_explanation": "The problem statement is mostly clear in describing the issue: accessing the `frames` and `name` attributes of a destroyed `WebFrameMain` object in Electron results in a segmentation fault (SIGSEGV) instead of throwing an error as expected. The statement includes relevant details such as the Electron version, operating system, architecture, and a stack trace, which help in understanding the context of the issue. However, there are minor ambiguities and missing details. For instance, the problem statement does not explicitly define what constitutes a \"destroyed frame\" or under what specific conditions the frame is considered destroyed. Additionally, there are no detailed reproduction steps or a test case (the Testcase Gist URL is marked as \"No response\"), which could make it harder to replicate the issue consistently. Edge cases or specific scenarios leading to the crash are also not mentioned. Despite these gaps, the overall intent and nature of the bug are understandable, warranting a score of 2 (Mostly Clear).", "difficulty_explanation": "The difficulty of solving this problem is rated at 0.65, placing it in the \"Hard\" category (0.6-0.8). This assessment is based on several factors. First, the scope of code changes appears relatively focused, primarily involving modifications to the `WebFrameMain` class in the Electron codebase, specifically around how the render frame's state is checked before access. The provided diff shows changes in a single file (`electron_api_web_frame_main.cc`) and its header (`electron_api_web_frame_main.h`), replacing a simple boolean flag check (`render_frame_disposed_`) with a more robust condition (`HasRenderFrame()`). However, the impact of these changes is significant as they address a critical issue (SIGSEGV) that can crash the application, requiring a deep understanding of Electron's rendering architecture and frame lifecycle management. \n\nSecond, the technical concepts involved are moderately complex. Solving this requires familiarity with C++ (used in Electron's native layer), understanding of Electron's API design (specifically `WebFrameMain`), and knowledge of Chromium's rendering pipeline (`RenderFrameHost`). Additionally, the developer must understand how JavaScript bindings interact with native code through V8, as the error handling involves throwing JavaScript errors from C++.\n\nThird, the problem touches on edge cases related to frame destruction and detachment, which are not fully detailed in the problem statement but are evident from the stack trace and code changes. Ensuring that the frame state is correctly checked before access is crucial to prevent crashes, and the solution must handle scenarios where the frame might be disposed of or detached unexpectedly. The code changes introduce a more explicit check (`HasRenderFrame()`), indicating a need to account for such edge cases, though the complexity of these edge cases seems moderate based on the diff.\n\nFinally, while the changes are localized, the potential impact on the broader Electron codebase is non-trivial due to the critical nature of frame management. A mistake here could introduce new crashes or regressions in other parts of the application. The problem also references a related pull request (#43473), suggesting that it may be part of a larger context or ongoing issue, which adds to the cognitive load of understanding the full scope. Overall, this problem requires a solid grasp of the Electron internals and careful handling of frame state, justifying a difficulty score of 0.65.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "Ctrl+C and Ctrl+V shortcuts are broken, they apply to the wrong tab\n### Tested versions\r\n\r\nv4.2.1.stable.mono.official [b09f793f5]\r\n\r\n\r\n\r\n### System information\r\n\r\nGodot v4.2.1.stable.mono - Windows 10.0.19045 - Vulkan (Forward+) - dedicated NVIDIA GeForce GTX 1060 6GB (NVIDIA; 31.0.15.3623) - AMD Ryzen 5 2600X Six-Core Processor (12 Threads)\r\n\r\n### Issue description\r\n\r\nWhen I try to use Ctrl+C and Ctrl+V to copy and paste an object in my scene, it instead for some reason pastes an option in the `Import` tab.\r\n\r\n- I do not have the `Import` tab open, I have the `Scene` tab open.\r\n- I do not even have something selected in the `FileSystem` tab which would show up in the `Import` tab when I switch to it.\r\n- But nonetheless I get `Set meshes/force_disable_compression` in the output when trying to Ctrl+C and Ctrl+V, which was the most recent setting I changed in the `Import` tab before moving on to other tasks.\r\n\r\nUsing the right click menu and selecting `Copy` and then selecting `Paste` works as intended. For some reason it is just the keyboard shortcut which is broken.\r\n\r\n### Steps to reproduce\r\n\r\n1. change a setting in the `Import` tab\r\n2. try to copy something in the `Scene` tab\r\n3. it will do nothing and the output will show that it just affected whatever setting you changed in the `Import` tab.\r\n\r\n### Minimal reproduction project (MRP)\r\n\r\nOpen a brand new project and follow the steps. Change an import setting of icon.svg and now you cannot Ctrl+C Ctrl+V in the `Scene` tab\n", "patch": "diff --git a/editor/editor_inspector.cpp b/editor/editor_inspector.cpp\nindex d9bead1e7832..5611d00814f3 100644\n--- a/editor/editor_inspector.cpp\n+++ b/editor/editor_inspector.cpp\n@@ -579,6 +579,12 @@ void EditorProperty::_notification(int p_what) {\n \t\t\t}\n \t\t} break;\n \t\tcase NOTIFICATION_ENTER_TREE: {\n+\t\t\tEditorInspector *inspector = get_parent_inspector();\n+\t\t\tif (inspector) {\n+\t\t\t\tinspector = inspector->get_root_inspector();\n+\t\t\t}\n+\t\t\tset_shortcut_context(inspector);\n+\n \t\t\tif (has_borders) {\n \t\t\t\tget_parent()->connect(SceneStringName(theme_changed), callable_mp(this, &EditorProperty::_update_property_bg));\n \t\t\t\t_update_property_bg();\n", "instance_id": "godotengine__godot-104485", "clarity": 2, "difficulty": 0.45, "clarity_explanation": "The problem statement is mostly clear in describing the issue: the Ctrl+C and Ctrl+V shortcuts are malfunctioning in the Godot editor, affecting the wrong tab (pasting settings in the 'Import' tab instead of copying/pasting objects in the 'Scene' tab). The description includes the context (tested version, system information), steps to reproduce, and a minimal reproduction project, which helps in understanding the issue. However, there are minor ambiguities and missing details. For instance, it does not explicitly mention whether this issue affects all objects or specific types in the 'Scene' tab, nor does it clarify if the issue persists across sessions or is tied to specific user actions beyond the described steps. Additionally, the expected behavior is implied but not explicitly detailed (e.g., what exactly should happen when Ctrl+C and Ctrl+V are pressed in the 'Scene' tab). These minor gaps prevent it from being fully comprehensive, hence a score of 2 (Mostly Clear).", "difficulty_explanation": "The difficulty of this problem falls into the medium range due to several factors. First, the scope of the code change appears localized to a single file (`editor_inspector.cpp`) and involves a small modification (adding a few lines to set the shortcut context). This suggests a relatively contained impact, not requiring extensive changes across multiple modules or significant architectural modifications. However, understanding the fix requires knowledge of the Godot editor's internal architecture, specifically how shortcut contexts are managed and how the inspector hierarchy interacts with input handling. The change involves setting the shortcut context to the root inspector, which implies a need to understand the relationship between `EditorProperty`, `EditorInspector`, and input event propagation in the Godot engine\u2014a moderately complex concept for someone unfamiliar with the codebase. Additionally, while the problem statement does not explicitly mention edge cases, the nature of input handling suggests potential issues like ensuring the shortcut context does not conflict with other UI elements or tabs, which might require careful testing but not extensive error handling in the provided code change. Overall, this problem requires understanding a specific part of the codebase and making a targeted fix, placing it at 0.45 (Medium difficulty), as it goes beyond a simple bug fix but does not demand deep architectural refactoring or advanced domain-specific knowledge.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "Game crashes when adding color preset after clearing presets in another control\n### Tested versions\n\n- Reproducible in: 4.4 (and previous 4.4.dev builds since saving color palettes was introduced #91604)\n\n### System information\n\nGodot v4.4.stable - Windows 11 (build 26100) - Multi-window, 1 monitor - Vulkan (Forward+) - integrated AMD Radeon 780M Graphics (Advanced Micro Devices, Inc.; 32.0.11039.8001) - AMD Ryzen 7 8845HS w/ Radeon 780M Graphics (16 threads)\n\n### Issue description\n\nIf you have multiple `ColorPickers` in the scene and one `ColorPicker` uses saved color palette and it was cleared, trying to add color preset in another `ColorPicker`, if that color was added to the presets before, it would crash the game.\n\nhttps://github.com/user-attachments/assets/1e5da6c7-255e-4d99-9793-721f06493741\n\n### Steps to reproduce\n\n1. Add 2 or more `ColorPicker`s to the scene\n2. Assign different colors to each `ColorPicker`\n3. Run the game\n4. Open Swatches in each `ColorPicker` and add current color to presets\n5. Save presets of one `ColorPicker` as color palette (you will see another issue mentioned in #104223)\n6. Clear presets in the `ColorPicker` that you saved the palette in\n7. In another `ColorPicker`  press the button to add current color to presets without chaning the color before (it should be the same color, as was added to presets for this `ColorPicker` before\n8. The game should crash\n\n### Minimal reproduction project (MRP)\n\n[regression-test-project.zip](https://github.com/user-attachments/files/19270277/regression-test-project.zip)\n", "patch": "diff --git a/scene/gui/color_picker.cpp b/scene/gui/color_picker.cpp\nindex 426e0092d71b..655988b3d16e 100644\n--- a/scene/gui/color_picker.cpp\n+++ b/scene/gui/color_picker.cpp\n@@ -1138,16 +1138,21 @@ void ColorPicker::add_preset(const Color &p_color) {\n \tList<Color>::Element *e = presets.find(p_color);\n \tif (e) {\n \t\tpresets.move_to_back(e);\n-\t\tpreset_cache.move_to_back(preset_cache.find(p_color));\n \n \t\tpreset_container->move_child(preset_group->get_pressed_button(), preset_container->get_child_count() - 1);\n \t} else {\n \t\tpresets.push_back(p_color);\n-\t\tpreset_cache.push_back(p_color);\n \n \t\t_add_preset_button(_get_preset_size(), p_color);\n \t}\n \n+\tList<Color>::Element *cache_e = preset_cache.find(p_color);\n+\tif (cache_e) {\n+\t\tpreset_cache.move_to_back(cache_e);\n+\t} else {\n+\t\tpreset_cache.push_back(p_color);\n+\t}\n+\n \tif (!palette_name->get_text().is_empty()) {\n \t\tpalette_name->set_text(vformat(\"%s*\", palette_name->get_text().trim_suffix(\"*\")));\n \t\tpalette_name->set_tooltip_text(ETR(\"The changes to this palette have not been saved to a file.\"));\n", "instance_id": "godotengine__godot-104227", "clarity": 2, "difficulty": 0.35, "clarity_explanation": "The problem statement is mostly clear in describing the issue: a game crash occurs when adding a color preset in one ColorPicker after clearing presets in another ColorPicker. It provides detailed steps to reproduce the issue, system information, and a minimal reproduction project, which are helpful for understanding the context. However, there are minor ambiguities and missing details. For instance, the problem statement does not explicitly mention the root cause of the crash (e.g., whether it's a null pointer dereference, memory corruption, or something else), which would help in assessing the scope of the fix. Additionally, it references another issue (#104223) without explaining its relevance, which could confuse someone unfamiliar with that issue. Edge cases beyond the specific reproduction steps are not discussed, leaving some uncertainty about the full scope of the problem. Overall, while the statement is actionable, it lacks some critical technical details that would make it comprehensive.", "difficulty_explanation": "The difficulty of this problem falls into the \"Easy\" range (0.2-0.4) due to several factors. First, the scope of the code change is relatively small and localized to a single file (`color_picker.cpp`) and a specific function (`add_preset`). The diff shows a modest modification involving the management of two lists (`presets` and `preset_cache`) to ensure consistency when moving or adding colors, which suggests a straightforward bug fix rather than a complex feature addition or architectural change. Second, the technical concepts involved are relatively basic: understanding of list manipulation in C++ and familiarity with the Godot engine's GUI component logic. No advanced algorithms, design patterns, or domain-specific knowledge beyond typical GUI programming are required. Third, the problem does not appear to involve complex edge cases beyond the specific crash scenario described, and the fix does not introduce significant error handling logic. However, it does require a moderate understanding of the interaction between `presets` and `preset_cache` lists and how they relate to the UI components, which slightly elevates the difficulty above \"Very Easy.\" There is no indication of broader architectural impact or performance considerations. Overall, this is a manageable bug fix for a developer with basic to intermediate experience in C++ and GUI programming, hence the score of 0.35.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "FileSystem panel loses focus after Renaming or Duplicating files\n**Godot version:**\r\n3.2.alpha 35944aebdeb4c3b5869aaeedaaded02397b7ce92\r\n**OS/device including version:**\r\n5.3.7.arch1-1\r\n**Issue description:**\r\nDeleting, renaming or duplicating a file in the FileSystem panel opens a prompt window. If you close this window while deleting a file (either by confirming the deletion or cancelling it) the FileSystem panel regains focus. This doesn't happen when duplicating or renaming a file. **edit:** [and it would be nice if it did.](https://github.com/godotengine/godot/issues/33126#issuecomment-547577403)\r\n**Steps to reproduce:**\r\n1. Select a file in the FileSystem panel\r\n2. Duplicate the file either by right-click -> Duplicate or the shortcut Ctrl+D\r\n3. Type a new name and press Return(Enter) to confirm\r\n\n", "patch": "diff --git a/editor/filesystem_dock.cpp b/editor/filesystem_dock.cpp\nindex 4fafdefbb598..267514ffde6a 100644\n--- a/editor/filesystem_dock.cpp\n+++ b/editor/filesystem_dock.cpp\n@@ -1338,6 +1338,10 @@ void FileSystemDock::_fs_changed() {\n \t}\n \n \tset_process(false);\n+\tif (had_focus) {\n+\t\thad_focus->grab_focus();\n+\t\thad_focus = nullptr;\n+\t}\n }\n \n void FileSystemDock::_set_scanning_mode() {\n@@ -2675,6 +2679,12 @@ bool FileSystemDock::_matches_all_search_tokens(const String &p_text) {\n }\n \n void FileSystemDock::_rescan() {\n+\tif (tree->has_focus()) {\n+\t\thad_focus = tree;\n+\t} else if (files->has_focus()) {\n+\t\thad_focus = files;\n+\t}\n+\n \t_set_scanning_mode();\n \tEditorFileSystem::get_singleton()->scan();\n }\ndiff --git a/editor/filesystem_dock.h b/editor/filesystem_dock.h\nindex 0ed0de3d59e9..dac535efb8e9 100644\n--- a/editor/filesystem_dock.h\n+++ b/editor/filesystem_dock.h\n@@ -235,6 +235,7 @@ class FileSystemDock : public VBoxContainer {\n \tbool import_dock_needs_update = false;\n \tTreeItem *resources_item = nullptr;\n \tTreeItem *favorites_item = nullptr;\n+\tControl *had_focus = nullptr;\n \n \tbool holding_branch = false;\n \tVector<TreeItem *> tree_items_selected_on_drag_begin;\n", "instance_id": "godotengine__godot-103734", "clarity": 2, "difficulty": 0.3, "clarity_explanation": "The problem statement is mostly clear in describing the issue: the FileSystem panel in Godot loses focus after renaming or duplicating files, unlike after deleting files where focus is regained. The goal is implied\u2014to ensure the FileSystem panel regains focus after renaming or duplicating actions. Steps to reproduce are provided, which helps in understanding the issue. However, there are minor ambiguities and missing details. For instance, the problem does not explicitly state whether the focus should return to a specific element (e.g., the tree or file list) or just the panel in general. Additionally, there are no mentions of edge cases, such as what should happen if the panel is not visible or if multiple operations are performed in quick succession. Constraints or expected behavior in different UI states are also not specified. Despite these minor gaps, the issue is valid and understandable with the provided context and steps.", "difficulty_explanation": "The difficulty of this problem falls in the \"Easy\" range (0.2-0.4) due to the following reasons based on the evaluation factors:\n\n1. **Scope and Depth of Code Changes:** The code changes are relatively small and localized to a single class (`FileSystemDock`) across two files (`filesystem_dock.cpp` and `filesystem_dock.h`). The modifications involve adding a member variable to track the focused control and logic to restore focus after certain operations. The changes do not impact the broader system architecture or require understanding complex interactions between multiple modules. The amount of code change is minimal, with only a few lines added to store and restore focus.\n\n2. **Number of Technical Concepts:** The solution requires basic understanding of UI handling in Godot, specifically focus management using methods like `grab_focus()`. It involves straightforward C++ concepts such as pointers and conditional checks. No advanced algorithms, design patterns, or domain-specific knowledge beyond basic UI programming are needed. Familiarity with Godot's editor codebase is helpful but not critical for this isolated fix.\n\n3. **Potential Edge Cases and Error Handling:** The problem statement does not mention specific edge cases, and the code changes do not introduce complex error handling. However, a developer might need to consider minor edge cases, such as ensuring `had_focus` is properly reset or handling scenarios where the control no longer exists when focus is to be restored. These are not particularly complex to address.\n\n4. **Overall Complexity:** The task is a simple bug fix that involves understanding a small part of the UI logic and making targeted modifications. It does not require deep knowledge of the entire codebase or intricate logic. The primary challenge lies in identifying the correct place to store and restore focus, which is straightforward given the provided diff.\n\nGiven these factors, a difficulty score of 0.30 reflects an easy problem that requires minimal code changes and basic understanding of UI focus management in a C++-based framework like Godot. It is slightly above the \"Very Easy\" range due to the need to understand the specific context of focus handling in the editor UI.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "Invalid startup embedded game location and size after resizing editor main area\n### Tested versions\n\n- Reproductive in Godot 4.4 RC3, RC2\n\n### System information\n\nGodot v4.4.rc3 - Windows 11 (build 26100) - Multi-window, 2 monitors - Vulkan (Forward+) - dedicated NVIDIA GeForce RTX 3070 Laptop GPU (NVIDIA; 32.0.15.7260) - AMD Ryzen 7 5800H with Radeon Graphics (16 threads)\n\n### Issue description\n\nWhen the game is embedded in the editor, if when editor main area is resized, the next time the embedded game is started it will startup with the previous location and sizse.\n\n### Steps to reproduce\n\n- Activate embedded without floating window\n- Start the game the first time, location and size will be OK\n- Stop the game\n- Resize a floating dock or the bottom panel when your are not in the Game tab\n- Start the game again\n- For a split second, the game will be displayed at the previous location and size before the resizing in the editor (the location and size of the previous startup)\n\nhttps://github.com/user-attachments/assets/94d29bef-e8b1-4b56-b1f6-6cef7560c6d9\n\n### Minimal reproduction project (MRP)\n\nAny project\n", "patch": "diff --git a/editor/plugins/game_view_plugin.cpp b/editor/plugins/game_view_plugin.cpp\nindex 30c558e0bd5d..bc3b4ceeb2b7 100644\n--- a/editor/plugins/game_view_plugin.cpp\n+++ b/editor/plugins/game_view_plugin.cpp\n@@ -257,7 +257,7 @@ void GameView::_show_update_window_wrapper() {\n \tPoint2 offset_embedded_process = embedded_process->get_global_position() - get_global_position();\n \n \t// On the first startup, the global position of the embedded process control is invalid because it was\n-\t// never displayed. We will calculated it manually using the minimum size of the window.\n+\t// never displayed. We will calculate it manually using the minimum size of the window.\n \tif (offset_embedded_process == Point2()) {\n \t\toffset_embedded_process.y = wrapped_min_size.y;\n \t}\n@@ -812,9 +812,8 @@ void GameView::_update_arguments_for_instance(int p_idx, List<String> &r_argumen\n \t_update_embed_window_size();\n \tRect2i rect = embedded_process->get_screen_embedded_window_rect();\n \n-\t// On the first startup, the global rect of the embedded process control is invalid because it was\n-\t// never displayed. We will calculated it manually.\n-\tif (!window_wrapper->get_window_enabled() && rect.size.y < embedded_process->get_custom_minimum_size().y) {\n+\t// Usually, the global rect of the embedded process control is invalid because it was hidden. We will calculate it manually.\n+\tif (!window_wrapper->get_window_enabled()) {\n \t\tSize2 old_min_size = embedded_process->get_custom_minimum_size();\n \t\tembedded_process->set_custom_minimum_size(Size2i());\n \n", "instance_id": "godotengine__godot-103436", "clarity": 2, "difficulty": 0.35, "clarity_explanation": "The problem statement is mostly clear in describing the issue: when the editor main area is resized in Godot 4.4 RC versions, the embedded game does not update its location and size correctly upon restarting, briefly showing the previous position before adjusting. The steps to reproduce are detailed, and a visual reference (via a GitHub attachment) is provided, which aids in understanding the issue. However, there are minor ambiguities and missing details. For instance, the problem statement does not explicitly define the expected behavior (e.g., should the game always start with the updated size/location immediately without flickering?). Additionally, there are no mentions of specific edge cases or constraints, such as behavior on different monitor setups beyond the reported dual-monitor configuration, or how different resizing actions might impact the issue. While the issue is reproducible in \"any project,\" the lack of a minimal reproduction project (MRP) with specific configurations could make it slightly harder to debug for someone unfamiliar with Godot's editor. Overall, the description is valid and mostly clear but lacks some precision and completeness in requirements and edge case coverage, warranting a score of 2 (Mostly Clear).", "difficulty_explanation": "The difficulty of solving this problem falls into the \"Easy\" range (0.2-0.4) due to several factors. First, the scope of code changes is relatively small and localized to a single file (`game_view_plugin.cpp`) within the Godot editor plugin. The diff shows minor modifications to two specific sections of the code, focusing on updating the logic for calculating the position and size of the embedded game window. The changes involve straightforward adjustments to conditional checks and comments, indicating a low volume of code modification without impacting the broader system architecture or requiring cross-module interactions.\n\nSecond, the technical concepts required to address this issue are not overly complex. The problem revolves around understanding Godot's editor UI rendering logic, specifically how embedded windows and their sizes/positions are managed during resizing events. Familiarity with Godot's internal APIs (e.g., `get_global_position()`, `get_screen_embedded_window_rect()`) and basic GUI programming concepts (e.g., window positioning and sizing) is necessary, but these are not advanced topics for someone with moderate experience in game engine development or C++ GUI programming.\n\nThird, the potential edge cases and error handling requirements appear minimal based on the problem statement and code changes. The issue description does not highlight specific edge cases beyond the general resizing behavior, and the code modifications do not introduce new error handling logic. However, there might be implicit edge cases to consider, such as rapid resizing events or extreme window sizes, which are not addressed in the diff or problem statement. These could slightly increase the complexity, but not significantly.\n\nOverall, this problem requires understanding some code logic and making simple modifications to fix a UI rendering glitch, without deep architectural changes or advanced technical knowledge. A difficulty score of 0.35 reflects this as an \"Easy\" task, leaning slightly toward the higher end of the range due to the need for familiarity with Godot's editor internals, which might pose a small learning curve for someone new to the codebase.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "Window content_scale_factor causes jitter in Control size\n### Tested versions\n\nReproducible in 4.4-beta3, 4.3-stable\n\n### System information\n\nGodot v4.4.beta3 - Ubuntu 24.04.1 LTS 24.04 on Wayland - X11 display driver, Multi-window, 1 monitor - Vulkan (Forward+) - integrated Intel(R) UHD Graphics (CML GT2) - Intel(R) Core(TM) i7-10510U CPU @ 1.80GHz (8 threads)\n\n### Issue description\n\nUsing the recommended way to scale UI to screen resolution by setting `get_tree().root.content_scale_factor` (either in the project settings or from script) causes Control node pixels to jitter on resizing the window. This is true even when the \"Snap Controls to Pixels\" option is enabled.\n\nInterestingly, using the node's own scale factor (or scaling a parent node to rescale the entire UI) doesn't exhibit this behaviour, but causes a host of other issues with GUIs so it's not a possible workaround.\n\nScreenshot of misaligned grid pixels from the MRP:\n\n![Image](https://github.com/user-attachments/assets/c906e43d-2bce-4ecd-b48a-aae6f9bb0015)\n\nScreenshot of the grid looking perfect at a different resolution:\n\n![Image](https://github.com/user-attachments/assets/fb2dea18-5215-41d1-b84b-93b6cceea017)\n\nI also managed to reproduce this in my game with all kinds of control nodes, including fonts. In that case the jitter is a lot more visible even when resizing at high resolutions.\n\n**Update:**\n\nSetting `content_scale_factor = 8.0` shows that this is not even a jitter, the control node's scale is just completely off when resizing to certain resolutions. There's no need for Nearest filtering either, the effect is clearly visible even on Linear filtered textures.\n\nhttps://github.com/user-attachments/assets/3cf1038a-1958-488d-acf5-fd5148140f8e\n\n### Steps to reproduce\n\n1. Place a control node (Confirmed with: TextureRect, Label).\n3. Optionally, set the window resolution to a small value, such as 480x360. For me small window sizes (regardless of the base resolution) greatly exacerbate the effect, but it also happens from time to time on larger window sizes.\n4. Set `display/window/stretch/scale` to a larger value, in my case 4.0 is enough, 8.0 makes it super visible.\n5. Resize the game window by dragging the corner, and watch the control node size jitter.\n\n### Minimal reproduction project (MRP)\n\n[gui-scale.zip](https://github.com/user-attachments/files/18734113/gui-scale.zip)\n", "patch": "diff --git a/scene/main/viewport.cpp b/scene/main/viewport.cpp\nindex d0054baeff25..e3979837ab69 100644\n--- a/scene/main/viewport.cpp\n+++ b/scene/main/viewport.cpp\n@@ -1002,10 +1002,10 @@ void Viewport::update_canvas_items() {\n \t_update_canvas_items(this);\n }\n \n-bool Viewport::_set_size(const Size2i &p_size, const Size2i &p_size_2d_override, bool p_allocated) {\n+bool Viewport::_set_size(const Size2i &p_size, const Size2 &p_size_2d_override, bool p_allocated) {\n \tTransform2D stretch_transform_new = Transform2D();\n \tif (is_size_2d_override_stretch_enabled() && p_size_2d_override.width > 0 && p_size_2d_override.height > 0) {\n-\t\tSize2 scale = Size2(p_size) / Size2(p_size_2d_override);\n+\t\tSize2 scale = Size2(p_size) / p_size_2d_override;\n \t\tstretch_transform_new.scale(scale);\n \t}\n \n@@ -1074,7 +1074,7 @@ Size2i Viewport::_get_size() const {\n \treturn size;\n }\n \n-Size2i Viewport::_get_size_2d_override() const {\n+Size2 Viewport::_get_size_2d_override() const {\n \treturn size_2d_override;\n }\n \n@@ -1092,7 +1092,7 @@ Rect2 Viewport::get_visible_rect() const {\n \t\tr = Rect2(Point2(), size);\n \t}\n \n-\tif (size_2d_override != Size2i()) {\n+\tif (size_2d_override != Size2()) {\n \t\tr.size = size_2d_override;\n \t}\n \n@@ -5223,7 +5223,10 @@ void SubViewport::set_size_2d_override(const Size2i &p_size) {\n \n Size2i SubViewport::get_size_2d_override() const {\n \tERR_READ_THREAD_GUARD_V(Size2i());\n-\treturn _get_size_2d_override();\n+\t// Rounding will cause offset issues with the\n+\t// exact positioning of subwindows, but changing the\n+\t// type of size_2d_override would break compatibility.\n+\treturn Size2i((_get_size_2d_override() + Size2(0.5, 0.5)).floor());\n }\n \n void SubViewport::set_size_2d_override_stretch(bool p_enable) {\ndiff --git a/scene/main/viewport.h b/scene/main/viewport.h\nindex 5260b513a951..5bcb50c55546 100644\n--- a/scene/main/viewport.h\n+++ b/scene/main/viewport.h\n@@ -252,7 +252,7 @@ class Viewport : public Node {\n \tTransform2D stretch_transform;\n \n \tSize2i size = Size2i(512, 512);\n-\tSize2i size_2d_override;\n+\tSize2 size_2d_override;\n \tbool size_allocated = false;\n \n \tRID contact_2d_debug;\n@@ -492,10 +492,10 @@ class Viewport : public Node {\n \tvoid _window_start_resize(SubWindowResize p_edge, Window *p_window);\n \n protected:\n-\tbool _set_size(const Size2i &p_size, const Size2i &p_size_2d_override, bool p_allocated);\n+\tbool _set_size(const Size2i &p_size, const Size2 &p_size_2d_override, bool p_allocated);\n \n \tSize2i _get_size() const;\n-\tSize2i _get_size_2d_override() const;\n+\tSize2 _get_size_2d_override() const;\n \tbool _is_size_allocated() const;\n \n \tvoid _notification(int p_what);\ndiff --git a/scene/main/window.cpp b/scene/main/window.cpp\nindex 1bb01313e721..d6328972b894 100644\n--- a/scene/main/window.cpp\n+++ b/scene/main/window.cpp\n@@ -1133,7 +1133,7 @@ void Window::_update_viewport_size() {\n \t//update the viewport part\n \n \tSize2i final_size;\n-\tSize2i final_size_override;\n+\tSize2 final_size_override;\n \tRect2i attach_to_screen_rect(Point2i(), size);\n \tdouble font_oversampling = 1.0;\n \twindow_transform = Transform2D();\n", "instance_id": "godotengine__godot-102741", "clarity": 2, "difficulty": 0.65, "clarity_explanation": "\nThe problem statement is mostly clear and provides a detailed description of the issue, including the context (UI scaling in Godot engine), the specific behavior observed (jitter in Control node sizes during window resizing), and steps to reproduce the issue. It also includes visual evidence (screenshots and a video) and a minimal reproduction project (MRP), which significantly aids in understanding the problem. However, there are minor ambiguities that prevent it from being comprehensive. For instance, the problem statement does not explicitly define the expected behavior or the desired outcome of the fix (e.g., Ascending does not clarify whether the goal is to eliminate jitter entirely or to minimize it to an acceptable level. Additionally, while edge cases like different resolutions and window sizes are mentioned, there is no detailed discussion on specific constraints or performance requirements for the fix. These missing details slightly reduce the clarity, as they leave some room for interpretation regarding the scope and success criteria of the solution.\n", "difficulty_explanation": "\nI rate the difficulty of this problem as 0.65, placing it in the \"Hard\" category. This assessment is based on several factors:\n\n1. **Scope and Depth of Code Changes:** The code changes provided affect multiple files (`viewport.cpp`, `viewport.h`, and `window.cpp`) within the Godot engine, a complex and large codebase. The modifications involve changing data types (from `Size2i` to `Size2`) and adjusting calculations related to viewport scaling and size overrides. These changes impact core rendering logic, which is critical to the engine's functionality, and require a deep understanding of how viewports and UI scaling interact across different components. While the actual lines of code changed are relatively few, the impact on the system's architecture (rendering and UI layout) is significant, as errors here could introduce new bugs or performance issues.\n\n2. **Number of Technical Concepts:** Solving this problem requires familiarity with several advanced concepts, including graphics rendering pipelines, viewport transformations, floating-point precision issues, and UI scaling in game engines. Specific knowledge of Godot's internal architecture (e.g., how `content_scale_factor` interacts with window resizing and control nodes) is necessary. Additionally, understanding the implications of type changes (integer to floating-point) on precision and rounding behavior is critical. These concepts are moderately to highly complex, especially for someone not already familiar with game engine internals.\n\n3. **Potential Edge Cases and Error Handling:** The problem statement highlights edge cases such as varying window resolutions, different scale factors (e.g., 4.0 or 8.0), and different display drivers (Wayland, X11). These edge cases are non-trivial, as they involve handling discrepancies in pixel alignment and scaling across diverse hardware and software environments. The code changes also introduce a rounding adjustment in `SubViewport::get_size_2d_override()` to address positioning issues, which suggests attention to subtle precision-related edge cases. However, additional error handling or validation logic does not appear to be a major focus of the changes, which slightly mitigates the difficulty.\n\n4. **Overall Complexity:** The combination of working in a critical area of the codebase (viewport and rendering logic), the need for domain-specific knowledge of game engine internals, and the handling of resolution and scaling edge cases makes this a challenging problem. It is not at the extreme end of difficulty (e.g., implementing a new rendering system from scratch), but it still requires a solid grasp of complex systems and careful testing to ensure the fix does not introduce regressions. Hence, a score of 0.65 reflects the hard but not insurmountable nature of the task, likely requiring a developer with intermediate to advanced experience in graphics programming or game engine development.\n", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": ".NET: Building GodotSharp is broken in current `master` branch\n### Tested versions\n\n- Reproducible in 4.4.dev (4364ed6ccd001cbfe7cb781d074100695c878d90)\n- Not reproducible in 4.4.dev6 and earlier\n\n### System information\n\nFedora 41, .NET 8.0.111\n\n### Issue description\n\nWhen building the GodotSharp assemblies, I get these errors:\n\n```\n$ ./modules/mono/build_scripts/build_assemblies.py --godot-output-dir ./bin\nRunning MSBuild:  /usr/bin/dotnet msbuild /home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp.sln /restore /t:Build /p:Configuration=Debug /p:NoWarn=1591\n\nWelcome to .NET 8.0!\n---------------------\nSDK Version: 8.0.111\n\n----------------\nInstalled an ASP.NET Core HTTPS development certificate.\nTo trust the certificate, view the instructions: https://aka.ms/dotnet-https-linux\n\n----------------\nWrite your first app: https://aka.ms/dotnet-hello-world\nFind out what's new: https://aka.ms/dotnet-whats-new\nExplore documentation: https://aka.ms/dotnet-docs\nReport issues and find source on GitHub: https://github.com/dotnet/core\nUse 'dotnet --help' to see available commands or visit: https://aka.ms/dotnet-cli\n--------------------------------------------------------------------------------------\nMSBuild version 17.8.5+b5265ef37 for .NET\n  Determining projects to restore...\n  Restored /home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp/GodotSharp.csproj (in 419 ms).\n  Restored /home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharpEditor/GodotSharpEditor.csproj (in 419 ms).\n  Restored /home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotPlugins/GodotPlugins.csproj (in 419 ms).\n  Restored /home/akien/Godot/godot/modules/mono/glue/GodotSharp/Godot.SourceGenerators.Internal/Godot.SourceGenerators.Internal.csproj (in 4.05 sec).\n  Godot.SourceGenerators.Internal -> /home/akien/Godot/godot/modules/mono/glue/GodotSharp/Godot.SourceGenerators.Internal/bin/Debug/netstandard2.0/Godot.SourceGenerators.Internal.dll\nCSC : warning CS9057: The analyzer assembly '/home/akien/Godot/godot/modules/mono/glue/GodotSharp/Godot.SourceGenerators.Internal/bin/Debug/netstandard2.0/Godot.SourceGenerators.Internal.dll' references version '4.9.0.0' of the compiler, which is newer than the currently running version '4.8.0.0'. [/home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp/GodotSharp.csproj]\n/home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp/Core/NativeInterop/NativeFuncs.cs(7,13): error CS0234: The type or namespace name 'SourceGenerators' does not exist in the namespace 'Godot' (are you missing an assembly reference?) [/home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp/GodotSharp.csproj]\n/home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp/Core/NativeInterop/NativeFuncs.cs(18,6): error CS0246: The type or namespace name 'GenerateUnmanagedCallbacksAttribute' could not be found (are you missing a using directive or an assembly reference?) [/home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp/GodotSharp.csproj]\n/home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp/Core/NativeInterop/NativeFuncs.cs(18,6): error CS0246: The type or namespace name 'GenerateUnmanagedCallbacks' could not be found (are you missing a using directive or an assembly reference?) [/home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp/GodotSharp.csproj]\n/home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp/Core/NativeInterop/NativeFuncs.cs(185,36): error CS8795: Partial method 'NativeFuncs.godotsharp_variant_new_copy(out godot_variant, scoped in godot_variant)' must have an implementation part because it has accessibility modifiers. [/home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp/GodotSharp.csproj]\n/home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp/Core/NativeInterop/NativeFuncs.cs(319,36): error CS8795: Partial method 'NativeFuncs.godotsharp_string_name_new_copy(out godot_string_name, scoped in godot_string_name)' must have an implementation part because it has accessibility modifiers. [/home/akien/Godot/godot/modules/mono/glue/GodotSharp/GodotSharp/GodotSharp.csproj]\n```\netc.\n\nFull error log:\n[godotsharp-errors.txt](https://github.com/user-attachments/files/18163050/godotsharp-errors.txt)\n\nThis appears to be a recent regression, possibly from #92131?\n\n<details>\n<summary>dotnet --info</summary>\n\n```\n.NET SDK:\n Version:           8.0.111\n Commit:            ad116b5ce0\n Workload version:  8.0.100-manifests.7198dcc9\n\nRuntime Environment:\n OS Name:     fedora\n OS Version:  41\n OS Platform: Linux\n RID:         fedora.41-x64\n Base Path:   /usr/lib64/dotnet/sdk/8.0.111/\n\n.NET workloads installed:\n Workload version: 8.0.100-manifests.7198dcc9\nThere are no installed workloads to display.\n\nHost:\n  Version:      8.0.11\n  Architecture: x64\n  Commit:       9cb3b725e3\n\n.NET SDKs installed:\n  8.0.111 [/usr/lib64/dotnet/sdk]\n\n.NET runtimes installed:\n  Microsoft.AspNetCore.App 8.0.11 [/usr/lib64/dotnet/shared/Microsoft.AspNetCore.App]\n  Microsoft.NETCore.App 8.0.11 [/usr/lib64/dotnet/shared/Microsoft.NETCore.App]\n\nOther architectures found:\n  None\n\nEnvironment variables:\n  DOTNET_ROOT       [/usr/lib64/dotnet]\n\nglobal.json file:\n  Not found\n\nLearn more:\n  https://aka.ms/dotnet/info\n\nDownload .NET:\n  https://aka.ms/dotnet/download\n```\n\n</details>\n\n### Steps to reproduce\n\n```\nscons module_mono_enabled=yes\n./bin/godot.blabla --generate-mono-glue modules/mono/glue\n./modules/mono/build_scripts/build_assemblies.py --godot-output-dir ./bin\n```\n\n### Minimal reproduction project (MRP)\n\nn/a\n", "patch": "diff --git a/.github/workflows/linux_builds.yml b/.github/workflows/linux_builds.yml\nindex 193942a1bb3a..6b786a7b5849 100644\n--- a/.github/workflows/linux_builds.yml\n+++ b/.github/workflows/linux_builds.yml\n@@ -140,6 +140,18 @@ jobs:\n           python-version: 3.8\n           scons-version: 4.0\n \n+      - name: Force remove preinstalled .NET SDKs\n+        if: matrix.build-mono\n+        run: |\n+          sudo rm -rf /usr/share/dotnet/sdk/*\n+\n+      - name: Setup older .NET SDK as baseline\n+        if: matrix.build-mono\n+        uses: actions/setup-dotnet@v4\n+        with:\n+          # Targeting the oldest version we want to support to ensure it still builds.\n+          dotnet-version: '8.0.100'\n+\n       - name: Compilation\n         uses: ./.github/actions/godot-build\n         with:\n@@ -163,6 +175,7 @@ jobs:\n       - name: Build .NET solutions\n         if: matrix.build-mono\n         run: |\n+          dotnet --info\n           ./modules/mono/build_scripts/build_assemblies.py --godot-output-dir=./bin --godot-platform=linuxbsd\n \n       - name: Prepare artifact\ndiff --git a/modules/mono/glue/GodotSharp/Godot.SourceGenerators.Internal/Godot.SourceGenerators.Internal.csproj b/modules/mono/glue/GodotSharp/Godot.SourceGenerators.Internal/Godot.SourceGenerators.Internal.csproj\nindex ee607ff279e2..d291199ad04d 100644\n--- a/modules/mono/glue/GodotSharp/Godot.SourceGenerators.Internal/Godot.SourceGenerators.Internal.csproj\n+++ b/modules/mono/glue/GodotSharp/Godot.SourceGenerators.Internal/Godot.SourceGenerators.Internal.csproj\n@@ -8,7 +8,7 @@\n   </PropertyGroup>\n \n   <ItemGroup>\n-    <PackageReference Include=\"Microsoft.CodeAnalysis.CSharp\" Version=\"4.9.2\" PrivateAssets=\"all\" />\n+    <PackageReference Include=\"Microsoft.CodeAnalysis.CSharp\" Version=\"4.8.0\" PrivateAssets=\"all\" />\n     <PackageReference Include=\"Microsoft.CodeAnalysis.Analyzers\" Version=\"3.3.4\" PrivateAssets=\"all\" />\n   </ItemGroup>\n \n", "instance_id": "godotengine__godot-100506", "clarity": 2, "difficulty": 0.55, "clarity_explanation": "The problem statement is mostly clear and provides a detailed description of the issue encountered when building GodotSharp assemblies in the current master branch of the Godot engine. It includes specific error messages, system information (Fedora 41, .NET 8.0.111), steps to reproduce the issue, and a reference to a potential cause (a recent pull request #92131). The goal is implicitly clear: resolve the build errors for GodotSharp. However, there are minor ambiguities and missing details. For instance, the problem statement does not explicitly define the expected outcome beyond \"fixing the build,\" nor does it specify constraints or requirements for the solution (e.g., compatibility with specific .NET versions). Additionally, edge cases or specific scenarios leading to the errors are not detailed beyond the provided logs. While the reproduction steps are provided, they lack context for someone unfamiliar with the Godot build process. Overall, the statement is valid and mostly clear but misses some minor details that would make it comprehensive.", "difficulty_explanation": "The difficulty of this problem falls into the medium range due to several factors. First, the scope of code changes is relatively focused, primarily involving a downgrade of the Microsoft.CodeAnalysis.CSharp package version from 4.9.2 to 4.8.0 in a single project file and adjustments to the CI workflow to use an older .NET SDK version (8.0.100). These changes are not extensive in terms of lines of code but require understanding the specific cause of the build failure, which is a version mismatch between the analyzer assembly and the running compiler version as indicated in the error logs. Second, the technical concepts involved include familiarity with .NET SDK versioning, MSBuild, and source generators in the context of GodotSharp, which are moderately complex and require domain-specific knowledge of the Godot engine's Mono module and its build system. Third, the problem impacts a specific part of the codebase (GodotSharp assemblies) but does not appear to affect the broader system architecture significantly. Finally, while the problem statement and logs highlight specific errors (e.g., missing namespaces and partial method implementation issues), there is no explicit mention of complex edge cases or extensive error handling requirements beyond resolving the version incompatibility. However, diagnosing and confirming the root cause (version mismatch) and ensuring compatibility across different environments adds a layer of complexity. Overall, this problem requires understanding multiple concepts and making targeted but non-trivial modifications, placing it in the medium difficulty range at 0.55.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "test: 32-bit Clang `ipc_test` failure at `-O0`\nNoticed as part of this branch #29796, however it can also be reproduced with master (8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf) by reproducing the equivalent CI & setting C(XX)FLAGS to -O0:\n```bash\nmake -C depends/ MULTIPROCESS=1 NO_QT=1 NO_WALLET=1 NO_ZMQ=1 NO_USDT=1 CFLAGS=\"-O0\" CXXFLAGS=\"-O0\" DEBUG=1 -j19 HOST=i686-pc-linux-gnu\ncmake -B build --toolchain /root/ci_scratch/depends/i686-pc-linux-gnu/toolchain.cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_COMPILER='clang;-m32' -DCMAKE_CXX_COMPILER='clang++;-m32'\ncmake --build build -j18\n```\n\n```bash\n./build/src/test/test_bitcoin --run_test=ipc*\nRunning 2 test cases...\nterminate called after throwing an instance of 'kj::ExceptionImpl'\n  what():  /root/ci_scratch/depends/i686-pc-linux-gnu/include/kj/common.h:1797: failed: expected start <= end && end <= size_; Out-of-bounds ArrayPtr::slice().\nstack: 5ca0dd6d 5c78b5db 5c8cc599 5ca0adc9 5c94fb37 5c950070 5c9cd709 5c9cf58a 5c9d72fd 5c9d025e 5c776f11 5bf6351d 5bf6347d 5bf633cd 5bf6337b 5bf6331d 5bf63194 f7afa4b0 f773dff6 f77d55b7\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\nunknown location(0): fatal error: in \"ipc_tests/ipc_tests\": signal: SIGABRT (application abort requested)\ntest/ipc_tests.cpp(12): last checkpoint: \"ipc_tests\" test entry\ntest_bitcoin: common/args.cpp:578: void ArgsManager::AddArg(const std::string &, const std::string &, unsigned int, const OptionsCategory &): Assertion `ret.second' failed.\nunknown location(0): fatal error: in \"ipc_tests/parse_address_test\": signal: SIGABRT (application abort requested)\ntest/ipc_tests.cpp(20): last checkpoint: \"parse_address_test\" fixture ctor\n\n*** 2 failures are detected in the test module \"Bitcoin Core Test Suite\"\n```\n", "patch": "diff --git a/depends/packages/capnp.mk b/depends/packages/capnp.mk\nindex 7f41d3b5a4ed3..dff92d9e61fe8 100644\n--- a/depends/packages/capnp.mk\n+++ b/depends/packages/capnp.mk\n@@ -4,6 +4,7 @@ $(package)_download_path=$(native_$(package)_download_path)\n $(package)_download_file=$(native_$(package)_download_file)\n $(package)_file_name=$(native_$(package)_file_name)\n $(package)_sha256_hash=$(native_$(package)_sha256_hash)\n+$(package)_patches=abi_placement_new.patch\n \n define $(package)_set_vars :=\n   $(package)_config_opts := -DBUILD_TESTING=OFF\n@@ -12,6 +13,10 @@ define $(package)_set_vars :=\n   $(package)_cxxflags += -fdebug-prefix-map=$($(package)_extract_dir)=/usr -fmacro-prefix-map=$($(package)_extract_dir)=/usr\n endef\n \n+define $(package)_preprocess_cmds\n+  patch -p2 < $($(package)_patch_dir)/abi_placement_new.patch\n+endef\n+\n define $(package)_config_cmds\n   $($(package)_cmake) .\n endef\ndiff --git a/depends/patches/capnp/abi_placement_new.patch b/depends/patches/capnp/abi_placement_new.patch\nnew file mode 100644\nindex 0000000000000..9aef85db8e86b\n--- /dev/null\n+++ b/depends/patches/capnp/abi_placement_new.patch\n@@ -0,0 +1,71 @@\n+From 74560f26f75dda4257dce541ca362a1e763b2971 Mon Sep 17 00:00:00 2001\n+From: Ryan Ofsky <ryan@ofsky.org>\n+Date: Thu, 6 Feb 2025 08:39:05 -0500\n+Subject: [PATCH 1/1] Avoid gcc/clang ABI incompatibility caused by\n+ PlacementNew\n+\n+GCC and clang do not use same calling convention for passing empty struct\n+parameters. There is more information about this in\n+https://itanium-cxx-abi.github.io/cxx-abi/cxx-abi-dev/archives/2015-December/002869.html\n+\n+Unfortunately this can create an issue in capnproto if it is built without\n+optimizations in GCC, and the resulting static libraries are used in a clang\n+program, or vice versa.\n+\n+Depending on what order libraries are specified on the linker command line, and\n+whether code compiled with the other compiler is calling any header functions\n+that cause weak a `operator new(unsigned int, kj::_::PlacementNew, void*)`\n+symbol to be defined in its own objects, this can cause the linker to link a\n+GCC-generated `kj::ctor` with a clang-generated `operator new`, and the\n+resulting program to crash due to the compilers using different calling\n+conventions for `operator new`.\n+\n+This problem is difficult to avoid in general, but pretty easy to avoid here by\n+changing `operator new` parameter order so the empty struct parameter is last.\n+\n+This change should be beneficial for capnproto users that may be compiling it\n+without optimizations, and not necessarily using a single compiler to build all\n+their dependencies.\n+\n+The problem does not occur if any optimizations are enabled because `operator\n+new` calls are inlined in that case.\n+---\n+ c++/src/kj/common.h | 11 +++++++----\n+ 1 file changed, 7 insertions(+), 4 deletions(-)\n+\n+diff --git a/c++/src/kj/common.h b/c++/src/kj/common.h\n+index b8edde3c..28ab11d6 100644\n+--- a/c++/src/kj/common.h\n++++ b/c++/src/kj/common.h\n+@@ -1034,24 +1034,27 @@ private:\n+ \n+ // We want placement new, but we don't want to #include <new>.  operator new cannot be defined in\n+ // a namespace, and defining it globally conflicts with the definition in <new>.  So we have to\n+-// define a dummy type and an operator new that uses it.\n++// define a dummy type and an operator new that uses it.  The dummy type is intentionally passed\n++// as the last parameter so clang and GCC ABI calling conventions for empty struct struct parameters\n++// are compatible, and there are not segfaults trying to call clang operator new/delete from GCC or\n++// vice versa.\n+ \n+ namespace _ {  // private\n+ struct PlacementNew {};\n+ }  // namespace _ (private)\n+ } // namespace kj\n+ \n+-inline void* operator new(size_t, kj::_::PlacementNew, void* __p) noexcept {\n++inline void* operator new(size_t, void* __p, kj::_::PlacementNew) noexcept {\n+   return __p;\n+ }\n+ \n+-inline void operator delete(void*, kj::_::PlacementNew, void* __p) noexcept {}\n++inline void operator delete(void*, void* __p, kj::_::PlacementNew) noexcept {}\n+ \n+ namespace kj {\n+ \n+ template <typename T, typename... Params>\n+ inline void ctor(T& location, Params&&... params) {\n+-  new (_::PlacementNew(), &location) T(kj::fwd<Params>(params)...);\n++  new (&location, _::PlacementNew()) T(kj::fwd<Params>(params)...);\n+ }\n+ \n+ template <typename T>\n", "instance_id": "bitcoin__bitcoin-31998", "clarity": 2, "difficulty": 0.75, "clarity_explanation": "The problem statement is mostly clear in describing the issue: a failure in the `ipc_test` when compiled with Clang at optimization level `-O0` on a 32-bit system. It provides specific steps to reproduce the issue, including build commands and the resulting error output, which is helpful for understanding the context. However, there are minor ambiguities and missing details. For instance, the problem statement does not explicitly define the expected behavior or the root cause in a concise manner (though the code changes hint at an ABI incompatibility between GCC and Clang). Additionally, it lacks explicit mention of edge cases or constraints beyond the specific build configuration. While the reproduction steps are detailed, the goal of the fix (beyond resolving the crash) and the broader impact are not fully articulated. Hence, it falls into the \"Mostly Clear\" category with minor details missing.", "difficulty_explanation": "The difficulty of this problem is rated as Hard (0.75) due to several factors across the evaluation criteria:\n\n1. **Clarity and Complexity of the Problem Description**: While the reproduction steps are clear, understanding the root cause (ABI incompatibility between GCC and Clang for empty struct parameters) requires deep knowledge of compiler behavior and calling conventions. This adds to the inherent complexity of the problem.\n\n2. **Scope and Depth of Code Changes**: The code changes are relatively localized, primarily involving a patch to the `capnp` library's `common.h` file to reorder parameters in a placement new operator to avoid ABI issues. Additionally, there are modifications to the build configuration in `capnp.mk` to apply the patch. While the changes are not extensive in terms of lines of code, they require understanding the interaction between the `capnp` library and the broader Bitcoin Core test suite, as well as the build system (CMake and makefiles). The impact is significant because it affects a third-party dependency used in a critical test suite, potentially influencing other parts of the system if not handled carefully.\n\n3. **Number of Technical Concepts**: Solving this problem demands advanced knowledge of several complex concepts:\n   - Compiler-specific behavior (GCC vs. Clang ABI differences for empty structs).\n   - C++ language intricacies, such as placement new and operator overloading.\n   - Build system modifications (patching dependencies in a `depends/` system).\n   - Low-level debugging of crashes (interpreting stack traces and error messages like `Out-of-bounds ArrayPtr::slice()`).\n   - Cross-compiler compatibility issues, especially in a 32-bit environment with optimization disabled (`-O0`).\n   These concepts are non-trivial and require significant experience to navigate effectively.\n\n4. **Potential Edge Cases and Error Handling**: The problem statement does not explicitly mention edge cases beyond the specific build configuration (`-O0`, 32-bit, Clang). However, the nature of the fix (ABI compatibility) implies potential risks in other build configurations or compiler combinations. The code change itself does not introduce new error handling but addresses a fundamental compatibility issue that could manifest as crashes in various scenarios. Understanding and verifying the fix's correctness across different environments adds to the difficulty.\n\nOverall, this problem is rated as Hard (0.75) because it requires a deep understanding of compiler internals, C++ nuances, and build systems, even though the code changes are relatively small. It falls short of Very Hard (0.8-1.0) because it does not involve extensive architectural changes or system-level redesigns, but it is still a challenging issue that demands specialized knowledge and careful validation.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "log/dump more information if a CheckQueue failure occurs\nI recently saw this on a node running master (90a5786bba4baac1c0270e1f4bf5bb8c790e10de iirc):\r\n```bash\r\n2024-09-23T13:12:14Z UpdateTip: new best=00000000000000000000d3ebbca24c44745cfa14153e758d29af82275e00c00f height=862523 version=0x20026000 log2_work=95.170324 tx=1084781037 date='2024-09-23T13:03:46Z' progress=0.999997 cache=302.1MiB(2120379txo)\r\n2024-09-23T13:12:14Z UpdateTip: new best=0000000000000000000164dcfef37624f2cc6b177032bbca57631285c2cd0267 height=862524 version=0x20150000 log2_work=95.170337 tx=1084782848 date='2024-09-23T13:05:37Z' progress=0.999998 cache=302.4MiB(2117708txo)\r\n2024-09-23T13:12:15Z New outbound-full-relay v1 peer connected: version: 70016, blocks=862524, peer=25\r\n2024-09-23T13:13:09Z Saw new header hash=00000000000000000000f9892b8210cc52b3f71c1f37ffcfcecc2dab746b6084 height=862525\r\n2024-09-23T13:13:09Z Saw new cmpctblock header hash=00000000000000000000f9892b8210cc52b3f71c1f37ffcfcecc2dab746b6084 peer=1\r\n2024-09-23T13:13:10Z ERROR: ConnectBlock: CheckQueue failed\r\n2024-09-23T13:13:10Z InvalidChainFound: invalid block=00000000000000000000f9892b8210cc52b3f71c1f37ffcfcecc2dab746b6084  height=862525  log2_work=95.170350  date=2024-09-23T13:12:13Z\r\n2024-09-23T13:13:10Z InvalidChainFound:  current best=0000000000000000000164dcfef37624f2cc6b177032bbca57631285c2cd0267  height=862524  log2_work=95.170337  date=2024-09-23T13:05:37Z\r\n2024-09-23T13:13:10Z [error] ConnectTip: ConnectBlock 00000000000000000000f9892b8210cc52b3f71c1f37ffcfcecc2dab746b6084 failed, block-validation-failed\r\n2024-09-23T13:13:10Z InvalidChainFound: invalid block=00000000000000000000f9892b8210cc52b3f71c1f37ffcfcecc2dab746b6084  height=862525  log2_work=95.170350  date=2024-09-23T13:12:13Z\r\n2024-09-23T13:13:10Z InvalidChainFound:  current best=0000000000000000000164dcfef37624f2cc6b177032bbca57631285c2cd0267  height=862524  log2_work=95.170337  date=2024-09-23T13:05:37Z\r\n2024-09-23T13:13:16Z New outbound-full-relay v2 peer connected: version: 70016, blocks=862525, peer=27\r\n2024-09-23T13:13:23Z New outbound-full-relay v1 peer connected: version: 70016, blocks=862525, peer=28\r\n```\r\n\r\nIn this case it was possible to restart the node with `-par=1`, to output the actual failure:\r\n```bash\r\n2024-09-23T14:19:04Z [error] ConnectTip: ConnectBlock 00000000000000000000f9892b8210cc52b3f71c1f37ffcfcecc2dab746b6084 failed, mandatory-script-verify-flag-failed (Script evaluated without error but finished with a false/empty top stack element)\r\n```\r\n\r\nHowever it would also be useful to get that information in either case. The cause of the `ConnectBlock` failure here has currently been put down to hardware.\n", "patch": "diff --git a/src/bench/checkqueue.cpp b/src/bench/checkqueue.cpp\nindex d1454f3634d63..8134154eb112b 100644\n--- a/src/bench/checkqueue.cpp\n+++ b/src/bench/checkqueue.cpp\n@@ -34,9 +34,9 @@ static void CCheckQueueSpeedPrevectorJob(benchmark::Bench& bench)\n         explicit PrevectorJob(FastRandomContext& insecure_rand){\n             p.resize(insecure_rand.randrange(PREVECTOR_SIZE*2));\n         }\n-        bool operator()()\n+        std::optional<int> operator()()\n         {\n-            return true;\n+            return std::nullopt;\n         }\n     };\n \n@@ -62,7 +62,7 @@ static void CCheckQueueSpeedPrevectorJob(benchmark::Bench& bench)\n         }\n         // control waits for completion by RAII, but\n         // it is done explicitly here for clarity\n-        control.Wait();\n+        control.Complete();\n     });\n }\n BENCHMARK(CCheckQueueSpeedPrevectorJob, benchmark::PriorityLevel::HIGH);\ndiff --git a/src/checkqueue.h b/src/checkqueue.h\nindex a1de000714d59..be41bf8bac71d 100644\n--- a/src/checkqueue.h\n+++ b/src/checkqueue.h\n@@ -11,19 +11,24 @@\n \n #include <algorithm>\n #include <iterator>\n+#include <optional>\n #include <vector>\n \n /**\n  * Queue for verifications that have to be performed.\n   * The verifications are represented by a type T, which must provide an\n-  * operator(), returning a bool.\n+  * operator(), returning an std::optional<R>.\n+  *\n+  * The overall result of the computation is std::nullopt if all invocations\n+  * return std::nullopt, or one of the other results otherwise.\n   *\n   * One thread (the master) is assumed to push batches of verifications\n   * onto the queue, where they are processed by N-1 worker threads. When\n   * the master is done adding work, it temporarily joins the worker pool\n   * as an N'th worker, until all jobs are done.\n+  *\n   */\n-template <typename T>\n+template <typename T, typename R = std::remove_cvref_t<decltype(std::declval<T>()().value())>>\n class CCheckQueue\n {\n private:\n@@ -47,7 +52,7 @@ class CCheckQueue\n     int nTotal GUARDED_BY(m_mutex){0};\n \n     //! The temporary evaluation result.\n-    bool fAllOk GUARDED_BY(m_mutex){true};\n+    std::optional<R> m_result GUARDED_BY(m_mutex);\n \n     /**\n      * Number of verifications that haven't completed yet.\n@@ -62,24 +67,28 @@ class CCheckQueue\n     std::vector<std::thread> m_worker_threads;\n     bool m_request_stop GUARDED_BY(m_mutex){false};\n \n-    /** Internal function that does bulk of the verification work. */\n-    bool Loop(bool fMaster) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    /** Internal function that does bulk of the verification work. If fMaster, return the final result. */\n+    std::optional<R> Loop(bool fMaster) EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n     {\n         std::condition_variable& cond = fMaster ? m_master_cv : m_worker_cv;\n         std::vector<T> vChecks;\n         vChecks.reserve(nBatchSize);\n         unsigned int nNow = 0;\n-        bool fOk = true;\n+        std::optional<R> local_result;\n+        bool do_work;\n         do {\n             {\n                 WAIT_LOCK(m_mutex, lock);\n                 // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n                 if (nNow) {\n-                    fAllOk &= fOk;\n+                    if (local_result.has_value() && !m_result.has_value()) {\n+                        std::swap(local_result, m_result);\n+                    }\n                     nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n+                    if (nTodo == 0 && !fMaster) {\n                         // We processed the last element; inform the master it can exit and return the result\n                         m_master_cv.notify_one();\n+                    }\n                 } else {\n                     // first iteration\n                     nTotal++;\n@@ -88,18 +97,19 @@ class CCheckQueue\n                 while (queue.empty() && !m_request_stop) {\n                     if (fMaster && nTodo == 0) {\n                         nTotal--;\n-                        bool fRet = fAllOk;\n+                        std::optional<R> to_return = std::move(m_result);\n                         // reset the status for new work later\n-                        fAllOk = true;\n+                        m_result = std::nullopt;\n                         // return the current status\n-                        return fRet;\n+                        return to_return;\n                     }\n                     nIdle++;\n                     cond.wait(lock); // wait\n                     nIdle--;\n                 }\n                 if (m_request_stop) {\n-                    return false;\n+                    // return value does not matter, because m_request_stop is only set in the destructor.\n+                    return std::nullopt;\n                 }\n \n                 // Decide how many work units to process now.\n@@ -112,12 +122,15 @@ class CCheckQueue\n                 vChecks.assign(std::make_move_iterator(start_it), std::make_move_iterator(queue.end()));\n                 queue.erase(start_it, queue.end());\n                 // Check whether we need to do work at all\n-                fOk = fAllOk;\n+                do_work = !m_result.has_value();\n             }\n             // execute work\n-            for (T& check : vChecks)\n-                if (fOk)\n-                    fOk = check();\n+            if (do_work) {\n+                for (T& check : vChecks) {\n+                    local_result = check();\n+                    if (local_result.has_value()) break;\n+                }\n+            }\n             vChecks.clear();\n         } while (true);\n     }\n@@ -146,8 +159,9 @@ class CCheckQueue\n     CCheckQueue(CCheckQueue&&) = delete;\n     CCheckQueue& operator=(CCheckQueue&&) = delete;\n \n-    //! Wait until execution finishes, and return whether all evaluations were successful.\n-    bool Wait() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n+    //! Join the execution until completion. If at least one evaluation wasn't successful, return\n+    //! its error.\n+    std::optional<R> Complete() EXCLUSIVE_LOCKS_REQUIRED(!m_mutex)\n     {\n         return Loop(true /* master thread */);\n     }\n@@ -188,11 +202,11 @@ class CCheckQueue\n  * RAII-style controller object for a CCheckQueue that guarantees the passed\n  * queue is finished before continuing.\n  */\n-template <typename T>\n+template <typename T, typename R = std::remove_cvref_t<decltype(std::declval<T>()().value())>>\n class CCheckQueueControl\n {\n private:\n-    CCheckQueue<T> * const pqueue;\n+    CCheckQueue<T, R> * const pqueue;\n     bool fDone;\n \n public:\n@@ -207,13 +221,12 @@ class CCheckQueueControl\n         }\n     }\n \n-    bool Wait()\n+    std::optional<R> Complete()\n     {\n-        if (pqueue == nullptr)\n-            return true;\n-        bool fRet = pqueue->Wait();\n+        if (pqueue == nullptr) return std::nullopt;\n+        auto ret = pqueue->Complete();\n         fDone = true;\n-        return fRet;\n+        return ret;\n     }\n \n     void Add(std::vector<T>&& vChecks)\n@@ -226,7 +239,7 @@ class CCheckQueueControl\n     ~CCheckQueueControl()\n     {\n         if (!fDone)\n-            Wait();\n+            Complete();\n         if (pqueue != nullptr) {\n             LEAVE_CRITICAL_SECTION(pqueue->m_control_mutex);\n         }\ndiff --git a/src/validation.cpp b/src/validation.cpp\nindex 95f3bc58d7d82..1cc4259919452 100644\n--- a/src/validation.cpp\n+++ b/src/validation.cpp\n@@ -2103,10 +2103,16 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txund\n     AddCoins(inputs, tx, nHeight);\n }\n \n-bool CScriptCheck::operator()() {\n+std::optional<std::pair<ScriptError, std::string>> CScriptCheck::operator()() {\n     const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;\n     const CScriptWitness *witness = &ptxTo->vin[nIn].scriptWitness;\n-    return VerifyScript(scriptSig, m_tx_out.scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, m_tx_out.nValue, cacheStore, *m_signature_cache, *txdata), &error);\n+    ScriptError error{SCRIPT_ERR_UNKNOWN_ERROR};\n+    if (VerifyScript(scriptSig, m_tx_out.scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, m_tx_out.nValue, cacheStore, *m_signature_cache, *txdata), &error)) {\n+        return std::nullopt;\n+    } else {\n+        auto debug_str = strprintf(\"input %i of %s (wtxid %s), spending %s:%i\", nIn, ptxTo->GetHash().ToString(), ptxTo->GetWitnessHash().ToString(), ptxTo->vin[nIn].prevout.hash.ToString(), ptxTo->vin[nIn].prevout.n);\n+        return std::make_pair(error, std::move(debug_str));\n+    }\n }\n \n ValidationCache::ValidationCache(const size_t script_execution_cache_bytes, const size_t signature_cache_bytes)\n@@ -2195,9 +2201,7 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState& state,\n         CScriptCheck check(txdata.m_spent_outputs[i], tx, validation_cache.m_signature_cache, i, flags, cacheSigStore, &txdata);\n         if (pvChecks) {\n             pvChecks->emplace_back(std::move(check));\n-        } else if (!check()) {\n-            ScriptError error{check.GetScriptError()};\n-\n+        } else if (auto result = check(); result.has_value()) {\n             if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n                 // Check whether the failure was caused by a\n                 // non-mandatory script verification check, such as\n@@ -2209,21 +2213,23 @@ bool CheckInputScripts(const CTransaction& tx, TxValidationState& state,\n                 // data providers.\n                 CScriptCheck check2(txdata.m_spent_outputs[i], tx, validation_cache.m_signature_cache, i,\n                         flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n-                if (check2())\n-                    return state.Invalid(TxValidationResult::TX_NOT_STANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n-\n-                // If the second check failed, it failed due to a mandatory script verification\n-                // flag, but the first check might have failed on a non-mandatory script\n-                // verification flag.\n-                //\n-                // Avoid reporting a mandatory script check failure with a non-mandatory error\n-                // string by reporting the error from the second check.\n-                error = check2.GetScriptError();\n+                auto mandatory_result = check2();\n+                if (!mandatory_result.has_value()) {\n+                    return state.Invalid(TxValidationResult::TX_NOT_STANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(result->first)), result->second);\n+                } else {\n+                    // If the second check failed, it failed due to a mandatory script verification\n+                    // flag, but the first check might have failed on a non-mandatory script\n+                    // verification flag.\n+                    //\n+                    // Avoid reporting a mandatory script check failure with a non-mandatory error\n+                    // string by reporting the error from the second check.\n+                    result = mandatory_result;\n+                }\n             }\n \n             // MANDATORY flag failures correspond to\n             // TxValidationResult::TX_CONSENSUS.\n-            return state.Invalid(TxValidationResult::TX_CONSENSUS, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(error)));\n+            return state.Invalid(TxValidationResult::TX_CONSENSUS, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(result->first)), result->second);\n         }\n     }\n \n@@ -2589,8 +2595,8 @@ bool Chainstate::ConnectBlock(const CBlock& block, BlockValidationState& state,\n         for (const auto& tx : block.vtx) {\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n-                    LogPrintf(\"ERROR: ConnectBlock(): tried to overwrite transaction\\n\");\n-                    return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-txns-BIP30\");\n+                    state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-txns-BIP30\",\n+                                  \"tried to overwrite transaction\");\n                 }\n             }\n         }\n@@ -2629,6 +2635,7 @@ bool Chainstate::ConnectBlock(const CBlock& block, BlockValidationState& state,\n     blockundo.vtxundo.reserve(block.vtx.size() - 1);\n     for (unsigned int i = 0; i < block.vtx.size(); i++)\n     {\n+        if (!state.IsValid()) break;\n         const CTransaction &tx = *(block.vtx[i]);\n \n         nInputs += tx.vin.size();\n@@ -2640,14 +2647,15 @@ bool Chainstate::ConnectBlock(const CBlock& block, BlockValidationState& state,\n             if (!Consensus::CheckTxInputs(tx, tx_state, view, pindex->nHeight, txfee)) {\n                 // Any transaction validation failure in ConnectBlock is a block consensus failure\n                 state.Invalid(BlockValidationResult::BLOCK_CONSENSUS,\n-                            tx_state.GetRejectReason(), tx_state.GetDebugMessage());\n-                LogError(\"%s: Consensus::CheckTxInputs: %s, %s\\n\", __func__, tx.GetHash().ToString(), state.ToString());\n-                return false;\n+                              tx_state.GetRejectReason(),\n+                              tx_state.GetDebugMessage() + \" in transaction \" + tx.GetHash().ToString());\n+                break;\n             }\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n-                LogPrintf(\"ERROR: %s: accumulated fee in the block out of range.\\n\", __func__);\n-                return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-txns-accumulated-fee-outofrange\");\n+                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-txns-accumulated-fee-outofrange\",\n+                              \"accumulated fee in the block out of range\");\n+                break;\n             }\n \n             // Check that transaction is BIP68 final\n@@ -2659,8 +2667,9 @@ bool Chainstate::ConnectBlock(const CBlock& block, BlockValidationState& state,\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, prevheights, *pindex)) {\n-                LogPrintf(\"ERROR: %s: contains a non-BIP68-final transaction\\n\", __func__);\n-                return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-txns-nonfinal\");\n+                state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-txns-nonfinal\",\n+                              \"contains a non-BIP68-final transaction \" + tx.GetHash().ToString());\n+                break;\n             }\n         }\n \n@@ -2670,8 +2679,8 @@ bool Chainstate::ConnectBlock(const CBlock& block, BlockValidationState& state,\n         // * witness (when witness enabled in flags and excludes coinbase)\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n         if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST) {\n-            LogPrintf(\"ERROR: ConnectBlock(): too many sigops\\n\");\n-            return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-blk-sigops\");\n+            state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-blk-sigops\", \"too many sigops\");\n+            break;\n         }\n \n         if (!tx.IsCoinBase())\n@@ -2683,9 +2692,7 @@ bool Chainstate::ConnectBlock(const CBlock& block, BlockValidationState& state,\n                 // Any transaction validation failure in ConnectBlock is a block consensus failure\n                 state.Invalid(BlockValidationResult::BLOCK_CONSENSUS,\n                               tx_state.GetRejectReason(), tx_state.GetDebugMessage());\n-                LogError(\"ConnectBlock(): CheckInputScripts on %s failed with %s\\n\",\n-                    tx.GetHash().ToString(), state.ToString());\n-                return false;\n+                break;\n             }\n             control.Add(std::move(vChecks));\n         }\n@@ -2705,14 +2712,18 @@ bool Chainstate::ConnectBlock(const CBlock& block, BlockValidationState& state,\n              Ticks<MillisecondsDouble>(m_chainman.time_connect) / m_chainman.num_blocks_total);\n \n     CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, params.GetConsensus());\n-    if (block.vtx[0]->GetValueOut() > blockReward) {\n-        LogPrintf(\"ERROR: ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\\n\", block.vtx[0]->GetValueOut(), blockReward);\n-        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-cb-amount\");\n+    if (block.vtx[0]->GetValueOut() > blockReward && state.IsValid()) {\n+        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"bad-cb-amount\",\n+                      strprintf(\"coinbase pays too much (actual=%d vs limit=%d)\", block.vtx[0]->GetValueOut(), blockReward));\n     }\n \n-    if (!control.Wait()) {\n-        LogPrintf(\"ERROR: %s: CheckQueue failed\\n\", __func__);\n-        return state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, \"block-validation-failed\");\n+    auto parallel_result = control.Complete();\n+    if (parallel_result.has_value() && state.IsValid()) {\n+        state.Invalid(BlockValidationResult::BLOCK_CONSENSUS, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(parallel_result->first)), parallel_result->second);\n+    }\n+    if (!state.IsValid()) {\n+        LogInfo(\"Block validation error: %s\", state.ToString());\n+        return false;\n     }\n     const auto time_4{SteadyClock::now()};\n     m_chainman.time_verify += time_4 - time_2;\n@@ -2722,8 +2733,9 @@ bool Chainstate::ConnectBlock(const CBlock& block, BlockValidationState& state,\n              Ticks<SecondsDouble>(m_chainman.time_verify),\n              Ticks<MillisecondsDouble>(m_chainman.time_verify) / m_chainman.num_blocks_total);\n \n-    if (fJustCheck)\n+    if (fJustCheck) {\n         return true;\n+    }\n \n     if (!m_blockman.WriteUndoDataForBlock(blockundo, state, *pindex)) {\n         return false;\ndiff --git a/src/validation.h b/src/validation.h\nindex 723babca31568..6b67dc485b837 100644\n--- a/src/validation.h\n+++ b/src/validation.h\n@@ -335,7 +335,6 @@ class CScriptCheck\n     unsigned int nIn;\n     unsigned int nFlags;\n     bool cacheStore;\n-    ScriptError error{SCRIPT_ERR_UNKNOWN_ERROR};\n     PrecomputedTransactionData *txdata;\n     SignatureCache* m_signature_cache;\n \n@@ -348,9 +347,7 @@ class CScriptCheck\n     CScriptCheck(CScriptCheck&&) = default;\n     CScriptCheck& operator=(CScriptCheck&&) = default;\n \n-    bool operator()();\n-\n-    ScriptError GetScriptError() const { return error; }\n+    std::optional<std::pair<ScriptError, std::string>> operator()();\n };\n \n // CScriptCheck is used a lot in std::vector, make sure that's efficient\n", "instance_id": "bitcoin__bitcoin-31112", "clarity": 2, "difficulty": 0.65, "clarity_explanation": "The problem statement is mostly clear in its intent to enhance logging for `CheckQueue` failures during block validation, as seen in the provided log output and the suggestion to include detailed error information without requiring a node restart with specific parameters. The goal is evident: to log more detailed information about the cause of a `ConnectBlock` failure. However, there are minor ambiguities and missing details. For instance, the problem statement does not explicitly define the exact format or content of the additional information to be logged beyond the example of a script verification failure. It also lacks clarity on whether this logging should cover all possible failure modes or just specific ones like script verification. Additionally, constraints or performance considerations for logging (e.g., impact on node operation or log size) are not mentioned. Despite these minor gaps, the intent and context are sufficiently clear with the provided logs and the reference to hardware issues as a potential cause.", "difficulty_explanation": "The difficulty of this problem falls into the \"Hard\" category due to several factors. First, the scope of code changes is significant, spanning multiple files (`checkqueue.h`, `validation.cpp`, etc.) and requiring modifications to core components of a blockchain validation system, likely part of Bitcoin Core or a similar project. The changes involve altering the `CCheckQueue` class to support returning detailed error information via `std::optional`, which necessitates a deep understanding of the existing parallel processing and verification logic. Second, the technical concepts involved are moderately complex, including C++ template programming, mutex-based synchronization, and domain-specific knowledge of blockchain transaction validation (e.g., script verification, BIP68, BIP30). Third, the modifications impact critical system behavior\u2014block validation\u2014and require careful handling to avoid introducing bugs in a consensus-critical codebase. While edge cases are not extensively detailed in the problem statement, the code changes show attention to error handling (e.g., script verification errors with detailed debug strings), indicating a need to manage various failure modes. However, this is not at the \"Very Hard\" level (0.8-1.0) because it does not involve fundamental architectural redesign or advanced domain-specific algorithms; it is more about enhancing error reporting within an existing framework. Thus, a score of 0.65 reflects the need for deep codebase familiarity, careful implementation across multiple modules, and attention to error handling in a critical system.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "Drag tab into new window lost all panels besides the first\n### Windows Terminal version\n\nPreview 1.23.10353.0\n\n### Windows build number\n\n10.0.22631.0\n\n### Other Software\n\n_No response_\n\n### Steps to reproduce\n\nCreate two tabs. In the second one split the screen in two panels. Drag this second tab into a new window.\n\n### Expected Behavior\n\nThe new window will have both panels. Terminal 1.21.10351.0 works as expected.\n\n### Actual Behavior\n\nThe new window have only the terminal in the first panel. From the task explorer, the processes in the lost panels doesn't become detach, they are just killed. \n", "patch": "diff --git a/src/cascadia/LocalTests_TerminalApp/TabTests.cpp b/src/cascadia/LocalTests_TerminalApp/TabTests.cpp\nindex 477e6dcf0ea..941d5fa06fe 100644\n--- a/src/cascadia/LocalTests_TerminalApp/TabTests.cpp\n+++ b/src/cascadia/LocalTests_TerminalApp/TabTests.cpp\n@@ -287,7 +287,7 @@ namespace TerminalAppLocalTests\n             NewTabArgs args{ newTerminalArgs };\r\n             ActionAndArgs newTabAction{ ShortcutAction::NewTab, args };\r\n             // push the arg onto the front\r\n-            page->_startupActions.Append(newTabAction);\r\n+            page->_startupActions.push_back(std::move(newTabAction));\r\n             Log::Comment(L\"Added a single newTab action\");\r\n \r\n             auto app = ::winrt::Windows::UI::Xaml::Application::Current();\r\ndiff --git a/src/cascadia/TerminalApp/AppActionHandlers.cpp b/src/cascadia/TerminalApp/AppActionHandlers.cpp\nindex b2ae698205a..69648929637 100644\n--- a/src/cascadia/TerminalApp/AppActionHandlers.cpp\n+++ b/src/cascadia/TerminalApp/AppActionHandlers.cpp\n@@ -752,13 +752,11 @@ namespace winrt::TerminalApp::implementation\n     {\r\n         if (const auto& realArgs = actionArgs.ActionArgs().try_as<ExecuteCommandlineArgs>())\r\n         {\r\n-            auto actions = winrt::single_threaded_vector<ActionAndArgs>(\r\n-                TerminalPage::ConvertExecuteCommandlineToActions(realArgs));\r\n-\r\n-            if (actions.Size() != 0)\r\n+            auto actions = ConvertExecuteCommandlineToActions(realArgs);\r\n+            if (!actions.empty())\r\n             {\r\n                 actionArgs.Handled(true);\r\n-                ProcessStartupActions(actions, false);\r\n+                ProcessStartupActions(std::move(actions), false);\r\n             }\r\n         }\r\n     }\r\ndiff --git a/src/cascadia/TerminalApp/TerminalPage.cpp b/src/cascadia/TerminalApp/TerminalPage.cpp\nindex 7604b4d7d56..7db179c9067 100644\n--- a/src/cascadia/TerminalApp/TerminalPage.cpp\n+++ b/src/cascadia/TerminalApp/TerminalPage.cpp\n@@ -62,7 +62,6 @@ namespace winrt::TerminalApp::implementation\n     TerminalPage::TerminalPage(TerminalApp::WindowProperties properties, const TerminalApp::ContentManager& manager) :\n         _tabs{ winrt::single_threaded_observable_vector<TerminalApp::TabBase>() },\n         _mruTabs{ winrt::single_threaded_observable_vector<TerminalApp::TabBase>() },\n-        _startupActions{ winrt::single_threaded_vector<ActionAndArgs>() },\n         _manager{ manager },\n         _hostingHwnd{},\n         _WindowProperties{ std::move(properties) }\n@@ -297,7 +296,7 @@ namespace winrt::TerminalApp::implementation\n         // GH#12267: Don't forget about defterm handoff here. If we're being\n         // created for embedding, then _yea_, we don't need to handoff to an\n         // elevated window.\n-        if (!_startupActions || IsRunningElevated() || _shouldStartInboundListener || _startupActions.Size() == 0)\n+        if (_startupActions.empty() || IsRunningElevated() || _shouldStartInboundListener)\n         {\n             // there aren't startup actions, or we're elevated. In that case, go for it.\n             return false;\n@@ -375,7 +374,7 @@ namespace winrt::TerminalApp::implementation\n     // - <none>\n     void TerminalPage::HandoffToElevated(const CascadiaSettings& settings)\n     {\n-        if (!_startupActions)\n+        if (_startupActions.empty())\n         {\n             return;\n         }\n@@ -489,7 +488,7 @@ namespace winrt::TerminalApp::implementation\n         {\n             _startupState = StartupState::InStartup;\n \n-            ProcessStartupActions(_startupActions, true);\n+            ProcessStartupActions(std::move(_startupActions), true);\n \n             // If we were told that the COM server needs to be started to listen for incoming\n             // default application connections, start it now.\n@@ -546,80 +545,56 @@ namespace winrt::TerminalApp::implementation\n     //   nt -d .` from inside another directory to work as expected.\n     // Return Value:\n     // - <none>\n-    safe_void_coroutine TerminalPage::ProcessStartupActions(Windows::Foundation::Collections::IVector<ActionAndArgs> actions,\n-                                                            const bool initial,\n-                                                            const winrt::hstring cwd,\n-                                                            const winrt::hstring env)\n+    safe_void_coroutine TerminalPage::ProcessStartupActions(std::vector<ActionAndArgs> actions, const bool initial, const winrt::hstring cwd, const winrt::hstring env)\n     {\n-        auto weakThis{ get_weak() };\n-\n-        // Handle it on a subsequent pass of the UI thread.\n-        co_await wil::resume_foreground(Dispatcher(), CoreDispatcherPriority::Normal);\n+        const auto strong = get_strong();\n \n         // If the caller provided a CWD, \"switch\" to that directory, then switch\n-        // back once we're done. This looks weird though, because we have to set\n-        // up the scope_exit _first_. We'll release the scope_exit if we don't\n-        // actually need it.\n-\n+        // back once we're done.\n         auto originalVirtualCwd{ _WindowProperties.VirtualWorkingDirectory() };\n-        auto restoreCwd = wil::scope_exit([&originalVirtualCwd, this]() {\n-            // ignore errors, we'll just power on through. We'd rather do\n-            // something rather than fail silently if the directory doesn't\n-            // actually exist.\n-            _WindowProperties.VirtualWorkingDirectory(originalVirtualCwd);\n-        });\n-\n-        // Literally the same thing with env vars too\n         auto originalVirtualEnv{ _WindowProperties.VirtualEnvVars() };\n-        auto restoreEnv = wil::scope_exit([&originalVirtualEnv, this]() {\n-            _WindowProperties.VirtualEnvVars(originalVirtualEnv);\n+        auto restoreCwd = wil::scope_exit([&]() {\n+            if (!cwd.empty())\n+            {\n+                // ignore errors, we'll just power on through. We'd rather do\n+                // something rather than fail silently if the directory doesn't\n+                // actually exist.\n+                _WindowProperties.VirtualWorkingDirectory(originalVirtualCwd);\n+                _WindowProperties.VirtualEnvVars(originalVirtualEnv);\n+            }\n         });\n+        _WindowProperties.VirtualWorkingDirectory(cwd);\n+        _WindowProperties.VirtualEnvVars(env);\n \n-        if (cwd.empty())\n+        for (size_t i = 0; i < actions.size(); ++i)\n         {\n-            // We didn't actually need to change the virtual CWD, so we don't\n-            // need to restore it\n-            restoreCwd.release();\n-        }\n-        else\n-        {\n-            _WindowProperties.VirtualWorkingDirectory(cwd);\n-        }\n+            if (i != 0)\n+            {\n+                // Each action may rely on the XAML layout of a preceding action.\n+                // Most importantly, this is the case for the combination of NewTab + SplitPane,\n+                // as the former appears to only have a layout size after at least 1 resume_foreground,\n+                // while the latter relies on that information. This is also why it uses Low priority.\n+                //\n+                // Curiously, this does not seem to be required when using startupActions, but only when\n+                // tearing out a tab (this currently creates a new window with injected startup actions).\n+                // This indicates that this is really more of an architectural issue and not a fundamental one.\n+                co_await wil::resume_foreground(Dispatcher(), CoreDispatcherPriority::Low);\n+            }\n \n-        if (env.empty())\n-        {\n-            restoreEnv.release();\n-        }\n-        else\n-        {\n-            _WindowProperties.VirtualEnvVars(env);\n+            _actionDispatch->DoAction(actions[i]);\n         }\n \n-        if (auto page{ weakThis.get() })\n+        // GH#6586: now that we're done processing all startup commands,\n+        // focus the active control. This will work as expected for both\n+        // commandline invocations and for `wt` action invocations.\n+        if (const auto& terminalTab{ _GetFocusedTabImpl() })\n         {\n-            for (const auto& action : actions)\n+            if (const auto& content{ terminalTab->GetActiveContent() })\n             {\n-                if (auto page{ weakThis.get() })\n-                {\n-                    _actionDispatch->DoAction(action);\n-                }\n-                else\n-                {\n-                    co_return;\n-                }\n-            }\n-\n-            // GH#6586: now that we're done processing all startup commands,\n-            // focus the active control. This will work as expected for both\n-            // commandline invocations and for `wt` action invocations.\n-            if (const auto& terminalTab{ _GetFocusedTabImpl() })\n-            {\n-                if (const auto& content{ terminalTab->GetActiveContent() })\n-                {\n-                    content.Focus(FocusState::Programmatic);\n-                }\n+                content.Focus(FocusState::Programmatic);\n             }\n         }\n+\n         if (initial)\n         {\n             _CompleteInitialization();\n@@ -3664,13 +3639,9 @@ namespace winrt::TerminalApp::implementation\n     // - actions: a list of Actions to process on startup.\n     // Return Value:\n     // - <none>\n-    void TerminalPage::SetStartupActions(std::vector<ActionAndArgs>& actions)\n+    void TerminalPage::SetStartupActions(std::vector<ActionAndArgs> actions)\n     {\n-        // The fastest way to copy all the actions out of the std::vector and\n-        // put them into a winrt::IVector is by making a copy, then moving the\n-        // copy into the winrt vector ctor.\n-        auto listCopy = actions;\n-        _startupActions = winrt::single_threaded_vector<ActionAndArgs>(std::move(listCopy));\n+        _startupActions = std::move(actions);\n     }\n \n     // Routine Description:\ndiff --git a/src/cascadia/TerminalApp/TerminalPage.h b/src/cascadia/TerminalApp/TerminalPage.h\nindex d094e07f0fe..9837f9fe618 100644\n--- a/src/cascadia/TerminalApp/TerminalPage.h\n+++ b/src/cascadia/TerminalApp/TerminalPage.h\n@@ -128,7 +128,7 @@ namespace winrt::TerminalApp::implementation\n         void Maximized(bool newMaximized);\n         void RequestSetMaximized(bool newMaximized);\n \n-        void SetStartupActions(std::vector<Microsoft::Terminal::Settings::Model::ActionAndArgs>& actions);\n+        void SetStartupActions(std::vector<Microsoft::Terminal::Settings::Model::ActionAndArgs> actions);\n \n         void SetInboundListener(bool isEmbedding);\n         static std::vector<Microsoft::Terminal::Settings::Model::ActionAndArgs> ConvertExecuteCommandlineToActions(const Microsoft::Terminal::Settings::Model::ExecuteCommandlineArgs& args);\n@@ -146,7 +146,7 @@ namespace winrt::TerminalApp::implementation\n         void ActionSaveFailed(winrt::hstring message);\n         void ShowTerminalWorkingDirectory();\n \n-        safe_void_coroutine ProcessStartupActions(Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::ActionAndArgs> actions,\n+        safe_void_coroutine ProcessStartupActions(std::vector<Microsoft::Terminal::Settings::Model::ActionAndArgs> actions,\n                                                   const bool initial,\n                                                   const winrt::hstring cwd = winrt::hstring{},\n                                                   const winrt::hstring env = winrt::hstring{});\n@@ -255,7 +255,7 @@ namespace winrt::TerminalApp::implementation\n         winrt::Windows::UI::Xaml::Controls::Grid::LayoutUpdated_revoker _layoutUpdatedRevoker;\n         StartupState _startupState{ StartupState::NotInitialized };\n \n-        Windows::Foundation::Collections::IVector<Microsoft::Terminal::Settings::Model::ActionAndArgs> _startupActions;\n+        std::vector<Microsoft::Terminal::Settings::Model::ActionAndArgs> _startupActions;\n         bool _shouldStartInboundListener{ false };\n         bool _isEmbeddingInboundListener{ false };\n \ndiff --git a/src/cascadia/TerminalApp/TerminalWindow.cpp b/src/cascadia/TerminalApp/TerminalWindow.cpp\nindex 055d6123ccf..4d644666e1c 100644\n--- a/src/cascadia/TerminalApp/TerminalWindow.cpp\n+++ b/src/cascadia/TerminalApp/TerminalWindow.cpp\n@@ -1054,12 +1054,8 @@ namespace winrt::TerminalApp::implementation\n     {\r\n         _contentBounds = bounds;\r\n \r\n-        const auto& args = _contentStringToActions(content, true);\r\n-\r\n-        for (const auto& action : args)\r\n-        {\r\n-            _initialContentArgs.push_back(action);\r\n-        }\r\n+        const auto args = _contentStringToActions(content, true);\r\n+        _initialContentArgs = wil::to_vector(args);\r\n     }\r\n \r\n     // Method Description:\r\n@@ -1085,7 +1081,7 @@ namespace winrt::TerminalApp::implementation\n         if (_appArgs->ExitCode() == 0)\r\n         {\r\n             auto& parsedArgs = _appArgs->ParsedArgs();\r\n-            auto actions = winrt::single_threaded_vector<ActionAndArgs>(std::move(parsedArgs.GetStartupActions()));\r\n+            auto& actions = parsedArgs.GetStartupActions();\r\n \r\n             _root->ProcessStartupActions(actions, false, _appArgs->CurrentDirectory(), _appArgs->CurrentEnvironment());\r\n \r\n@@ -1200,7 +1196,7 @@ namespace winrt::TerminalApp::implementation\n     {\r\n         try\r\n         {\r\n-            const auto& args = ActionAndArgs::Deserialize(content);\r\n+            const auto args = ActionAndArgs::Deserialize(content);\r\n             if (args == nullptr ||\r\n                 args.Size() == 0)\r\n             {\r\n@@ -1244,9 +1240,9 @@ namespace winrt::TerminalApp::implementation\n \r\n             const bool replaceFirstWithNewTab = tabIndex >= _root->NumberOfTabs();\r\n \r\n-            const auto& args = _contentStringToActions(content, replaceFirstWithNewTab);\r\n+            auto args = _contentStringToActions(content, replaceFirstWithNewTab);\r\n \r\n-            _root->AttachContent(args, tabIndex);\r\n+            _root->AttachContent(std::move(args), tabIndex);\r\n         }\r\n     }\r\n     void TerminalWindow::SendContentToOther(winrt::TerminalApp::RequestReceiveContentArgs args)\r\n", "instance_id": "microsoft__terminal-18627", "clarity": 2, "difficulty": 0.65, "clarity_explanation": "The problem statement is mostly clear in describing the issue: when dragging a tab with multiple panels into a new window in Windows Terminal, only the first panel is retained, and the other panels are lost (with their processes being terminated). The goal is to ensure that all panels are preserved in the new window. The statement includes the version of the software, steps to reproduce, expected behavior, and actual behavior, which provides a good foundation for understanding the issue. However, it lacks specific technical details about the root cause or constraints (e.g., whether this is a UI rendering issue, a data serialization issue, or a process management issue). Additionally, edge cases or specific scenarios (e.g., behavior with different types of panels or configurations) are not mentioned, which could be critical for a complete solution. Hence, while the problem is valid and mostly clear, minor details are missing, warranting a score of 2 (Mostly Clear).", "difficulty_explanation": "The difficulty of this problem falls into the \"Hard\" category (0.6-0.8) due to several factors. First, the scope of code changes spans multiple files (e.g., TerminalPage.cpp, TerminalWindow.cpp, AppActionHandlers.cpp) and involves significant modifications to how startup actions and content are handled when a tab is dragged into a new window. This requires understanding the interactions between different components of the Windows Terminal codebase, such as tab management, action dispatching, and window initialization. Second, the technical concepts involved include C++ with WinRT (Windows Runtime), coroutines (safe_void_coroutine), and specific Windows Terminal abstractions like ActionAndArgs and TerminalPage. These are moderately advanced concepts, especially given the use of asynchronous programming and the need to manage UI state correctly. Third, the changes impact core functionality (tab and panel management), which could have architectural implications if not handled carefully, especially when ensuring that panel state and associated processes are preserved during the drag operation. Finally, while the problem statement does not explicitly mention edge cases, the nature of the issue implies potential complexities, such as handling different panel configurations, ensuring process continuity, and managing UI focus (as seen in the code changes). The code changes themselves are non-trivial, involving refactoring from WinRT collections to standard C++ containers (e.g., std::vector) and adjusting how actions are processed and dispatched. Overall, this problem requires a deep understanding of the codebase and careful handling of state and UI logic, justifying a difficulty score of 0.65.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "Clear Buffer is broken in Windows Terminal Preview (1.22.2362.0)\n### Windows Terminal version\r\n\r\n1.22.2362.0\r\n\r\n### Windows build number\r\n\r\n10.0.22631.4037\r\n\r\n### Steps to reproduce\r\n\r\n* Settings -> Actions -> Add New -> Add \"Ctrl+l\" (lowercase L) for \"Clear Buffer\". Press Save.\r\n* Open tab with \"Command Prompt\".\r\n* Execute \"cd C:\\Windows\". Execute \"dir\" several times to fill the screen.\r\n* Press Ctrl+l (lowercase L).\r\n\r\n### Expected Behavior\r\n\r\nClear Buffer works fine in Windows Terminal v.1.20.11781.0.\r\n\r\n### Actual Behavior\r\n\r\nClear Buffer does not work in Windows Terminal Preview v.1.22.2362.0.\r\n\r\nThe same problem can be reproduced with \"Ubuntu 24.04 LTS\" tab (WSL2).\r\n\r\nI've just noticed that pressing Ctrl+Shift+L works differently from Ctrl+L (but still broken). And I didn't assign Ctrl+Shift+L to anything.\n", "patch": "diff --git a/src/cascadia/TerminalControl/ControlCore.cpp b/src/cascadia/TerminalControl/ControlCore.cpp\nindex cd4f5f58b81..5c96b5c805c 100644\n--- a/src/cascadia/TerminalControl/ControlCore.cpp\n+++ b/src/cascadia/TerminalControl/ControlCore.cpp\n@@ -2221,19 +2221,32 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n     // - <none>\r\n     void ControlCore::ClearBuffer(Control::ClearBufferType clearType)\r\n     {\r\n-        if (clearType == Control::ClearBufferType::Scrollback || clearType == Control::ClearBufferType::All)\r\n+        std::wstring_view command;\r\n+        switch (clearType)\r\n+        {\r\n+        case ClearBufferType::Screen:\r\n+            command = L\"\\x1b[H\\x1b[2J\";\r\n+            break;\r\n+        case ClearBufferType::Scrollback:\r\n+            command = L\"\\x1b[3J\";\r\n+            break;\r\n+        case ClearBufferType::All:\r\n+            command = L\"\\x1b[H\\x1b[2J\\x1b[3J\";\r\n+            break;\r\n+        }\r\n+\r\n         {\r\n             const auto lock = _terminal->LockForWriting();\r\n-            _terminal->EraseScrollback();\r\n+            _terminal->Write(command);\r\n         }\r\n \r\n         if (clearType == Control::ClearBufferType::Screen || clearType == Control::ClearBufferType::All)\r\n         {\r\n-            // Send a signal to conpty to clear the buffer.\r\n             if (auto conpty{ _connection.try_as<TerminalConnection::ConptyConnection>() })\r\n             {\r\n-                // ConPTY will emit sequences to sync up our buffer with its new\r\n-                // contents.\r\n+                // Since the clearing of ConPTY occurs asynchronously, this call can result weird issues,\r\n+                // where a console application still sees contents that we've already deleted, etc.\r\n+                // The correct way would be for ConPTY to emit the appropriate CSI n J sequences.\r\n                 conpty.ClearBuffer();\r\n             }\r\n         }\r\ndiff --git a/src/cascadia/TerminalCore/Terminal.cpp b/src/cascadia/TerminalCore/Terminal.cpp\nindex c5876e1497c..4b855b02f6c 100644\n--- a/src/cascadia/TerminalCore/Terminal.cpp\n+++ b/src/cascadia/TerminalCore/Terminal.cpp\n@@ -209,12 +209,6 @@ void Terminal::SetCursorStyle(const DispatchTypes::CursorStyle cursorStyle)\n     engine.Dispatch().SetCursorStyle(cursorStyle);\r\n }\r\n \r\n-void Terminal::EraseScrollback()\r\n-{\r\n-    auto& engine = reinterpret_cast<OutputStateMachineEngine&>(_stateMachine->Engine());\r\n-    engine.Dispatch().EraseInDisplay(DispatchTypes::EraseType::Scrollback);\r\n-}\r\n-\r\n bool Terminal::IsXtermBracketedPasteModeEnabled() const noexcept\r\n {\r\n     return _systemMode.test(Mode::BracketedPaste);\r\ndiff --git a/src/cascadia/TerminalCore/Terminal.hpp b/src/cascadia/TerminalCore/Terminal.hpp\nindex e9d3f1abd0a..ae7c2dbe168 100644\n--- a/src/cascadia/TerminalCore/Terminal.hpp\n+++ b/src/cascadia/TerminalCore/Terminal.hpp\n@@ -94,7 +94,6 @@ class Microsoft::Terminal::Core::Terminal final :\n     void UpdateAppearance(const winrt::Microsoft::Terminal::Core::ICoreAppearance& appearance);\r\n     void SetFontInfo(const FontInfo& fontInfo);\r\n     void SetCursorStyle(const ::Microsoft::Console::VirtualTerminal::DispatchTypes::CursorStyle cursorStyle);\r\n-    void EraseScrollback();\r\n     bool IsXtermBracketedPasteModeEnabled() const noexcept;\r\n     std::wstring_view GetWorkingDirectory() noexcept;\r\n \r\ndiff --git a/src/cascadia/UnitTests_Control/ControlCoreTests.cpp b/src/cascadia/UnitTests_Control/ControlCoreTests.cpp\nindex 4620afae09a..e018e1fd2ad 100644\n--- a/src/cascadia/UnitTests_Control/ControlCoreTests.cpp\n+++ b/src/cascadia/UnitTests_Control/ControlCoreTests.cpp\n@@ -304,9 +304,9 @@ namespace ControlUnitTests\n \r\n         Log::Comment(L\"Check the buffer after the clear\");\r\n         VERIFY_ARE_EQUAL(20, core->_terminal->GetViewport().Height());\r\n-        VERIFY_ARE_EQUAL(21, core->ScrollOffset());\r\n+        VERIFY_ARE_EQUAL(41, core->ScrollOffset());\r\n         VERIFY_ARE_EQUAL(20, core->ViewHeight());\r\n-        VERIFY_ARE_EQUAL(41, core->BufferHeight());\r\n+        VERIFY_ARE_EQUAL(61, core->BufferHeight());\r\n \r\n         // In this test, we can't actually check if we cleared the buffer\r\n         // contents. ConPTY will handle the actual clearing of the buffer\r\ndiff --git a/src/host/PtySignalInputThread.cpp b/src/host/PtySignalInputThread.cpp\nindex 45860f9c1a0..fa3893b4dd0 100644\n--- a/src/host/PtySignalInputThread.cpp\n+++ b/src/host/PtySignalInputThread.cpp\n@@ -7,6 +7,7 @@\n \r\n #include \"output.h\"\r\n #include \"handle.h\"\r\n+#include \"_stream.h\"\r\n #include \"../interactivity/inc/ServiceLocator.hpp\"\r\n \r\n using namespace Microsoft::Console;\r\n@@ -197,7 +198,9 @@ void PtySignalInputThread::_DoClearBuffer() const\n     }\r\n \r\n     auto& gci = ServiceLocator::LocateGlobals().getConsoleInformation();\r\n-    THROW_IF_FAILED(gci.GetActiveOutputBuffer().ClearBuffer());\r\n+    auto& screenInfo = gci.GetActiveOutputBuffer();\r\n+    auto& stateMachine = screenInfo.GetStateMachine();\r\n+    stateMachine.ProcessString(L\"\\x1b[H\\x1b[2J\");\r\n }\r\n \r\n void PtySignalInputThread::_DoShowHide(const ShowHideData& data)\r\ndiff --git a/src/host/screenInfo.cpp b/src/host/screenInfo.cpp\nindex 8d5e9217246..3e1ae49d4b3 100644\n--- a/src/host/screenInfo.cpp\n+++ b/src/host/screenInfo.cpp\n@@ -2129,38 +2129,6 @@ void SCREEN_INFORMATION::SetViewport(const Viewport& newViewport,\n     Tracing::s_TraceWindowViewport(_viewport);\r\n }\r\n \r\n-// Method Description:\r\n-// - Clear the entire contents of the viewport, except for the cursor's row,\r\n-//   which is moved to the top line of the viewport.\r\n-// - This is used exclusively by ConPTY to support GH#1193, GH#1882. This allows\r\n-//   a terminal to clear the contents of the ConPTY buffer, which is important\r\n-//   if the user would like to be able to clear the terminal-side buffer.\r\n-// Arguments:\r\n-// - <none>\r\n-// Return Value:\r\n-// - S_OK\r\n-[[nodiscard]] HRESULT SCREEN_INFORMATION::ClearBuffer()\r\n-{\r\n-    // Rotate the buffer to bring the cursor row to the top of the viewport.\r\n-    const auto cursorPos = _textBuffer->GetCursor().GetPosition();\r\n-    for (auto i = 0; i < cursorPos.y; i++)\r\n-    {\r\n-        _textBuffer->IncrementCircularBuffer();\r\n-    }\r\n-\r\n-    // Erase everything below that point.\r\n-    RETURN_IF_FAILED(SetCursorPosition({ 0, 1 }, false));\r\n-    auto& engine = reinterpret_cast<OutputStateMachineEngine&>(_stateMachine->Engine());\r\n-    engine.Dispatch().EraseInDisplay(DispatchTypes::EraseType::ToEnd);\r\n-\r\n-    // Restore the original cursor x offset, but now on the first row.\r\n-    RETURN_IF_FAILED(SetCursorPosition({ cursorPos.x, 0 }, false));\r\n-\r\n-    _textBuffer->TriggerRedrawAll();\r\n-\r\n-    return S_OK;\r\n-}\r\n-\r\n // Routine Description:\r\n // - Writes cells to the output buffer at the cursor position.\r\n // Arguments:\r\ndiff --git a/src/host/screenInfo.hpp b/src/host/screenInfo.hpp\nindex 4ecd1a4e3e9..c7685cb1c06 100644\n--- a/src/host/screenInfo.hpp\n+++ b/src/host/screenInfo.hpp\n@@ -203,8 +203,6 @@ class SCREEN_INFORMATION : public ConsoleObjectHeader, public Microsoft::Console\n     void SetDefaultAttributes(const TextAttribute& attributes,\r\n                               const TextAttribute& popupAttributes);\r\n \r\n-    [[nodiscard]] HRESULT ClearBuffer();\r\n-\r\n     void UpdateBottom();\r\n \r\n     FontInfo& GetCurrentFont() noexcept;\r\n", "instance_id": "microsoft__terminal-17884", "clarity": 2, "difficulty": 0.55, "clarity_explanation": "The problem statement is mostly clear in describing the issue: the \"Clear Buffer\" functionality is broken in Windows Terminal Preview (version 1.22.2362.0) when using the assigned shortcut Ctrl+L, and it behaves differently with Ctrl+Shift+L. The steps to reproduce are provided, along with the expected and actual behavior, which helps in understanding the issue. However, there are minor ambiguities and missing details. For instance, the problem statement does not explicitly define what \"Clear Buffer\" should do in terms of technical behavior (e.g., clearing the screen, scrollback, or both), though this can be inferred from context and the code changes. Additionally, there are no mentions of specific edge cases or constraints (e.g., behavior in different terminal profiles or with specific content in the buffer). While the issue is valid and mostly clear, these minor gaps prevent it from being comprehensive.", "difficulty_explanation": "The difficulty of this problem falls into the medium range due to several factors. First, the scope of code changes spans multiple files (ControlCore.cpp, Terminal.cpp, Terminal.hpp, PtySignalInputThread.cpp, screenInfo.cpp, screenInfo.hpp, and unit tests), indicating a need to understand interactions across different components of the Windows Terminal codebase. The changes involve replacing direct buffer clearing logic with ANSI escape sequences (e.g., \"\\x1b[H\\x1b[2J\" for screen clearing), which requires familiarity with terminal control sequences and their implications on different terminal environments (e.g., ConPTY, WSL2). \n\nSecond, the technical concepts involved include understanding terminal buffer management, ANSI escape sequence handling, and the interaction between the terminal frontend and backend (ConPTY). While these concepts are not extremely advanced, they require a moderate level of domain-specific knowledge about terminal emulation and Windows console internals. The removal of certain methods (e.g., EraseScrollback, ClearBuffer) and their replacement with sequence-based clearing suggests a shift in design approach, which adds to the complexity of ensuring compatibility and correctness.\n\nThird, the problem involves potential edge cases, such as asynchronous clearing issues with ConPTY (as noted in the code comments) and ensuring consistent behavior across different terminal profiles (e.g., Command Prompt, Ubuntu WSL2). While the problem statement does not explicitly mention edge cases, the code changes and comments hint at challenges like content visibility mismatches post-clearing, which require careful handling. However, no extensive error handling or performance optimization is evident in the changes, limiting the difficulty from reaching the higher end.\n\nFinally, the impact on the system's architecture is moderate. The changes alter how buffer clearing is handled (moving from direct API calls to escape sequences), which could affect other parts of the system relying on the old behavior, but it does not appear to be a fundamental refactoring of core components. Given these considerations, a difficulty score of 0.55 reflects the need for a solid understanding of multiple concepts, cross-file modifications, and handling of implicit edge cases, placing it in the medium difficulty range.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "Support querying the colors via OSC\n<!-- \r\n\ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8\ud83d\udea8\r\n\r\nI ACKNOWLEDGE THE FOLLOWING BEFORE PROCEEDING:\r\n1. If I delete this entire template and go my own path, the core team may close my issue without further explanation or engagement.\r\n2. If I list multiple bugs/concerns in this one issue, the core team may close my issue without further explanation or engagement.\r\n3. If I write an issue that has many duplicates, the core team may close my issue without further explanation or engagement (and without necessarily spending time to find the exact duplicate ID number).\r\n4. If I leave the title incomplete when filing the issue, the core team may close my issue without further explanation or engagement.\r\n5. If I file something completely blank in the body, the core team may close my issue without further explanation or engagement.\r\n\r\nAll good? Then proceed!\r\n-->\r\n\r\nOSC 4, 10, 11 and friends, with a `?` instead of a color, respond with the current value of that color in xterm, vte and quite a few other terminals, always using the `rgb:RRRR/GGGG/BBBB` notation, and the same terminator (ST vs. BEL) as in the query.\r\n\r\nExamples:\r\n\r\n    echo -ne '\\e]4;1;?\\e\\\\'; cat\r\n\r\n    echo -ne '\\e]11;?\\a'; cat\r\n\r\nThis allows apps (e.g. vim) to automatically pick a color scheme depending on whether the user has a dark-on-bright on bright-on-dark color scheme. I don't know if it's actually being used in practice, though :D\r\n\n", "patch": "diff --git a/.github/actions/spelling/patterns/patterns.txt b/.github/actions/spelling/patterns/patterns.txt\nindex 0089073a434..39fadfec281 100644\n--- a/.github/actions/spelling/patterns/patterns.txt\n+++ b/.github/actions/spelling/patterns/patterns.txt\n@@ -22,6 +22,7 @@ vcvars\\w*\n ROY\\sG\\.\\sBIV\n !(?:(?i)ESC)!\\[\n !(?:(?i)CSI)!(?:\\d+(?:;\\d+|)m|[ABCDF])\n+(?i)rgb:[a-z0-9]{2,4}/[a-z0-9]{2,4}/[a-z0-9]{2,4}\n \n # SSE intrinsics like \"_mm_subs_epu16\"\n \\b_mm(?:|256|512)_\\w+\\b\ndiff --git a/src/terminal/adapter/ITermDispatch.hpp b/src/terminal/adapter/ITermDispatch.hpp\nindex bf4d2cc5bd5..514c8b0c4d9 100644\n--- a/src/terminal/adapter/ITermDispatch.hpp\n+++ b/src/terminal/adapter/ITermDispatch.hpp\n@@ -76,9 +76,10 @@ class Microsoft::Console::VirtualTerminal::ITermDispatch\n     virtual bool BackwardsTab(const VTInt numTabs) = 0; // CBT\r\n     virtual bool TabClear(const DispatchTypes::TabClearType clearType) = 0; // TBC\r\n     virtual bool TabSet(const VTParameter setType) = 0; // DECST8C\r\n-    virtual bool SetColorTableEntry(const size_t tableIndex, const DWORD color) = 0; // OSCColorTable\r\n-    virtual bool SetDefaultForeground(const DWORD color) = 0; // OSCDefaultForeground\r\n-    virtual bool SetDefaultBackground(const DWORD color) = 0; // OSCDefaultBackground\r\n+    virtual bool SetColorTableEntry(const size_t tableIndex, const DWORD color) = 0; // OSCSetColorTable\r\n+    virtual bool RequestColorTableEntry(const size_t tableIndex) = 0; // OSCGetColorTable\r\n+    virtual bool SetXtermColorResource(const size_t resource, const DWORD color) = 0; // OSCSetDefaultForeground, OSCSetDefaultBackground, OSCSetCursorColor, OSCResetCursorColor\r\n+    virtual bool RequestXtermColorResource(const size_t resource) = 0; // OSCGetDefaultForeground, OSCGetDefaultBackground, OSCGetCursorColor\r\n     virtual bool AssignColor(const DispatchTypes::ColorItem item, const VTInt fgIndex, const VTInt bgIndex) = 0; // DECAC\r\n \r\n     virtual bool EraseInDisplay(const DispatchTypes::EraseType eraseType) = 0; // ED\r\n@@ -128,7 +129,6 @@ class Microsoft::Console::VirtualTerminal::ITermDispatch\n     virtual bool ScreenAlignmentPattern() = 0; // DECALN\r\n \r\n     virtual bool SetCursorStyle(const DispatchTypes::CursorStyle cursorStyle) = 0; // DECSCUSR\r\n-    virtual bool SetCursorColor(const COLORREF color) = 0; // OSCSetCursorColor, OSCResetCursorColor\r\n \r\n     virtual bool SetClipboard(wil::zwstring_view content) = 0; // OSCSetClipboard\r\n \r\ndiff --git a/src/terminal/adapter/adaptDispatch.cpp b/src/terminal/adapter/adaptDispatch.cpp\nindex 3aca2abfdf9..1c84e939ffb 100644\n--- a/src/terminal/adapter/adaptDispatch.cpp\n+++ b/src/terminal/adapter/adaptDispatch.cpp\n@@ -18,6 +18,25 @@ using namespace Microsoft::Console::VirtualTerminal;\n \n static constexpr std::wstring_view whitespace{ L\" \" };\n \n+struct XtermResourceColorTableEntry\n+{\n+    int ColorTableIndex;\n+    int AliasIndex;\n+};\n+\n+static constexpr std::array<XtermResourceColorTableEntry, 10> XtermResourceColorTableMappings{ {\n+    /* 10 */ { TextColor::DEFAULT_FOREGROUND, static_cast<int>(ColorAlias::DefaultForeground) },\n+    /* 11 */ { TextColor::DEFAULT_BACKGROUND, static_cast<int>(ColorAlias::DefaultBackground) },\n+    /* 12 */ { TextColor::CURSOR_COLOR, -1 },\n+    /* 13 */ { -1, -1 },\n+    /* 14 */ { -1, -1 },\n+    /* 15 */ { -1, -1 },\n+    /* 16 */ { -1, -1 },\n+    /* 17 */ { -1, -1 },\n+    /* 18 */ { -1, -1 },\n+    /* 19 */ { -1, -1 },\n+} };\n+\n AdaptDispatch::AdaptDispatch(ITerminalApi& api, Renderer* renderer, RenderSettings& renderSettings, TerminalInput& terminalInput) noexcept :\n     _api{ api },\n     _renderer{ renderer },\n@@ -3439,18 +3458,6 @@ bool AdaptDispatch::SetCursorStyle(const DispatchTypes::CursorStyle cursorStyle)\n     return true;\n }\n \n-// Method Description:\n-// - Sets a single entry of the colortable to a new value\n-// Arguments:\n-// - tableIndex: The VT color table index\n-// - dwColor: The new RGB color value to use.\n-// Return Value:\n-// True if handled successfully. False otherwise.\n-bool AdaptDispatch::SetCursorColor(const COLORREF cursorColor)\n-{\n-    return SetColorTableEntry(TextColor::CURSOR_COLOR, cursorColor);\n-}\n-\n // Routine Description:\n // - OSC Copy to Clipboard\n // Arguments:\n@@ -3491,28 +3498,69 @@ bool AdaptDispatch::SetColorTableEntry(const size_t tableIndex, const DWORD dwCo\n     return true;\n }\n \n+bool AdaptDispatch::RequestColorTableEntry(const size_t tableIndex)\n+{\n+    const auto color = _renderSettings.GetColorTableEntry(tableIndex);\n+    if (color != INVALID_COLOR)\n+    {\n+        const til::color c{ color };\n+        // Scale values up to match xterm's 16-bit color report format.\n+        _api.ReturnResponse(fmt::format(FMT_COMPILE(L\"\\033]4;{};rgb:{:04x}/{:04x}/{:04x}\\033\\\\\"), tableIndex, c.r * 0x0101, c.g * 0x0101, c.b * 0x0101));\n+    }\n+\n+    return true;\n+}\n+\n // Method Description:\n-// - Sets the default foreground color to a new value\n-// Arguments:\n-// - dwColor: The new RGB color value to use, as a COLORREF, format 0x00BBGGRR.\n+// - Sets one Xterm Color Resource such as Default Foreground, Background, Cursor\n // Return Value:\n // True if handled successfully. False otherwise.\n-bool AdaptDispatch::SetDefaultForeground(const DWORD dwColor)\n+bool AdaptDispatch::SetXtermColorResource(const size_t resource, const DWORD color)\n {\n-    _renderSettings.SetColorAliasIndex(ColorAlias::DefaultForeground, TextColor::DEFAULT_FOREGROUND);\n-    return SetColorTableEntry(TextColor::DEFAULT_FOREGROUND, dwColor);\n+    assert(resource >= 10);\n+    const auto mappingIndex = resource - 10;\n+    const auto& oscMapping = XtermResourceColorTableMappings.at(mappingIndex);\n+    if (oscMapping.ColorTableIndex > 0)\n+    {\n+        if (oscMapping.AliasIndex >= 0) [[unlikely]]\n+        {\n+            // If this color change applies to an aliased color, point the alias at the new color\n+            _renderSettings.SetColorAliasIndex(static_cast<ColorAlias>(oscMapping.AliasIndex), oscMapping.ColorTableIndex);\n+        }\n+        return SetColorTableEntry(oscMapping.ColorTableIndex, color);\n+    }\n+\n+    return true;\n }\n \n // Method Description:\n-// - Sets the default background color to a new value\n-// Arguments:\n-// - dwColor: The new RGB color value to use, as a COLORREF, format 0x00BBGGRR.\n+// - Reports the value of one Xterm Color Resource, if it is set.\n // Return Value:\n // True if handled successfully. False otherwise.\n-bool AdaptDispatch::SetDefaultBackground(const DWORD dwColor)\n+bool AdaptDispatch::RequestXtermColorResource(const size_t resource)\n {\n-    _renderSettings.SetColorAliasIndex(ColorAlias::DefaultBackground, TextColor::DEFAULT_BACKGROUND);\n-    return SetColorTableEntry(TextColor::DEFAULT_BACKGROUND, dwColor);\n+    assert(resource >= 10);\n+    const auto mappingIndex = resource - 10;\n+    const auto& oscMapping = XtermResourceColorTableMappings.at(mappingIndex);\n+    if (oscMapping.ColorTableIndex > 0)\n+    {\n+        size_t finalColorIndex = oscMapping.ColorTableIndex;\n+\n+        if (oscMapping.AliasIndex >= 0) [[unlikely]]\n+        {\n+            finalColorIndex = _renderSettings.GetColorAliasIndex(static_cast<ColorAlias>(oscMapping.AliasIndex));\n+        }\n+\n+        const auto color = _renderSettings.GetColorTableEntry(finalColorIndex);\n+        if (color != INVALID_COLOR)\n+        {\n+            const til::color c{ color };\n+            // Scale values up to match xterm's 16-bit color report format.\n+            _api.ReturnResponse(fmt::format(FMT_COMPILE(L\"\\033]{};rgb:{:04x}/{:04x}/{:04x}\\033\\\\\"), resource, c.r * 0x0101, c.g * 0x0101, c.b * 0x0101));\n+        }\n+    }\n+\n+    return true;\n }\n \n // Method Description:\ndiff --git a/src/terminal/adapter/adaptDispatch.hpp b/src/terminal/adapter/adaptDispatch.hpp\nindex cba0273665d..ef5636be1e2 100644\n--- a/src/terminal/adapter/adaptDispatch.hpp\n+++ b/src/terminal/adapter/adaptDispatch.hpp\n@@ -126,14 +126,14 @@ namespace Microsoft::Console::VirtualTerminal\n         bool HardReset() override; // RIS\n         bool ScreenAlignmentPattern() override; // DECALN\n         bool SetCursorStyle(const DispatchTypes::CursorStyle cursorStyle) override; // DECSCUSR\n-        bool SetCursorColor(const COLORREF cursorColor) override;\n \n         bool SetClipboard(const wil::zwstring_view content) override; // OSCSetClipboard\n \n         bool SetColorTableEntry(const size_t tableIndex,\n-                                const DWORD color) override; // OSCColorTable\n-        bool SetDefaultForeground(const DWORD color) override; // OSCDefaultForeground\n-        bool SetDefaultBackground(const DWORD color) override; // OSCDefaultBackground\n+                                const DWORD color) override; // OSCSetColorTable\n+        bool RequestColorTableEntry(const size_t tableIndex) override; // OSCGetColorTable\n+        bool SetXtermColorResource(const size_t resource, const DWORD color) override; // OSCSetDefaultForeground, OSCSetDefaultBackground, OSCSetCursorColor, OSCResetCursorColor\n+        bool RequestXtermColorResource(const size_t resource) override; // OSCGetDefaultForeground, OSCGetDefaultBackground, OSCGetCursorColor\n         bool AssignColor(const DispatchTypes::ColorItem item, const VTInt fgIndex, const VTInt bgIndex) override; // DECAC\n \n         bool WindowManipulation(const DispatchTypes::WindowManipulationType function,\ndiff --git a/src/terminal/adapter/termDispatch.hpp b/src/terminal/adapter/termDispatch.hpp\nindex 607089545bf..5d256928712 100644\n--- a/src/terminal/adapter/termDispatch.hpp\n+++ b/src/terminal/adapter/termDispatch.hpp\n@@ -69,9 +69,10 @@ class Microsoft::Console::VirtualTerminal::TermDispatch : public Microsoft::Cons\n     bool BackwardsTab(const VTInt /*numTabs*/) override { return false; } // CBT\r\n     bool TabClear(const DispatchTypes::TabClearType /*clearType*/) override { return false; } // TBC\r\n     bool TabSet(const VTParameter /*setType*/) override { return false; } // DECST8C\r\n-    bool SetColorTableEntry(const size_t /*tableIndex*/, const DWORD /*color*/) override { return false; } // OSCColorTable\r\n-    bool SetDefaultForeground(const DWORD /*color*/) override { return false; } // OSCDefaultForeground\r\n-    bool SetDefaultBackground(const DWORD /*color*/) override { return false; } // OSCDefaultBackground\r\n+    bool SetColorTableEntry(const size_t /*tableIndex*/, const DWORD /*color*/) override { return false; } // OSCSetColorTable\r\n+    bool RequestColorTableEntry(const size_t /*tableIndex*/) override { return false; } // OSCGetColorTable\r\n+    bool SetXtermColorResource(const size_t /*resource*/, const DWORD /*color*/) override { return false; } // OSCSetDefaultForeground, OSCSetDefaultBackground, OSCSetCursorColor, OSCResetCursorColor\r\n+    bool RequestXtermColorResource(const size_t /*resource*/) override { return false; } // OSCGetDefaultForeground, OSCGetDefaultBackground, OSCGetCursorColor\r\n     bool AssignColor(const DispatchTypes::ColorItem /*item*/, const VTInt /*fgIndex*/, const VTInt /*bgIndex*/) override { return false; } // DECAC\r\n \r\n     bool EraseInDisplay(const DispatchTypes::EraseType /* eraseType*/) override { return false; } // ED\r\n@@ -121,7 +122,6 @@ class Microsoft::Console::VirtualTerminal::TermDispatch : public Microsoft::Cons\n     bool ScreenAlignmentPattern() override { return false; } // DECALN\r\n \r\n     bool SetCursorStyle(const DispatchTypes::CursorStyle /*cursorStyle*/) override { return false; } // DECSCUSR\r\n-    bool SetCursorColor(const COLORREF /*color*/) override { return false; } // OSCSetCursorColor, OSCResetCursorColor\r\n \r\n     bool SetClipboard(wil::zwstring_view /*content*/) override { return false; } // OscSetClipboard\r\n \r\ndiff --git a/src/terminal/adapter/ut_adapter/adapterTest.cpp b/src/terminal/adapter/ut_adapter/adapterTest.cpp\nindex edd13ddab01..7d571086edd 100644\n--- a/src/terminal/adapter/ut_adapter/adapterTest.cpp\n+++ b/src/terminal/adapter/ut_adapter/adapterTest.cpp\n@@ -2398,6 +2398,232 @@ class AdapterTest\n         _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n     }\r\n \r\n+    TEST_METHOD(Osc4ColorPaletteReportTests)\r\n+    {\r\n+        _testGetSet->PrepData();\r\n+\r\n+        // The colors below use the same VT525 colors as the other color table report tests.\r\n+        auto& renderSettings = _testGetSet->_renderer._renderSettings;\r\n+        renderSettings.SetColorTableEntry(0, RGB(0, 0, 0));\r\n+        renderSettings.SetColorTableEntry(1, RGB(204, 36, 36));\r\n+        renderSettings.SetColorTableEntry(2, RGB(51, 204, 51));\r\n+        renderSettings.SetColorTableEntry(3, RGB(204, 204, 51));\r\n+        renderSettings.SetColorTableEntry(4, RGB(51, 51, 204));\r\n+        renderSettings.SetColorTableEntry(5, RGB(204, 51, 204));\r\n+        renderSettings.SetColorTableEntry(6, RGB(51, 204, 204));\r\n+        renderSettings.SetColorTableEntry(7, RGB(120, 120, 120));\r\n+        renderSettings.SetColorTableEntry(8, RGB(69, 69, 69));\r\n+        renderSettings.SetColorTableEntry(9, RGB(255, 0, 0));\r\n+        renderSettings.SetColorTableEntry(10, RGB(0, 255, 0));\r\n+        renderSettings.SetColorTableEntry(11, RGB(255, 255, 0));\r\n+        renderSettings.SetColorTableEntry(12, RGB(0, 0, 255));\r\n+        renderSettings.SetColorTableEntry(13, RGB(255, 0, 255));\r\n+        renderSettings.SetColorTableEntry(14, RGB(0, 255, 255));\r\n+        renderSettings.SetColorTableEntry(15, RGB(255, 255, 255));\r\n+        for (size_t i = 16; i < TextColor::TABLE_SIZE; i++)\r\n+        {\r\n+            renderSettings.SetColorTableEntry(i, RGB(0, 0, 0));\r\n+        }\r\n+\r\n+        // Dynamic color reports begin with an OSC, parameter 4, another parameter for the index, and end with ST.\r\n+        const auto OSC = L\"\\033]\";\r\n+        const auto ST = L\"\\033\\\\\";\r\n+\r\n+        _pDispatch->RequestColorTableEntry(0);\r\n+        std::wstring expectedResponse = OSC;\r\n+        expectedResponse += L\"4;0;rgb:0000/0000/0000\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(1);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;1;rgb:cccc/2424/2424\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(2);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;2;rgb:3333/cccc/3333\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(3);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;3;rgb:cccc/cccc/3333\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(4);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;4;rgb:3333/3333/cccc\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(5);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;5;rgb:cccc/3333/cccc\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(6);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;6;rgb:3333/cccc/cccc\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(7);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;7;rgb:7878/7878/7878\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(8);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;8;rgb:4545/4545/4545\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(9);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;9;rgb:ffff/0000/0000\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(10);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;10;rgb:0000/ffff/0000\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(11);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;11;rgb:ffff/ffff/0000\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(12);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;12;rgb:0000/0000/ffff\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(13);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;13;rgb:ffff/0000/ffff\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(14);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;14;rgb:0000/ffff/ffff\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        _pDispatch->RequestColorTableEntry(15);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"4;15;rgb:ffff/ffff/ffff\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+    }\r\n+\r\n+    TEST_METHOD(XtermColorResourceReportTests)\r\n+    {\r\n+        _testGetSet->PrepData();\r\n+\r\n+        // The colors below use the same VT525 colors as the other color table report tests.\r\n+        auto& renderSettings = _testGetSet->_renderer._renderSettings;\r\n+        renderSettings.SetColorTableEntry(0, RGB(0, 0, 0));\r\n+        renderSettings.SetColorTableEntry(1, RGB(204, 36, 36));\r\n+        renderSettings.SetColorTableEntry(2, RGB(51, 204, 51));\r\n+        renderSettings.SetColorTableEntry(3, RGB(204, 204, 51));\r\n+        renderSettings.SetColorTableEntry(4, RGB(51, 51, 204));\r\n+        renderSettings.SetColorTableEntry(5, RGB(204, 51, 204));\r\n+        renderSettings.SetColorTableEntry(6, RGB(51, 204, 204));\r\n+        renderSettings.SetColorTableEntry(7, RGB(120, 120, 120));\r\n+        renderSettings.SetColorTableEntry(8, RGB(69, 69, 69));\r\n+        renderSettings.SetColorTableEntry(9, RGB(255, 0, 0));\r\n+        renderSettings.SetColorTableEntry(10, RGB(0, 255, 0));\r\n+        renderSettings.SetColorTableEntry(11, RGB(255, 255, 0));\r\n+        renderSettings.SetColorTableEntry(12, RGB(0, 0, 255));\r\n+        renderSettings.SetColorTableEntry(13, RGB(255, 0, 255));\r\n+        renderSettings.SetColorTableEntry(14, RGB(0, 255, 255));\r\n+        renderSettings.SetColorTableEntry(15, RGB(255, 255, 255));\r\n+\r\n+        renderSettings.SetColorTableEntry(TextColor::DEFAULT_FOREGROUND, RGB(190, 190, 190));\r\n+        renderSettings.SetColorTableEntry(TextColor::DEFAULT_BACKGROUND, RGB(12, 12, 12));\r\n+        renderSettings.SetColorTableEntry(TextColor::CURSOR_COLOR, RGB(255, 0, 0));\r\n+\r\n+        // Dynamic color reports begin with an OSC, a parameter matching the requested value, and end with ST.\r\n+        const auto OSC = L\"\\033]\";\r\n+        const auto ST = L\"\\033\\\\\";\r\n+\r\n+        // Foreground mapped to DARK_WHITE\r\n+        _pDispatch->RequestXtermColorResource(10);\r\n+        std::wstring expectedResponse = OSC;\r\n+        expectedResponse += L\"10;rgb:7878/7878/7878\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        // Foreground mapped to independent foreground color\r\n+        renderSettings.SetColorAliasIndex(ColorAlias::DefaultForeground, TextColor::DEFAULT_FOREGROUND);\r\n+        _pDispatch->RequestXtermColorResource(10);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"10;rgb:bebe/bebe/bebe\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        // Background mapped to DARK_BLACK\r\n+        _pDispatch->RequestXtermColorResource(11);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"11;rgb:0000/0000/0000\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        // Background mapped to independent background color\r\n+        renderSettings.SetColorAliasIndex(ColorAlias::DefaultBackground, TextColor::DEFAULT_BACKGROUND);\r\n+        _pDispatch->RequestXtermColorResource(11);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"11;rgb:0c0c/0c0c/0c0c\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        // Foreground and Background mapped to different indices (e.g. via DECAC)\r\n+        {\r\n+            _testGetSet->_response.clear(); // manually clear (since we aren't issuing a call that will empty it)\r\n+            auto retentionScope = _testGetSet->EnableInputRetentionInScope();\r\n+            renderSettings.SetColorAliasIndex(ColorAlias::DefaultForeground, TextColor::DARK_RED);\r\n+            renderSettings.SetColorAliasIndex(ColorAlias::DefaultBackground, TextColor::BRIGHT_GREEN);\r\n+            _pDispatch->RequestXtermColorResource(10);\r\n+            _pDispatch->RequestXtermColorResource(11);\r\n+            expectedResponse = OSC;\r\n+            expectedResponse += L\"10;rgb:cccc/2424/2424\";\r\n+            expectedResponse += ST;\r\n+            expectedResponse += OSC;\r\n+            expectedResponse += L\"11;rgb:0000/ffff/0000\";\r\n+            expectedResponse += ST;\r\n+            _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+        }\r\n+\r\n+        _pDispatch->RequestXtermColorResource(12);\r\n+        expectedResponse = OSC;\r\n+        expectedResponse += L\"12;rgb:ffff/0000/0000\";\r\n+        expectedResponse += ST;\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        // Resource set to unrepresentable color\r\n+        _testGetSet->_response.clear(); // manually clear (since we aren't issuing a call that will empty it)\r\n+        renderSettings.SetColorTableEntry(TextColor::CURSOR_COLOR, INVALID_COLOR);\r\n+        _pDispatch->RequestXtermColorResource(12);\r\n+        expectedResponse = L\"\";\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+\r\n+        // Unsupported resource - no mapped color\r\n+        _testGetSet->_response.clear();\r\n+        _pDispatch->RequestXtermColorResource(13);\r\n+        expectedResponse = L\"\";\r\n+        _testGetSet->ValidateInputEvent(expectedResponse.c_str());\r\n+    }\r\n+\r\n     TEST_METHOD(TabulationStopReportTests)\r\n     {\r\n         _testGetSet->PrepData();\r\ndiff --git a/src/terminal/parser/InputStateMachineEngine.cpp b/src/terminal/parser/InputStateMachineEngine.cpp\nindex 645ff33a1dc..d98bfd98de2 100644\n--- a/src/terminal/parser/InputStateMachineEngine.cpp\n+++ b/src/terminal/parser/InputStateMachineEngine.cpp\n@@ -550,8 +550,19 @@ bool InputStateMachineEngine::ActionIgnore() noexcept\n // - string - OSC string we've collected. NOT null terminated.\r\n // Return Value:\r\n // - true if we handled the dispatch.\r\n-bool InputStateMachineEngine::ActionOscDispatch(const size_t /*parameter*/, const std::wstring_view /*string*/) noexcept\r\n+bool InputStateMachineEngine::ActionOscDispatch(const size_t /*parameter*/, const std::wstring_view /*string*/)\r\n {\r\n+    // Unlike ActionCsiDispatch, we are not checking whether the application has requested\r\n+    // VT input.\r\n+    // Our documentation states that VT reports generated by application requests will be\r\n+    // sent regardless of the state of `ENABLE_VIRTUAL_TERMINAL_INPUT`. We can't easily do\r\n+    // that for CSI reports because we may incidentally pass through non-response VT input;\r\n+    // however, there should be no OSC on the input stream *except* for responses.\r\n+    // It should be safe to pass all OSCs from the input stream through to the application.\r\n+    if (_pfnFlushToInputQueue)\r\n+    {\r\n+        return _pfnFlushToInputQueue();\r\n+    }\r\n     return false;\r\n }\r\n \r\ndiff --git a/src/terminal/parser/InputStateMachineEngine.hpp b/src/terminal/parser/InputStateMachineEngine.hpp\nindex 32159f6f947..a572ec41123 100644\n--- a/src/terminal/parser/InputStateMachineEngine.hpp\n+++ b/src/terminal/parser/InputStateMachineEngine.hpp\n@@ -157,7 +157,7 @@ namespace Microsoft::Console::VirtualTerminal\n \r\n         bool ActionIgnore() noexcept override;\r\n \r\n-        bool ActionOscDispatch(const size_t parameter, const std::wstring_view string) noexcept override;\r\n+        bool ActionOscDispatch(const size_t parameter, const std::wstring_view string) override;\r\n \r\n         bool ActionSs3Dispatch(const wchar_t wch, const VTParameters parameters) override;\r\n \r\ndiff --git a/src/terminal/parser/OutputStateMachineEngine.cpp b/src/terminal/parser/OutputStateMachineEngine.cpp\nindex 66c993ac06b..874f382642a 100644\n--- a/src/terminal/parser/OutputStateMachineEngine.cpp\n+++ b/src/terminal/parser/OutputStateMachineEngine.cpp\n@@ -14,6 +14,8 @@\n using namespace Microsoft::Console;\r\n using namespace Microsoft::Console::VirtualTerminal;\r\n \r\n+constexpr COLORREF COLOR_INQUIRY_COLOR = 0xfeffffff; // It's like INVALID_COLOR but special\r\n+\r\n // takes ownership of pDispatch\r\n OutputStateMachineEngine::OutputStateMachineEngine(std::unique_ptr<ITermDispatch> pDispatch) :\r\n     _dispatch(std::move(pDispatch)),\r\n@@ -788,7 +790,14 @@ bool OutputStateMachineEngine::ActionOscDispatch(const size_t parameter, const s\n         {\r\n             const auto tableIndex = til::at(tableIndexes, i);\r\n             const auto rgb = til::at(colors, i);\r\n-            success = success && _dispatch->SetColorTableEntry(tableIndex, rgb);\r\n+            if (rgb == COLOR_INQUIRY_COLOR)\r\n+            {\r\n+                success = success && _dispatch->RequestColorTableEntry(tableIndex);\r\n+            }\r\n+            else\r\n+            {\r\n+                success = success && _dispatch->SetColorTableEntry(tableIndex, rgb);\r\n+            }\r\n         }\r\n         break;\r\n     }\r\n@@ -800,40 +809,18 @@ bool OutputStateMachineEngine::ActionOscDispatch(const size_t parameter, const s\n         success = _GetOscSetColor(string, colors);\r\n         if (success)\r\n         {\r\n-            auto commandIndex = parameter;\r\n-            size_t colorIndex = 0;\r\n-\r\n-            if (commandIndex == OscActionCodes::SetForegroundColor && colors.size() > colorIndex)\r\n+            auto resource = parameter;\r\n+            for (auto&& color : colors)\r\n             {\r\n-                const auto color = til::at(colors, colorIndex);\r\n-                if (color != INVALID_COLOR)\r\n+                if (color == COLOR_INQUIRY_COLOR)\r\n                 {\r\n-                    success = success && _dispatch->SetDefaultForeground(color);\r\n+                    success = success && _dispatch->RequestXtermColorResource(resource);\r\n                 }\r\n-                commandIndex++;\r\n-                colorIndex++;\r\n-            }\r\n-\r\n-            if (commandIndex == OscActionCodes::SetBackgroundColor && colors.size() > colorIndex)\r\n-            {\r\n-                const auto color = til::at(colors, colorIndex);\r\n-                if (color != INVALID_COLOR)\r\n-                {\r\n-                    success = success && _dispatch->SetDefaultBackground(color);\r\n-                }\r\n-                commandIndex++;\r\n-                colorIndex++;\r\n-            }\r\n-\r\n-            if (commandIndex == OscActionCodes::SetCursorColor && colors.size() > colorIndex)\r\n-            {\r\n-                const auto color = til::at(colors, colorIndex);\r\n-                if (color != INVALID_COLOR)\r\n+                else if (color != INVALID_COLOR)\r\n                 {\r\n-                    success = success && _dispatch->SetCursorColor(color);\r\n+                    success = success && _dispatch->SetXtermColorResource(resource, color);\r\n                 }\r\n-                commandIndex++;\r\n-                colorIndex++;\r\n+                resource++;\r\n             }\r\n         }\r\n         break;\r\n@@ -851,7 +838,8 @@ bool OutputStateMachineEngine::ActionOscDispatch(const size_t parameter, const s\n     }\r\n     case OscActionCodes::ResetCursorColor:\r\n     {\r\n-        success = _dispatch->SetCursorColor(INVALID_COLOR);\r\n+        /* The reset codes for xterm dynamic resources are the set codes + 100 */\r\n+        success = _dispatch->SetXtermColorResource(parameter - 100u, INVALID_COLOR);\r\n         break;\r\n     }\r\n     case OscActionCodes::Hyperlink:\r\n@@ -938,6 +926,8 @@ bool OutputStateMachineEngine::_GetOscSetColorTable(const std::wstring_view stri\n                                                     std::vector<size_t>& tableIndexes,\r\n                                                     std::vector<DWORD>& rgbs) const\r\n {\r\n+    using namespace std::string_view_literals;\r\n+\r\n     const auto parts = Utils::SplitString(string, L';');\r\n     if (parts.size() < 2)\r\n     {\r\n@@ -949,13 +939,23 @@ bool OutputStateMachineEngine::_GetOscSetColorTable(const std::wstring_view stri\n \r\n     for (size_t i = 0, j = 1; j < parts.size(); i += 2, j += 2)\r\n     {\r\n+        auto&& index = til::at(parts, i);\r\n+        auto&& color = til::at(parts, j);\r\n         unsigned int tableIndex = 0;\r\n-        const auto indexSuccess = Utils::StringToUint(til::at(parts, i), tableIndex);\r\n-        const auto colorOptional = Utils::ColorFromXTermColor(til::at(parts, j));\r\n-        if (indexSuccess && colorOptional.has_value())\r\n+        const auto indexSuccess = Utils::StringToUint(index, tableIndex);\r\n+\r\n+        if (indexSuccess)\r\n         {\r\n-            newTableIndexes.push_back(tableIndex);\r\n-            newRgbs.push_back(colorOptional.value());\r\n+            if (color == L\"?\"sv) [[unlikely]]\r\n+            {\r\n+                newTableIndexes.push_back(tableIndex);\r\n+                newRgbs.push_back(COLOR_INQUIRY_COLOR);\r\n+            }\r\n+            else if (const auto colorOptional = Utils::ColorFromXTermColor(color))\r\n+            {\r\n+                newTableIndexes.push_back(tableIndex);\r\n+                newRgbs.push_back(colorOptional.value());\r\n+            }\r\n         }\r\n     }\r\n \r\n@@ -1032,6 +1032,8 @@ bool OutputStateMachineEngine::_ParseHyperlink(const std::wstring_view string,\n bool OutputStateMachineEngine::_GetOscSetColor(const std::wstring_view string,\r\n                                                std::vector<DWORD>& rgbs) const\r\n {\r\n+    using namespace std::string_view_literals;\r\n+\r\n     const auto parts = Utils::SplitString(string, L';');\r\n     if (parts.size() < 1)\r\n     {\r\n@@ -1039,10 +1041,14 @@ bool OutputStateMachineEngine::_GetOscSetColor(const std::wstring_view string,\n     }\r\n \r\n     std::vector<DWORD> newRgbs;\r\n-    for (size_t i = 0; i < parts.size(); i++)\r\n+    for (auto&& part : parts)\r\n     {\r\n-        const auto colorOptional = Utils::ColorFromXTermColor(til::at(parts, i));\r\n-        if (colorOptional.has_value())\r\n+        if (part == L\"?\"sv) [[unlikely]]\r\n+        {\r\n+            newRgbs.push_back(COLOR_INQUIRY_COLOR);\r\n+            continue;\r\n+        }\r\n+        else if (const auto colorOptional = Utils::ColorFromXTermColor(part))\r\n         {\r\n             newRgbs.push_back(colorOptional.value());\r\n         }\r\ndiff --git a/src/terminal/parser/ut_parser/OutputEngineTest.cpp b/src/terminal/parser/ut_parser/OutputEngineTest.cpp\nindex f19ad423fbc..8a5015e25cb 100644\n--- a/src/terminal/parser/ut_parser/OutputEngineTest.cpp\n+++ b/src/terminal/parser/ut_parser/OutputEngineTest.cpp\n@@ -1158,12 +1158,8 @@ class StatefulDispatch final : public TermDispatch\n         _numTabs{ 0 },\n         _tabClear{ false },\n         _tabClearTypes{},\n-        _setDefaultForeground(false),\n-        _defaultForegroundColor{ RGB(0, 0, 0) },\n-        _setDefaultBackground(false),\n-        _defaultBackgroundColor{ RGB(0, 0, 0) },\n-        _setDefaultCursorColor(false),\n-        _defaultCursorColor{ RGB(0, 0, 0) },\n+        _xtermResourcesChanged{},\n+        _xtermResourceValues{},\n         _hyperlinkMode{ false },\n         _options{ s_cMaxOptions, static_cast<DispatchTypes::GraphicsOptions>(s_uiGraphicsCleared) }, // fill with cleared option\n         _colorTable{},\n@@ -1432,24 +1428,22 @@ class StatefulDispatch final : public TermDispatch\n         return true;\n     }\n \n-    bool SetDefaultForeground(const DWORD color) noexcept override\n+    bool RequestColorTableEntry(const size_t tableIndex) noexcept override\n     {\n-        _setDefaultForeground = true;\n-        _defaultForegroundColor = color;\n+        _colorTableEntriesRequested.push_back(tableIndex);\n         return true;\n     }\n \n-    bool SetDefaultBackground(const DWORD color) noexcept override\n+    bool SetXtermColorResource(const size_t resource, const DWORD color) override\n     {\n-        _setDefaultBackground = true;\n-        _defaultBackgroundColor = color;\n+        _xtermResourcesChanged.push_back(resource);\n+        _xtermResourceValues.push_back(color);\n         return true;\n     }\n \n-    bool SetCursorColor(const DWORD color) noexcept override\n+    bool RequestXtermColorResource(const size_t resource) override\n     {\n-        _setDefaultCursorColor = true;\n-        _defaultCursorColor = color;\n+        _xtermResourcesRequested.push_back(resource);\n         return true;\n     }\n \n@@ -1529,13 +1523,11 @@ class StatefulDispatch final : public TermDispatch\n     size_t _numTabs;\n     bool _tabClear;\n     std::vector<DispatchTypes::TabClearType> _tabClearTypes;\n-    bool _setDefaultForeground;\n-    DWORD _defaultForegroundColor;\n-    bool _setDefaultBackground;\n-    DWORD _defaultBackgroundColor;\n-    bool _setDefaultCursorColor;\n-    DWORD _defaultCursorColor;\n+    std::vector<size_t> _xtermResourcesChanged;\n+    std::vector<DWORD> _xtermResourceValues;\n+    std::vector<size_t> _xtermResourcesRequested;\n     bool _setColorTableEntry;\n+    std::vector<size_t> _colorTableEntriesRequested;\n     bool _hyperlinkMode;\n     std::wstring _copyContent;\n     std::wstring _uri;\n@@ -2822,105 +2814,114 @@ class StateMachineExternalTest final\n \n         // Single param\n         mach.ProcessString(L\"\\033]10;rgb:1/1/1\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);\n-        VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_defaultForegroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]10;rgb:12/34/56\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);\n-        VERIFY_ARE_EQUAL(RGB(0x12, 0x34, 0x56), pDispatch->_defaultForegroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x12, 0x34, 0x56), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]10;#111\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]10;#123456\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);\n-        VERIFY_ARE_EQUAL(RGB(0x12, 0x34, 0x56), pDispatch->_defaultForegroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x12, 0x34, 0x56), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]10;DarkOrange\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);\n-        VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_defaultForegroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         // Multiple params\n         mach.ProcessString(L\"\\033]10;#111;rgb:2/2/2\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_defaultBackgroundColor);\n+        VERIFY_ARE_EQUAL(2u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[1]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_xtermResourceValues[1]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]10;#111;DarkOrange\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_defaultBackgroundColor);\n+        VERIFY_ARE_EQUAL(2u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[1]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n+        VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_xtermResourceValues[1]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]10;#111;DarkOrange;rgb:2/2/2\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_defaultBackgroundColor);\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultCursorColor);\n-        VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_defaultCursorColor);\n+        VERIFY_ARE_EQUAL(3u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[1]);\n+        VERIFY_ARE_EQUAL(12u, pDispatch->_xtermResourcesChanged[2]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n+        VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_xtermResourceValues[1]);\n+        VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_xtermResourceValues[2]);\n \n         pDispatch->ClearState();\n \n         // Partially valid multi-param sequences.\n         mach.ProcessString(L\"\\033]10;#111;\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]10;#111;rgb:\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);\n-        VERIFY_IS_FALSE(pDispatch->_setDefaultBackground);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]10;#111;#2\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultForeground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultForegroundColor);\n-        VERIFY_IS_FALSE(pDispatch->_setDefaultBackground);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]10;;rgb:1/1/1\\033\\\\\");\n-        VERIFY_IS_FALSE(pDispatch->_setDefaultForeground);\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_defaultBackgroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]10;#1;rgb:1/1/1\\033\\\\\");\n-        VERIFY_IS_FALSE(pDispatch->_setDefaultForeground);\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_defaultBackgroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         // Invalid sequences.\n         mach.ProcessString(L\"\\033]10;rgb:1/1/\\033\\\\\");\n-        VERIFY_IS_FALSE(pDispatch->_setDefaultForeground);\n+        VERIFY_ARE_EQUAL(0u, pDispatch->_xtermResourcesChanged.size());\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]10;#1\\033\\\\\");\n-        VERIFY_IS_FALSE(pDispatch->_setDefaultForeground);\n+        VERIFY_ARE_EQUAL(0u, pDispatch->_xtermResourcesChanged.size());\n \n         pDispatch->ClearState();\n     }\n@@ -2933,100 +2934,115 @@ class StateMachineExternalTest final\n         StateMachine mach(std::move(engine));\n \n         mach.ProcessString(L\"\\033]11;rgb:1/1/1\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_defaultBackgroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         // Single param\n         mach.ProcessString(L\"\\033]11;rgb:12/34/56\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x12, 0x34, 0x56), pDispatch->_defaultBackgroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x12, 0x34, 0x56), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]11;#111\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]11;#123456\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x12, 0x34, 0x56), pDispatch->_defaultBackgroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x12, 0x34, 0x56), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]11;DarkOrange\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_defaultBackgroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         // Multiple params\n         mach.ProcessString(L\"\\033]11;#111;rgb:2/2/2\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);\n-        VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_defaultCursorColor);\n+        VERIFY_ARE_EQUAL(2u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(12u, pDispatch->_xtermResourcesChanged[1]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x22, 0x22, 0x22), pDispatch->_xtermResourceValues[1]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]11;#111;DarkOrange\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);\n-        VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_defaultCursorColor);\n+        VERIFY_ARE_EQUAL(2u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(12u, pDispatch->_xtermResourcesChanged[1]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n+        VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_xtermResourceValues[1]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]11;#111;DarkOrange;rgb:2/2/2\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);\n-        VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_defaultCursorColor);\n-        // The third param is out of range.\n+        VERIFY_ARE_EQUAL(3u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(12u, pDispatch->_xtermResourcesChanged[1]);\n+        VERIFY_ARE_EQUAL(13u, pDispatch->_xtermResourcesChanged[2]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n+        VERIFY_ARE_EQUAL(RGB(255, 140, 0), pDispatch->_xtermResourceValues[1]);\n+        // The third param is out of range, but it's technically still in compliance to set it\n \n         pDispatch->ClearState();\n \n         // Partially valid multi-param sequences.\n         mach.ProcessString(L\"\\033]11;#111;\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]11;#111;rgb:\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]11;#111;#2\\033\\\\\");\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultBackground);\n-        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_defaultBackgroundColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x10, 0x10, 0x10), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]11;;rgb:1/1/1\\033\\\\\");\n-        VERIFY_IS_FALSE(pDispatch->_setDefaultBackground);\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultCursorColor);\n-        VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_defaultCursorColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(12u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]11;#1;rgb:1/1/1\\033\\\\\");\n-        VERIFY_IS_FALSE(pDispatch->_setDefaultBackground);\n-        VERIFY_IS_TRUE(pDispatch->_setDefaultCursorColor);\n-        VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_defaultCursorColor);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(12u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x11, 0x11, 0x11), pDispatch->_xtermResourceValues[0]);\n \n         pDispatch->ClearState();\n \n         // Invalid sequences.\n         mach.ProcessString(L\"\\033]11;rgb:1/1/\\033\\\\\");\n-        VERIFY_IS_FALSE(pDispatch->_setDefaultBackground);\n+        VERIFY_ARE_EQUAL(0u, pDispatch->_xtermResourcesChanged.size());\n \n         pDispatch->ClearState();\n \n         mach.ProcessString(L\"\\033]11;#1\\033\\\\\");\n-        VERIFY_IS_FALSE(pDispatch->_setDefaultBackground);\n+        VERIFY_ARE_EQUAL(0u, pDispatch->_xtermResourcesChanged.size());\n \n         pDispatch->ClearState();\n     }\n@@ -3178,6 +3194,88 @@ class StateMachineExternalTest final\n         pDispatch->ClearState();\n     }\n \n+    TEST_METHOD(TestOscGetColorTableEntry)\n+    {\n+        auto dispatch = std::make_unique<StatefulDispatch>();\n+        auto pDispatch = dispatch.get();\n+        auto engine = std::make_unique<OutputStateMachineEngine>(std::move(dispatch));\n+        StateMachine mach(std::move(engine));\n+\n+        mach.ProcessString(L\"\\033]4;0;?;1;?;2;;3;?;4;?\\033\\\\\"); // Inquire about 0-4 skipping 2\n+        VERIFY_ARE_EQUAL((std::vector<size_t>{ 0u, 1u, 3u, 4u }), pDispatch->_colorTableEntriesRequested);\n+        pDispatch->ClearState();\n+\n+        mach.ProcessString(L\"\\033]4;0;rgb:00/00/00;1;rgb:00/00/01;2;?;3;rgb:00/00/03;4;rgb:00/00/04\\033\\\\\"); // Set 0-4, except 2 (inquire)\n+        VERIFY_ARE_EQUAL(RGB(0, 0, 0), pDispatch->_colorTable.at(0));\n+        VERIFY_ARE_EQUAL(RGB(0, 0, 1), pDispatch->_colorTable.at(1));\n+        VERIFY_ARE_EQUAL(RGB(0, 0, 3), pDispatch->_colorTable.at(3));\n+        VERIFY_ARE_EQUAL(RGB(0, 0, 4), pDispatch->_colorTable.at(4));\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_colorTableEntriesRequested.size()); // note: (1u, 2u) constructs a 1-length vector containing 2\n+        VERIFY_ARE_EQUAL(2u, pDispatch->_colorTableEntriesRequested[0]);\n+        pDispatch->ClearState();\n+\n+        pDispatch->_colorTable.at(3) = RGB(0xfe, 0xed, 0xfa);\n+        mach.ProcessString(L\"\\033]4;0;rgb:f0/00/00;1;?;3\\033\\\\\"); // Set 0, inquire 1, truncated 3\n+        VERIFY_ARE_EQUAL(RGB(0xf0, 0, 0), pDispatch->_colorTable.at(0));\n+        VERIFY_ARE_EQUAL(RGB(0xfe, 0xed, 0xfa), pDispatch->_colorTable.at(3)); // unchanged from before ProcessString\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_colorTableEntriesRequested.size()); // note: (1u, 2u) constructs a 1-length vector containing 2\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_colorTableEntriesRequested[0]);\n+        pDispatch->ClearState();\n+    }\n+\n+    TEST_METHOD(TestOscXtermResourceReport)\n+    {\n+        auto dispatch = std::make_unique<StatefulDispatch>();\n+        auto pDispatch = dispatch.get();\n+        auto engine = std::make_unique<OutputStateMachineEngine>(std::move(dispatch));\n+        StateMachine mach(std::move(engine));\n+\n+        mach.ProcessString(L\"\\033]10;?\\033\\\\\");\n+        VERIFY_ARE_EQUAL(0u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesRequested.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesRequested[0]);\n+        pDispatch->ClearState();\n+\n+        // Two params, skip first\n+        mach.ProcessString(L\"\\033]10;;?\\033\\\\\");\n+        VERIFY_ARE_EQUAL(0u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesRequested.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesRequested[0]);\n+        pDispatch->ClearState();\n+\n+        // Two params, set first\n+        mach.ProcessString(L\"\\033]10;rgb:11/22/33;?\\033\\\\\");\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(10u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x11, 0x22, 0x33), pDispatch->_xtermResourceValues[0]);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesRequested.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesRequested[0]);\n+        pDispatch->ClearState();\n+\n+        // Two params, set first, starting at 12\n+        mach.ProcessString(L\"\\033]12;rgb:11/22/33;?\\033\\\\\");\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(12u, pDispatch->_xtermResourcesChanged[0]);\n+        VERIFY_ARE_EQUAL(RGB(0x11, 0x22, 0x33), pDispatch->_xtermResourceValues[0]);\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesRequested.size());\n+        VERIFY_ARE_EQUAL(13u, pDispatch->_xtermResourcesRequested[0]);\n+        pDispatch->ClearState();\n+\n+        // Request all 10\n+        mach.ProcessString(L\"\\033]10;?;?;?;?;?;?;?;?;?;?\\033\\\\\");\n+        VERIFY_ARE_EQUAL(0u, pDispatch->_xtermResourcesChanged.size());\n+        std::vector<size_t> expected{ 10u, 11u, 12u, 13u, 14u, 15u, 16u, 17u, 18u, 19u };\n+        VERIFY_ARE_EQUAL(expected, pDispatch->_xtermResourcesRequested);\n+        pDispatch->ClearState();\n+\n+        // Request out of range\n+        mach.ProcessString(L\"\\033]10;;?\\033\\\\\");\n+        VERIFY_ARE_EQUAL(0u, pDispatch->_xtermResourcesChanged.size());\n+        VERIFY_ARE_EQUAL(1u, pDispatch->_xtermResourcesRequested.size());\n+        VERIFY_ARE_EQUAL(11u, pDispatch->_xtermResourcesRequested[0]);\n+        pDispatch->ClearState();\n+    }\n+\n     TEST_METHOD(TestOscSetWindowTitle)\n     {\n         BEGIN_TEST_METHOD_PROPERTIES()\n", "instance_id": "microsoft__terminal-17729", "clarity": 2, "difficulty": 0.55, "clarity_explanation": "The problem statement is mostly clear in its intent to support querying colors via OSC (Operating System Command) sequences in a terminal emulator, with examples provided for querying color values. It specifies the expected format of responses (rgb:RRRR/GGGG/BBBB notation) and mentions compatibility with xterm and other terminals. However, there are minor ambiguities and missing details. For instance, it does not explicitly define the full range of OSC commands to be supported beyond the examples (e.g., OSC 4, 10, 11), nor does it clarify the expected behavior for invalid or unsupported queries. Additionally, edge cases such as handling of invalid color indices or malformed input are not addressed. While the goal is understandable, these gaps prevent it from being fully comprehensive.", "difficulty_explanation": "The difficulty of this problem falls in the medium range due to several factors. First, the scope of code changes is significant, spanning multiple files (e.g., adapter, parser, and test files) and requiring modifications to existing interfaces and logic for handling OSC sequences. This involves understanding and updating the terminal's color management system and dispatch mechanisms, which indicates a need for familiarity with the codebase's architecture. Second, the technical concepts involved include parsing OSC sequences, managing color tables, and handling color aliasing, which require a moderate understanding of terminal emulation protocols and C++ programming nuances (e.g., working with COLORREF, string formatting for responses). Third, the changes impact how color queries are processed and returned, necessitating careful handling of edge cases like invalid indices or unrepresentable colors, as seen in the test cases. While not overly complex, the problem requires integrating new functionality into an existing system with attention to detail across multiple components, justifying a score of 0.55. It is not hard enough to warrant a higher score, as it does not involve deep architectural refactoring or advanced algorithms, but it is beyond a simple bug fix or feature addition due to the cross-file impact and conceptual depth.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "Cursor invalidation failing when line renditions are used\n### Windows Terminal version\n\n1.21.1272.0\n\n### Windows build number\n\n10.0.19045.4291\n\n### Other Software\n\n_No response_\n\n### Steps to reproduce\n\n1. Open a WSL bash shell\r\n2. Execute the following statement:\r\n   ```\r\n   printf \"\\ec\\e[999B\\n\\e[H\\e#6\\n\\e[1 q\"; read\r\n   ```\r\n3. Type some text and note whether the cursor is blinking.\r\n4. Backspace to the start of the line and check the cursor again.\r\n\n\n### Expected Behavior\n\nThe final escape sequence in that `printf` is a `DECSCUSR` command, setting the cursor style to a blinking block, so it should be blinking the whole time (except maybe when it's actually moving).\n\n### Actual Behavior\n\nThe cursor blinks at the start of the line, but doesn't blink in any other column. The issue isn't specifically related to blinking, though. It can also manifest as almost constant cursor \"droppings\", but this test case was the easiest to reproduce.\r\n\r\nAnd note that it also fails on openconsole/conhost if you've configured it to use the Atlas engine, so it's not a conpty issue, but it appears to be Atlas only.\r\n\r\nLine rendition has got something to do with it - the first line is set to double-width in this test - but it's not only the double-width line that is affected. And I think the scroll offset is also a factor, which is why this test case forces a linefeed at the bottom of the page.\r\n\r\nAs far as I can tell from a git bisect, it first broke in commit 20b0bed46df71c596b4fb68edfb6bb4b4ebf1c89 (PR #15500).\r\n\n", "patch": "diff --git a/src/renderer/base/renderer.cpp b/src/renderer/base/renderer.cpp\nindex 91e5772006e..c8ed8b28e7b 100644\n--- a/src/renderer/base/renderer.cpp\n+++ b/src/renderer/base/renderer.cpp\n@@ -1178,8 +1178,8 @@ void Renderer::_invalidateCurrentCursor() const\n     const auto view = buffer.GetSize();\r\n     const auto coord = _currentCursorOptions.coordCursor;\r\n \r\n-    const auto lineRendition = buffer.GetLineRendition(coord.y);\r\n-    const auto cursorWidth = _pData->IsCursorDoubleWidth() ? 2 : 1;\r\n+    const auto lineRendition = _currentCursorOptions.lineRendition;\r\n+    const auto cursorWidth = _currentCursorOptions.fIsDoubleWidth ? 2 : 1;\r\n \r\n     til::rect rect{ coord.x, coord.y, coord.x + cursorWidth, coord.y + 1 };\r\n     rect = BufferToScreenLine(rect, lineRendition);\r\n", "instance_id": "microsoft__terminal-17234", "clarity": 2, "difficulty": 0.45, "clarity_explanation": "The problem statement is mostly clear in describing the issue of cursor invalidation failing when line renditions are used in Windows Terminal. It provides specific steps to reproduce the issue, including a test command, and clearly states the expected and actual behavior of the cursor. Additionally, it identifies relevant factors such as line rendition (double-width lines) and scroll offset, and even points to a specific commit where the issue was introduced. However, there are minor ambiguities and missing details that prevent it from being comprehensive. For instance, the problem statement does not explicitly define what \"cursor droppings\" means in a technical context, and it lacks detailed information on the expected behavior across different terminal configurations or edge cases beyond the provided test case. While the issue is tied to the Atlas engine, there is no deeper explanation of why or how line rendition and scroll offset interact to cause the problem, which could be critical for a complete understanding.", "difficulty_explanation": "The difficulty of this problem falls into the medium range due to several factors. First, the scope of the code change is relatively small, as it involves a targeted modification in a single file (`renderer.cpp`) with just a couple of lines changed to use cursor-specific options for line rendition and width instead of buffer data. This suggests a focused fix rather than a broad architectural change. However, understanding the issue requires knowledge of terminal rendering logic, specifically how cursor positioning and line renditions (like double-width lines) interact within the Windows Terminal's rendering engine (Atlas). It also demands familiarity with the codebase's internal data structures (e.g., `_currentCursorOptions`) and how they relate to the buffer state. While the change itself is simple, identifying the root cause likely involved debugging complex interactions between cursor state, line rendition, and screen coordinates, as hinted by the git bisect reference in the problem statement. There are no explicit edge cases mentioned beyond the test case, but the nature of terminal rendering implies potential challenges with different cursor styles, terminal sizes, or line rendition modes that might need consideration. Overall, this problem requires a moderate depth of understanding of the rendering subsystem but does not appear to impact the broader architecture or necessitate advanced domain-specific knowledge beyond terminal emulation, placing it at the lower end of medium difficulty.", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "Copy with Control Sequences\n# Description of the new feature/enhancement\r\nOption to copy text from the terminal with ANSI sequences. Useful when you need to copy styled output to another file like a markdown codefence with ansi-support (ex. https://github.com/expressive-code/expressive-code/pull/29)\r\n\r\nSee similar option in [iTerm2](https://iterm2.com/documentation-menu-items.html): Edit > Copy with Control Sequences\r\n\r\n# Proposed technical implementation details (optional)\r\n\r\nA new \"Copy with Control Sequences\" command that includes escape sequences in the copied text. Either include original ANSI-sequences if possible or recreate (best-effort) like iTerm2.\n", "patch": "diff --git a/doc/cascadia/profiles.schema.json b/doc/cascadia/profiles.schema.json\nindex ec903dc5b80..478c75129b4 100644\n--- a/doc/cascadia/profiles.schema.json\n+++ b/doc/cascadia/profiles.schema.json\n@@ -879,6 +879,11 @@\n               \"default\": false,\n               \"description\": \"If true, the copied content will be copied as a single line (even if there are hard line breaks present in the text). If false, newlines persist from the selected text.\"\n             },\n+            \"withControlSequences\": {\n+              \"type\": \"boolean\",\n+              \"default\": false,\n+              \"description\": \"If true, copied content will contain ANSI escape code control sequences representing the styling of the content.\"\n+            },\n             \"dismissSelection\": {\n               \"type\": \"boolean\",\n               \"default\": true,\ndiff --git a/src/buffer/out/textBuffer.cpp b/src/buffer/out/textBuffer.cpp\nindex 802e48e7c3e..a920854b732 100644\n--- a/src/buffer/out/textBuffer.cpp\n+++ b/src/buffer/out/textBuffer.cpp\n@@ -1917,6 +1917,41 @@ std::wstring TextBuffer::GetPlainText(const CopyRequest& req) const\n     return selectedText;\r\n }\r\n \r\n+// Retrieves the text data from the buffer *with* ANSI escape code control sequences and presents it in\r\n+//      a clipboard-ready format.\r\n+// Arguments:\r\n+// - req - the copy request having the bounds of the selected region and other related configuration flags.\r\n+// Return Value:\r\n+// - The text and control sequence data from the selected region of the text buffer. Empty if the copy request\r\n+//      is invalid.\r\n+std::wstring TextBuffer::GetWithControlSequences(const CopyRequest& req) const\r\n+{\r\n+    if (req.beg > req.end)\r\n+    {\r\n+        return {};\r\n+    }\r\n+\r\n+    std::wstring selectedText;\r\n+    std::optional<TextAttribute> previousTextAttr;\r\n+    bool delayedLineBreak = false;\r\n+\r\n+    const auto firstRow = req.beg.y;\r\n+    const auto lastRow = req.end.y;\r\n+\r\n+    for (til::CoordType currentRow = firstRow; currentRow <= lastRow; currentRow++)\r\n+    {\r\n+        const auto& row = GetRowByOffset(currentRow);\r\n+\r\n+        const auto [startX, endX, reqAddLineBreak] = _RowCopyHelper(req, currentRow, row);\r\n+        const bool isLastRow = currentRow == lastRow;\r\n+        const bool addLineBreak = reqAddLineBreak && !isLastRow;\r\n+\r\n+        _SerializeRow(row, startX, endX, addLineBreak, isLastRow, selectedText, previousTextAttr, delayedLineBreak);\r\n+    }\r\n+\r\n+    return selectedText;\r\n+}\r\n+\r\n // Routine Description:\r\n // - Generates a CF_HTML compliant structure from the selected region of the buffer\r\n // Arguments:\r\n@@ -2348,7 +2383,7 @@ void TextBuffer::_AppendRTFText(std::string& contentBuilder, const std::wstring_\n     }\r\n }\r\n \r\n-void TextBuffer::Serialize(const wchar_t* destination) const\r\n+void TextBuffer::SerializeToPath(const wchar_t* destination) const\r\n {\r\n     const wil::unique_handle file{ CreateFileW(destination, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_DELETE, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr) };\r\n     THROW_LAST_ERROR_IF(!file);\r\n@@ -2358,279 +2393,318 @@ void TextBuffer::Serialize(const wchar_t* destination) const\n     buffer.reserve(writeThreshold + writeThreshold / 2);\r\n     buffer.push_back(L'\\uFEFF');\r\n \r\n-    const til::CoordType lastRowWithText = GetLastNonSpaceCharacter(nullptr).y;\r\n-    CharacterAttributes previousAttr = CharacterAttributes::Unused1;\r\n-    TextColor previousFg;\r\n-    TextColor previousBg;\r\n-    TextColor previousUl;\r\n-    uint16_t previousHyperlinkId = 0;\r\n+    std::optional<TextAttribute> previousTextAttr;\r\n     bool delayedLineBreak = false;\r\n \r\n+    const til::CoordType firstRow = 0;\r\n+    const til::CoordType lastRow = GetLastNonSpaceCharacter(nullptr).y;\r\n+\r\n     // This iterates through each row. The exit condition is at the end\r\n     // of the for() loop so that we can properly handle file flushing.\r\n-    for (til::CoordType currentRow = 0;; currentRow++)\r\n+    for (til::CoordType currentRow = firstRow;; currentRow++)\r\n     {\r\n         const auto& row = GetRowByOffset(currentRow);\r\n \r\n-        if (const auto lr = row.GetLineRendition(); lr != LineRendition::SingleWidth)\r\n+        const auto isLastRow = currentRow == lastRow;\r\n+        const auto startX = 0;\r\n+        const auto endX = row.GetReadableColumnCount();\r\n+        const bool addLineBreak = !row.WasWrapForced() || isLastRow;\r\n+\r\n+        _SerializeRow(row, startX, endX, addLineBreak, isLastRow, buffer, previousTextAttr, delayedLineBreak);\r\n+\r\n+        if (buffer.size() >= writeThreshold || isLastRow)\r\n         {\r\n-            static constexpr std::wstring_view mappings[] = {\r\n-                L\"\\x1b#6\", // LineRendition::DoubleWidth\r\n-                L\"\\x1b#3\", // LineRendition::DoubleHeightTop\r\n-                L\"\\x1b#4\", // LineRendition::DoubleHeightBottom\r\n-            };\r\n-            const auto idx = std::clamp(static_cast<int>(lr) - 1, 0, 2);\r\n-            buffer.append(til::at(mappings, idx));\r\n+            const auto fileSize = gsl::narrow<DWORD>(buffer.size() * sizeof(wchar_t));\r\n+            DWORD bytesWritten = 0;\r\n+            THROW_IF_WIN32_BOOL_FALSE(WriteFile(file.get(), buffer.data(), fileSize, &bytesWritten, nullptr));\r\n+            THROW_WIN32_IF_MSG(ERROR_WRITE_FAULT, bytesWritten != fileSize, \"failed to write\");\r\n+            buffer.clear();\r\n         }\r\n \r\n-        const auto& runs = row.Attributes().runs();\r\n-        const auto beg = runs.begin();\r\n-        const auto end = runs.end();\r\n-        auto it = beg;\r\n-        const auto last = end - 1;\r\n-        const auto lastCharX = row.MeasureRight();\r\n-        til::CoordType oldX = 0;\r\n-\r\n-        for (; it != end; ++it)\r\n+        if (isLastRow)\r\n         {\r\n-            const auto attr = it->value.GetCharacterAttributes();\r\n-            const auto hyperlinkId = it->value.GetHyperlinkId();\r\n-            const auto fg = it->value.GetForeground();\r\n-            const auto bg = it->value.GetBackground();\r\n-            const auto ul = it->value.GetUnderlineColor();\r\n+            break;\r\n+        }\r\n+    }\r\n+}\r\n \r\n-            if (previousAttr != attr)\r\n-            {\r\n-                auto attrDelta = attr ^ previousAttr;\r\n-\r\n-                // There's no escape sequence that only turns off either bold/intense or dim/faint. SGR 22 turns off both.\r\n-                // This results in two issues in our generic \"Mapping\" code below. Assuming, both Intense and Faint were on...\r\n-                // * ...and either turned off, it would emit SGR 22 which turns both attributes off = Wrong.\r\n-                // * ...and both are now off, it would emit SGR 22 twice.\r\n-                //\r\n-                // This extra branch takes care of both issues. If both attributes turned off it'll emit a single \\x1b[22m,\r\n-                // if faint turned off \\x1b[22;1m (intense is still on), and \\x1b[22;2m if intense turned off (vice versa).\r\n-                if (WI_AreAllFlagsSet(previousAttr, CharacterAttributes::Intense | CharacterAttributes::Faint) &&\r\n-                    WI_IsAnyFlagSet(attrDelta, CharacterAttributes::Intense | CharacterAttributes::Faint))\r\n-                {\r\n-                    wchar_t buf[8] = L\"\\x1b[22m\";\r\n-                    size_t len = 5;\r\n+// Serializes one row of the text buffer including ANSI escape code control sequences.\r\n+// Arguments:\r\n+// - row - A reference to the row being serialized.\r\n+// - startX - The first column (inclusive) to include in the serialized content.\r\n+// - endX - The last column (exclusive) to include in the serialized content.\r\n+// - addLineBreak - Whether to add a line break at the end of the serialized row.\r\n+// - isLastRow - Whether this is the final row to be serialized.\r\n+// - buffer - A string to write the serialized row into.\r\n+// - previousTextAttr - Used for tracking state across multiple calls to `_SerializeRow` for sequential rows.\r\n+//      The value will be mutated by the call. The initial call should contain `nullopt`, and subsequent calls\r\n+//      should pass the value that was written by the previous call.\r\n+// - delayedLineBreak - Similarly used for tracking state across multiple calls, and similarly will be mutated\r\n+//      by the call. The initial call should pass `false` and subsequent calls should pass the value that was\r\n+//      written by the previous call.\r\n+void TextBuffer::_SerializeRow(const ROW& row, const til::CoordType startX, const til::CoordType endX, const bool addLineBreak, const bool isLastRow, std::wstring& buffer, std::optional<TextAttribute>& previousTextAttr, bool& delayedLineBreak) const\r\n+{\r\n+    if (const auto lr = row.GetLineRendition(); lr != LineRendition::SingleWidth)\r\n+    {\r\n+        static constexpr std::wstring_view mappings[] = {\r\n+            L\"\\x1b#6\", // LineRendition::DoubleWidth\r\n+            L\"\\x1b#3\", // LineRendition::DoubleHeightTop\r\n+            L\"\\x1b#4\", // LineRendition::DoubleHeightBottom\r\n+        };\r\n+        const auto idx = std::clamp(static_cast<int>(lr) - 1, 0, 2);\r\n+        buffer.append(til::at(mappings, idx));\r\n+    }\r\n \r\n-                    if (WI_IsAnyFlagSet(attr, CharacterAttributes::Intense | CharacterAttributes::Faint))\r\n-                    {\r\n-                        buf[4] = L';';\r\n-                        buf[5] = WI_IsAnyFlagSet(attr, CharacterAttributes::Intense) ? L'1' : L'2';\r\n-                        buf[6] = L'm';\r\n-                        len = 7;\r\n-                    }\r\n+    const auto startXU16 = gsl::narrow_cast<uint16_t>(startX);\r\n+    const auto endXU16 = gsl::narrow_cast<uint16_t>(endX);\r\n+    const auto runs = row.Attributes().slice(startXU16, endXU16).runs();\r\n \r\n-                    buffer.append(&buf[0], len);\r\n-                    WI_ClearAllFlags(attrDelta, CharacterAttributes::Intense | CharacterAttributes::Faint);\r\n-                }\r\n+    const auto beg = runs.begin();\r\n+    const auto end = runs.end();\r\n+    auto it = beg;\r\n+    // Don't try to get `end - 1` if it's an empty iterator; in this case we're going to ignore the `last`\r\n+    // value anyway so just use `end`.\r\n+    const auto last = it == end ? end : end - 1;\r\n+    const auto lastCharX = row.MeasureRight();\r\n+    til::CoordType oldX = startX;\r\n+\r\n+    for (; it != end; ++it)\r\n+    {\r\n+        const auto effectivePreviousTextAttr = previousTextAttr.value_or(TextAttribute{ CharacterAttributes::Unused1, TextColor{}, TextColor{}, 0, TextColor{} });\r\n+        const auto previousAttr = effectivePreviousTextAttr.GetCharacterAttributes();\r\n+        const auto previousHyperlinkId = effectivePreviousTextAttr.GetHyperlinkId();\r\n+        const auto previousFg = effectivePreviousTextAttr.GetForeground();\r\n+        const auto previousBg = effectivePreviousTextAttr.GetBackground();\r\n+        const auto previousUl = effectivePreviousTextAttr.GetUnderlineColor();\r\n+\r\n+        const auto attr = it->value.GetCharacterAttributes();\r\n+        const auto hyperlinkId = it->value.GetHyperlinkId();\r\n+        const auto fg = it->value.GetForeground();\r\n+        const auto bg = it->value.GetBackground();\r\n+        const auto ul = it->value.GetUnderlineColor();\r\n+\r\n+        if (previousAttr != attr)\r\n+        {\r\n+            auto attrDelta = attr ^ previousAttr;\r\n \r\n-                {\r\n-                    struct Mapping\r\n-                    {\r\n-                        CharacterAttributes attr;\r\n-                        uint8_t change[2]; // [0] = off, [1] = on\r\n-                    };\r\n-                    static constexpr Mapping mappings[] = {\r\n-                        { CharacterAttributes::Intense, { 22, 1 } },\r\n-                        { CharacterAttributes::Italics, { 23, 3 } },\r\n-                        { CharacterAttributes::Blinking, { 25, 5 } },\r\n-                        { CharacterAttributes::Invisible, { 28, 8 } },\r\n-                        { CharacterAttributes::CrossedOut, { 29, 9 } },\r\n-                        { CharacterAttributes::Faint, { 22, 2 } },\r\n-                        { CharacterAttributes::TopGridline, { 55, 53 } },\r\n-                        { CharacterAttributes::ReverseVideo, { 27, 7 } },\r\n-                    };\r\n-                    for (const auto& mapping : mappings)\r\n-                    {\r\n-                        if (WI_IsAnyFlagSet(attrDelta, mapping.attr))\r\n-                        {\r\n-                            const auto n = til::at(mapping.change, WI_IsAnyFlagSet(attr, mapping.attr));\r\n-                            fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[{}m\"), n);\r\n-                        }\r\n-                    }\r\n-                }\r\n+            // There's no escape sequence that only turns off either bold/intense or dim/faint. SGR 22 turns off both.\r\n+            // This results in two issues in our generic \"Mapping\" code below. Assuming, both Intense and Faint were on...\r\n+            // * ...and either turned off, it would emit SGR 22 which turns both attributes off = Wrong.\r\n+            // * ...and both are now off, it would emit SGR 22 twice.\r\n+            //\r\n+            // This extra branch takes care of both issues. If both attributes turned off it'll emit a single \\x1b[22m,\r\n+            // if faint turned off \\x1b[22;1m (intense is still on), and \\x1b[22;2m if intense turned off (vice versa).\r\n+            if (WI_AreAllFlagsSet(previousAttr, CharacterAttributes::Intense | CharacterAttributes::Faint) &&\r\n+                WI_IsAnyFlagSet(attrDelta, CharacterAttributes::Intense | CharacterAttributes::Faint))\r\n+            {\r\n+                wchar_t buf[8] = L\"\\x1b[22m\";\r\n+                size_t len = 5;\r\n \r\n-                if (WI_IsAnyFlagSet(attrDelta, CharacterAttributes::UnderlineStyle))\r\n+                if (WI_IsAnyFlagSet(attr, CharacterAttributes::Intense | CharacterAttributes::Faint))\r\n                 {\r\n-                    static constexpr std::wstring_view mappings[] = {\r\n-                        L\"\\x1b[24m\", // UnderlineStyle::NoUnderline\r\n-                        L\"\\x1b[4m\", // UnderlineStyle::SinglyUnderlined\r\n-                        L\"\\x1b[21m\", // UnderlineStyle::DoublyUnderlined\r\n-                        L\"\\x1b[4:3m\", // UnderlineStyle::CurlyUnderlined\r\n-                        L\"\\x1b[4:4m\", // UnderlineStyle::DottedUnderlined\r\n-                        L\"\\x1b[4:5m\", // UnderlineStyle::DashedUnderlined\r\n-                    };\r\n-\r\n-                    auto idx = WI_EnumValue(it->value.GetUnderlineStyle());\r\n-                    if (idx >= std::size(mappings))\r\n-                    {\r\n-                        idx = 1; // UnderlineStyle::SinglyUnderlined\r\n-                    }\r\n-\r\n-                    buffer.append(til::at(mappings, idx));\r\n+                    buf[4] = L';';\r\n+                    buf[5] = WI_IsAnyFlagSet(attr, CharacterAttributes::Intense) ? L'1' : L'2';\r\n+                    buf[6] = L'm';\r\n+                    len = 7;\r\n                 }\r\n \r\n-                previousAttr = attr;\r\n+                buffer.append(&buf[0], len);\r\n+                WI_ClearAllFlags(attrDelta, CharacterAttributes::Intense | CharacterAttributes::Faint);\r\n             }\r\n \r\n-            if (previousFg != fg)\r\n             {\r\n-                switch (fg.GetType())\r\n+                struct Mapping\r\n                 {\r\n-                case ColorType::IsDefault:\r\n-                    buffer.append(L\"\\x1b[39m\");\r\n-                    break;\r\n-                case ColorType::IsIndex16:\r\n+                    CharacterAttributes attr;\r\n+                    uint8_t change[2]; // [0] = off, [1] = on\r\n+                };\r\n+                static constexpr Mapping mappings[] = {\r\n+                    { CharacterAttributes::Intense, { 22, 1 } },\r\n+                    { CharacterAttributes::Italics, { 23, 3 } },\r\n+                    { CharacterAttributes::Blinking, { 25, 5 } },\r\n+                    { CharacterAttributes::Invisible, { 28, 8 } },\r\n+                    { CharacterAttributes::CrossedOut, { 29, 9 } },\r\n+                    { CharacterAttributes::Faint, { 22, 2 } },\r\n+                    { CharacterAttributes::TopGridline, { 55, 53 } },\r\n+                    { CharacterAttributes::ReverseVideo, { 27, 7 } },\r\n+                };\r\n+                for (const auto& mapping : mappings)\r\n                 {\r\n-                    uint8_t index = WI_IsFlagSet(fg.GetIndex(), 8) ? 90 : 30;\r\n-                    index += fg.GetIndex() & 7;\r\n-                    fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[{}m\"), index);\r\n-                    break;\r\n-                }\r\n-                case ColorType::IsIndex256:\r\n-                    fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[38;5;{}m\"), fg.GetIndex());\r\n-                    break;\r\n-                case ColorType::IsRgb:\r\n-                    fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[38;2;{};{};{}m\"), fg.GetR(), fg.GetG(), fg.GetB());\r\n-                    break;\r\n-                default:\r\n-                    break;\r\n+                    if (WI_IsAnyFlagSet(attrDelta, mapping.attr))\r\n+                    {\r\n+                        const auto n = til::at(mapping.change, WI_IsAnyFlagSet(attr, mapping.attr));\r\n+                        fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[{}m\"), n);\r\n+                    }\r\n                 }\r\n-                previousFg = fg;\r\n             }\r\n \r\n-            if (previousBg != bg)\r\n+            if (WI_IsAnyFlagSet(attrDelta, CharacterAttributes::UnderlineStyle))\r\n             {\r\n-                switch (bg.GetType())\r\n-                {\r\n-                case ColorType::IsDefault:\r\n-                    buffer.append(L\"\\x1b[49m\");\r\n-                    break;\r\n-                case ColorType::IsIndex16:\r\n+                static constexpr std::wstring_view mappings[] = {\r\n+                    L\"\\x1b[24m\", // UnderlineStyle::NoUnderline\r\n+                    L\"\\x1b[4m\", // UnderlineStyle::SinglyUnderlined\r\n+                    L\"\\x1b[21m\", // UnderlineStyle::DoublyUnderlined\r\n+                    L\"\\x1b[4:3m\", // UnderlineStyle::CurlyUnderlined\r\n+                    L\"\\x1b[4:4m\", // UnderlineStyle::DottedUnderlined\r\n+                    L\"\\x1b[4:5m\", // UnderlineStyle::DashedUnderlined\r\n+                };\r\n+\r\n+                auto idx = WI_EnumValue(it->value.GetUnderlineStyle());\r\n+                if (idx >= std::size(mappings))\r\n                 {\r\n-                    uint8_t index = WI_IsFlagSet(bg.GetIndex(), 8) ? 100 : 40;\r\n-                    index += bg.GetIndex() & 7;\r\n-                    fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[{}m\"), index);\r\n-                    break;\r\n-                }\r\n-                case ColorType::IsIndex256:\r\n-                    fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[48;5;{}m\"), bg.GetIndex());\r\n-                    break;\r\n-                case ColorType::IsRgb:\r\n-                    fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[48;2;{};{};{}m\"), bg.GetR(), bg.GetG(), bg.GetB());\r\n-                    break;\r\n-                default:\r\n-                    break;\r\n+                    idx = 1; // UnderlineStyle::SinglyUnderlined\r\n                 }\r\n-                previousBg = bg;\r\n+\r\n+                buffer.append(til::at(mappings, idx));\r\n             }\r\n+        }\r\n \r\n-            if (previousUl != ul)\r\n+        if (previousFg != fg)\r\n+        {\r\n+            switch (fg.GetType())\r\n             {\r\n-                switch (fg.GetType())\r\n-                {\r\n-                case ColorType::IsDefault:\r\n-                    buffer.append(L\"\\x1b[59m\");\r\n-                    break;\r\n-                case ColorType::IsIndex256:\r\n-                    fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[58:5:{}m\"), ul.GetIndex());\r\n-                    break;\r\n-                case ColorType::IsRgb:\r\n-                    fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[58:2::{}:{}:{}m\"), ul.GetR(), ul.GetG(), ul.GetB());\r\n-                    break;\r\n-                default:\r\n-                    break;\r\n-                }\r\n-                previousUl = ul;\r\n+            case ColorType::IsDefault:\r\n+                buffer.append(L\"\\x1b[39m\");\r\n+                break;\r\n+            case ColorType::IsIndex16:\r\n+            {\r\n+                uint8_t index = WI_IsFlagSet(fg.GetIndex(), 8) ? 90 : 30;\r\n+                index += fg.GetIndex() & 7;\r\n+                fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[{}m\"), index);\r\n+                break;\r\n             }\r\n+            case ColorType::IsIndex256:\r\n+                fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[38;5;{}m\"), fg.GetIndex());\r\n+                break;\r\n+            case ColorType::IsRgb:\r\n+                fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[38;2;{};{};{}m\"), fg.GetR(), fg.GetG(), fg.GetB());\r\n+                break;\r\n+            default:\r\n+                break;\r\n+            }\r\n+        }\r\n \r\n-            if (previousHyperlinkId != hyperlinkId)\r\n+        if (previousBg != bg)\r\n+        {\r\n+            switch (bg.GetType())\r\n             {\r\n-                if (hyperlinkId)\r\n-                {\r\n-                    const auto uri = GetHyperlinkUriFromId(hyperlinkId);\r\n-                    if (!uri.empty())\r\n-                    {\r\n-                        buffer.append(L\"\\x1b]8;;\");\r\n-                        buffer.append(uri);\r\n-                        buffer.append(L\"\\x1b\\\\\");\r\n-                        previousHyperlinkId = hyperlinkId;\r\n-                    }\r\n-                }\r\n-                else\r\n-                {\r\n-                    buffer.append(L\"\\x1b]8;;\\x1b\\\\\");\r\n-                    previousHyperlinkId = 0;\r\n-                }\r\n+            case ColorType::IsDefault:\r\n+                buffer.append(L\"\\x1b[49m\");\r\n+                break;\r\n+            case ColorType::IsIndex16:\r\n+            {\r\n+                uint8_t index = WI_IsFlagSet(bg.GetIndex(), 8) ? 100 : 40;\r\n+                index += bg.GetIndex() & 7;\r\n+                fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[{}m\"), index);\r\n+                break;\r\n             }\r\n+            case ColorType::IsIndex256:\r\n+                fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[48;5;{}m\"), bg.GetIndex());\r\n+                break;\r\n+            case ColorType::IsRgb:\r\n+                fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[48;2;{};{};{}m\"), bg.GetR(), bg.GetG(), bg.GetB());\r\n+                break;\r\n+            default:\r\n+                break;\r\n+            }\r\n+        }\r\n \r\n-            // Initially, the buffer is initialized with the default attributes, but once it begins to scroll,\r\n-            // newly scrolled in rows are initialized with the current attributes. This means we need to set\r\n-            // the current attributes to those of the upcoming row before the row comes up. Or inversely:\r\n-            // We let the row come up, let it set its attributes and only then print the newline.\r\n-            if (delayedLineBreak)\r\n+        if (previousUl != ul)\r\n+        {\r\n+            switch (fg.GetType())\r\n             {\r\n-                buffer.append(L\"\\r\\n\");\r\n-                delayedLineBreak = false;\r\n+            case ColorType::IsDefault:\r\n+                buffer.append(L\"\\x1b[59m\");\r\n+                break;\r\n+            case ColorType::IsIndex256:\r\n+                fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[58:5:{}m\"), ul.GetIndex());\r\n+                break;\r\n+            case ColorType::IsRgb:\r\n+                fmt::format_to(std::back_inserter(buffer), FMT_COMPILE(L\"\\x1b[58:2::{}:{}:{}m\"), ul.GetR(), ul.GetG(), ul.GetB());\r\n+                break;\r\n+            default:\r\n+                break;\r\n             }\r\n+        }\r\n \r\n-            auto newX = oldX + it->length;\r\n-\r\n-            // Since our text buffer doesn't store the original input text, the information over the amount of trailing\r\n-            // whitespaces was lost. If we don't do anything here then a row that just says \"Hello\" would be serialized\r\n-            // to \"Hello                    ...\". If the user restores the buffer dump with a different window size,\r\n-            // this would result in some fairly ugly reflow. This code attempts to at least trim trailing whitespaces.\r\n-            //\r\n-            // As mentioned above for `delayedLineBreak`, rows are initialized with their first attribute, BUT\r\n-            // only if the viewport has begun to scroll. Otherwise, they're initialized with the default attributes.\r\n-            // In other words, we can only skip \\x1b[K = Erase in Line, if both the first/last attribute are the default attribute.\r\n-            static constexpr TextAttribute defaultAttr;\r\n-            const auto trimTrailingWhitespaces = it == last && lastCharX < newX;\r\n-            const auto clearToEndOfLine = trimTrailingWhitespaces && (beg->value != defaultAttr || last->value != defaultAttr);\r\n-\r\n-            if (trimTrailingWhitespaces)\r\n+        if (previousHyperlinkId != hyperlinkId)\r\n+        {\r\n+            if (hyperlinkId)\r\n             {\r\n-                newX = lastCharX;\r\n+                const auto uri = GetHyperlinkUriFromId(hyperlinkId);\r\n+                if (!uri.empty())\r\n+                {\r\n+                    buffer.append(L\"\\x1b]8;;\");\r\n+                    buffer.append(uri);\r\n+                    buffer.append(L\"\\x1b\\\\\");\r\n+                }\r\n             }\r\n-\r\n-            buffer.append(row.GetText(oldX, newX));\r\n-\r\n-            if (clearToEndOfLine)\r\n+            else\r\n             {\r\n-                buffer.append(L\"\\x1b[K\");\r\n+                buffer.append(L\"\\x1b]8;;\\x1b\\\\\");\r\n             }\r\n+        }\r\n \r\n-            oldX = newX;\r\n+        previousTextAttr = it->value;\r\n+\r\n+        // Initially, the buffer is initialized with the default attributes, but once it begins to scroll,\r\n+        // newly scrolled in rows are initialized with the current attributes. This means we need to set\r\n+        // the current attributes to those of the upcoming row before the row comes up. Or inversely:\r\n+        // We let the row come up, let it set its attributes and only then print the newline.\r\n+        if (delayedLineBreak)\r\n+        {\r\n+            buffer.append(L\"\\r\\n\");\r\n+            delayedLineBreak = false;\r\n         }\r\n \r\n-        const auto moreRowsRemaining = currentRow < lastRowWithText;\r\n-        delayedLineBreak = !row.WasWrapForced();\r\n+        auto newX = oldX + it->length;\r\n \r\n-        if (!moreRowsRemaining)\r\n+        // Since our text buffer doesn't store the original input text, the information over the amount of trailing\r\n+        // whitespaces was lost. If we don't do anything here then a row that just says \"Hello\" would be serialized\r\n+        // to \"Hello                    ...\". If the user restores the buffer dump with a different window size,\r\n+        // this would result in some fairly ugly reflow. This code attempts to at least trim trailing whitespaces.\r\n+        //\r\n+        // As mentioned above for `delayedLineBreak`, rows are initialized with their first attribute, BUT\r\n+        // only if the viewport has begun to scroll. Otherwise, they're initialized with the default attributes.\r\n+        // In other words, we can only skip \\x1b[K = Erase in Line, if both the first/last attribute are the default attribute.\r\n+        static constexpr TextAttribute defaultAttr;\r\n+        const auto trimTrailingWhitespaces = it == last && lastCharX < newX;\r\n+        const auto clearToEndOfLine = trimTrailingWhitespaces && (beg->value != defaultAttr || last->value != defaultAttr);\r\n+\r\n+        if (trimTrailingWhitespaces)\r\n         {\r\n-            if (previousHyperlinkId)\r\n-            {\r\n-                buffer.append(L\"\\x1b]8;;\\x1b\\\\\");\r\n-            }\r\n-            buffer.append(L\"\\x1b[m\\r\\n\");\r\n+            newX = lastCharX;\r\n         }\r\n \r\n-        if (buffer.size() >= writeThreshold || !moreRowsRemaining)\r\n+        buffer.append(row.GetText(oldX, newX));\r\n+\r\n+        if (clearToEndOfLine)\r\n         {\r\n-            const auto fileSize = gsl::narrow<DWORD>(buffer.size() * sizeof(wchar_t));\r\n-            DWORD bytesWritten = 0;\r\n-            THROW_IF_WIN32_BOOL_FALSE(WriteFile(file.get(), buffer.data(), fileSize, &bytesWritten, nullptr));\r\n-            THROW_WIN32_IF_MSG(ERROR_WRITE_FAULT, bytesWritten != fileSize, \"failed to write\");\r\n-            buffer.clear();\r\n+            buffer.append(L\"\\x1b[K\");\r\n         }\r\n \r\n-        if (!moreRowsRemaining)\r\n+        oldX = newX;\r\n+    }\r\n+\r\n+    // Handle empty rows (with no runs). See above for more details about `delayedLineBreak`.\r\n+    if (delayedLineBreak)\r\n+    {\r\n+        buffer.append(L\"\\r\\n\");\r\n+        delayedLineBreak = false;\r\n+    }\r\n+\r\n+    delayedLineBreak = !row.WasWrapForced() && addLineBreak;\r\n+\r\n+    if (isLastRow)\r\n+    {\r\n+        if (previousTextAttr.has_value() && previousTextAttr->GetHyperlinkId())\r\n         {\r\n-            break;\r\n+            buffer.append(L\"\\x1b]8;;\\x1b\\\\\");\r\n+        }\r\n+        buffer.append(L\"\\x1b[0m\");\r\n+        if (addLineBreak)\r\n+        {\r\n+            buffer.append(L\"\\r\\n\");\r\n         }\r\n     }\r\n }\r\ndiff --git a/src/buffer/out/textBuffer.hpp b/src/buffer/out/textBuffer.hpp\nindex a39ebd4db40..c97de9e7523 100644\n--- a/src/buffer/out/textBuffer.hpp\n+++ b/src/buffer/out/textBuffer.hpp\n@@ -266,6 +266,8 @@ class TextBuffer final\n \r\n     std::wstring GetPlainText(const CopyRequest& req) const;\r\n \r\n+    std::wstring GetWithControlSequences(const CopyRequest& req) const;\r\n+\r\n     std::string GenHTML(const CopyRequest& req,\r\n                         const int fontHeightPoints,\r\n                         const std::wstring_view fontFaceName,\r\n@@ -280,7 +282,7 @@ class TextBuffer final\n                        const bool isIntenseBold,\r\n                        std::function<std::tuple<COLORREF, COLORREF, COLORREF>(const TextAttribute&)> GetAttributeColors) const noexcept;\r\n \r\n-    void Serialize(const wchar_t* destination) const;\r\n+    void SerializeToPath(const wchar_t* destination) const;\r\n \r\n     struct PositionInformation\r\n     {\r\n@@ -332,6 +334,8 @@ class TextBuffer final\n \r\n     std::tuple<til::CoordType, til::CoordType, bool> _RowCopyHelper(const CopyRequest& req, const til::CoordType iRow, const ROW& row) const;\r\n \r\n+    void _SerializeRow(const ROW& row, const til::CoordType startX, const til::CoordType endX, const bool addLineBreak, const bool isLastRow, std::wstring& buffer, std::optional<TextAttribute>& previousTextAttr, bool& delayedLineBreak) const;\r\n+\r\n     static void _AppendRTFText(std::string& contentBuilder, const std::wstring_view& text);\r\n \r\n     Microsoft::Console::Render::Renderer* _renderer = nullptr;\r\ndiff --git a/src/cascadia/TerminalApp/AppActionHandlers.cpp b/src/cascadia/TerminalApp/AppActionHandlers.cpp\nindex 8675fb98bac..0bfbcff8ad7 100644\n--- a/src/cascadia/TerminalApp/AppActionHandlers.cpp\n+++ b/src/cascadia/TerminalApp/AppActionHandlers.cpp\n@@ -548,7 +548,7 @@ namespace winrt::TerminalApp::implementation\n     {\r\n         if (const auto& realArgs = args.ActionArgs().try_as<CopyTextArgs>())\r\n         {\r\n-            const auto handled = _CopyText(realArgs.DismissSelection(), realArgs.SingleLine(), realArgs.CopyFormatting());\r\n+            const auto handled = _CopyText(realArgs.DismissSelection(), realArgs.SingleLine(), realArgs.WithControlSequences(), realArgs.CopyFormatting());\r\n             args.Handled(handled);\r\n         }\r\n     }\r\ndiff --git a/src/cascadia/TerminalApp/TerminalPage.cpp b/src/cascadia/TerminalApp/TerminalPage.cpp\nindex b3111e9b639..13391e44f42 100644\n--- a/src/cascadia/TerminalApp/TerminalPage.cpp\n+++ b/src/cascadia/TerminalApp/TerminalPage.cpp\n@@ -2971,14 +2971,15 @@ namespace winrt::TerminalApp::implementation\n     // Arguments:\n     // - dismissSelection: if not enabled, copying text doesn't dismiss the selection\n     // - singleLine: if enabled, copy contents as a single line of text\n+    // - withControlSequences: if enabled, the copied plain text contains color/style ANSI escape codes from the selection\n     // - formats: dictate which formats need to be copied\n     // Return Value:\n     // - true iff we we able to copy text (if a selection was active)\n-    bool TerminalPage::_CopyText(const bool dismissSelection, const bool singleLine, const Windows::Foundation::IReference<CopyFormat>& formats)\n+    bool TerminalPage::_CopyText(const bool dismissSelection, const bool singleLine, const bool withControlSequences, const Windows::Foundation::IReference<CopyFormat>& formats)\n     {\n         if (const auto& control{ _GetActiveControl() })\n         {\n-            return control.CopySelectionToClipboard(dismissSelection, singleLine, formats);\n+            return control.CopySelectionToClipboard(dismissSelection, singleLine, withControlSequences, formats);\n         }\n         return false;\n     }\ndiff --git a/src/cascadia/TerminalApp/TerminalPage.h b/src/cascadia/TerminalApp/TerminalPage.h\nindex 9e5d3029c7f..28ccfd8ec8c 100644\n--- a/src/cascadia/TerminalApp/TerminalPage.h\n+++ b/src/cascadia/TerminalApp/TerminalPage.h\n@@ -429,7 +429,7 @@ namespace winrt::TerminalApp::implementation\n         bool _IsUriSupported(const winrt::Windows::Foundation::Uri& parsedUri);\n \n         void _ShowCouldNotOpenDialog(winrt::hstring reason, winrt::hstring uri);\n-        bool _CopyText(const bool dismissSelection, const bool singleLine, const Windows::Foundation::IReference<Microsoft::Terminal::Control::CopyFormat>& formats);\n+        bool _CopyText(const bool dismissSelection, const bool singleLine, const bool withControlSequences, const Windows::Foundation::IReference<Microsoft::Terminal::Control::CopyFormat>& formats);\n \n         safe_void_coroutine _SetTaskbarProgressHandler(const IInspectable sender, const IInspectable eventArgs);\n \ndiff --git a/src/cascadia/TerminalControl/ControlCore.cpp b/src/cascadia/TerminalControl/ControlCore.cpp\nindex 9cc7732f452..d7beb39a504 100644\n--- a/src/cascadia/TerminalControl/ControlCore.cpp\n+++ b/src/cascadia/TerminalControl/ControlCore.cpp\n@@ -574,7 +574,7 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n             else if (vkey == VK_RETURN && !mods.IsCtrlPressed() && !mods.IsAltPressed())\r\n             {\r\n                 // [Shift +] Enter --> copy text\r\n-                CopySelectionToClipboard(mods.IsShiftPressed(), nullptr);\r\n+                CopySelectionToClipboard(mods.IsShiftPressed(), false, nullptr);\r\n                 _terminal->ClearSelection();\r\n                 _updateSelectionUI();\r\n                 return true;\r\n@@ -1315,9 +1315,11 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n     //     Windows Clipboard (CascadiaWin32:main.cpp).\r\n     // Arguments:\r\n     // - singleLine: collapse all of the text to one line\r\n+    // - withControlSequences: if enabled, the copied plain text contains color/style ANSI escape codes from the selection\r\n     // - formats: which formats to copy (defined by action's CopyFormatting arg). nullptr\r\n     //             if we should defer which formats are copied to the global setting\r\n     bool ControlCore::CopySelectionToClipboard(bool singleLine,\r\n+                                               bool withControlSequences,\r\n                                                const Windows::Foundation::IReference<CopyFormat>& formats)\r\n     {\r\n         ::Microsoft::Terminal::Core::Terminal::TextCopyData payload;\r\n@@ -1339,7 +1341,7 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n \r\n             // extract text from buffer\r\n             // RetrieveSelectedTextFromBuffer will lock while it's reading\r\n-            payload = _terminal->RetrieveSelectedTextFromBuffer(singleLine, copyHtml, copyRtf);\r\n+            payload = _terminal->RetrieveSelectedTextFromBuffer(singleLine, withControlSequences, copyHtml, copyRtf);\r\n         }\r\n \r\n         copyToClipboard(payload.plainText, payload.html, payload.rtf);\r\ndiff --git a/src/cascadia/TerminalControl/ControlCore.h b/src/cascadia/TerminalControl/ControlCore.h\nindex 1719f34c880..609aed42834 100644\n--- a/src/cascadia/TerminalControl/ControlCore.h\n+++ b/src/cascadia/TerminalControl/ControlCore.h\n@@ -123,7 +123,7 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n \r\n         void SendInput(std::wstring_view wstr);\r\n         void PasteText(const winrt::hstring& hstr);\r\n-        bool CopySelectionToClipboard(bool singleLine, const Windows::Foundation::IReference<CopyFormat>& formats);\r\n+        bool CopySelectionToClipboard(bool singleLine, bool withControlSequences, const Windows::Foundation::IReference<CopyFormat>& formats);\r\n         void SelectAll();\r\n         void ClearSelection();\r\n         bool ToggleBlockSelection();\r\ndiff --git a/src/cascadia/TerminalControl/ControlInteractivity.cpp b/src/cascadia/TerminalControl/ControlInteractivity.cpp\nindex f18851c2fbb..c99d69ae6a4 100644\n--- a/src/cascadia/TerminalControl/ControlInteractivity.cpp\n+++ b/src/cascadia/TerminalControl/ControlInteractivity.cpp\n@@ -194,9 +194,11 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n     //     Windows Clipboard (CascadiaWin32:main.cpp).\r\n     // Arguments:\r\n     // - singleLine: collapse all of the text to one line\r\n+    // - withControlSequences: if enabled, the copied plain text contains color/style ANSI escape codes from the selection\r\n     // - formats: which formats to copy (defined by action's CopyFormatting arg). nullptr\r\n     //             if we should defer which formats are copied to the global setting\r\n     bool ControlInteractivity::CopySelectionToClipboard(bool singleLine,\r\n+                                                        bool withControlSequences,\r\n                                                         const Windows::Foundation::IReference<CopyFormat>& formats)\r\n     {\r\n         if (_core)\r\n@@ -213,7 +215,7 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n             // Mark the current selection as copied\r\n             _selectionNeedsToBeCopied = false;\r\n \r\n-            return _core->CopySelectionToClipboard(singleLine, formats);\r\n+            return _core->CopySelectionToClipboard(singleLine, withControlSequences, formats);\r\n         }\r\n \r\n         return false;\r\n@@ -312,7 +314,7 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n             else\r\n             {\r\n                 // Try to copy the text and clear the selection\r\n-                const auto successfulCopy = CopySelectionToClipboard(shiftEnabled, nullptr);\r\n+                const auto successfulCopy = CopySelectionToClipboard(shiftEnabled, false, nullptr);\r\n                 _core->ClearSelection();\r\n                 if (_core->CopyOnSelect() || !successfulCopy)\r\n                 {\r\n@@ -445,7 +447,7 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n             // IMPORTANT!\r\n             // DO NOT clear the selection here!\r\n             // Otherwise, the selection will be cleared immediately after you make it.\r\n-            CopySelectionToClipboard(false, nullptr);\r\n+            CopySelectionToClipboard(false, false, nullptr);\r\n         }\r\n \r\n         _singleClickTouchdownPos = std::nullopt;\r\ndiff --git a/src/cascadia/TerminalControl/ControlInteractivity.h b/src/cascadia/TerminalControl/ControlInteractivity.h\nindex 22eaa95c397..a1b3d7993cf 100644\n--- a/src/cascadia/TerminalControl/ControlInteractivity.h\n+++ b/src/cascadia/TerminalControl/ControlInteractivity.h\n@@ -83,6 +83,7 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n #pragma endregion\r\n \r\n         bool CopySelectionToClipboard(bool singleLine,\r\n+                                      bool withControlSequences,\r\n                                       const Windows::Foundation::IReference<CopyFormat>& formats);\r\n         void RequestPasteTextFromClipboard();\r\n         void SetEndSelectionPoint(const Core::Point pixelPosition);\r\ndiff --git a/src/cascadia/TerminalControl/ControlInteractivity.idl b/src/cascadia/TerminalControl/ControlInteractivity.idl\nindex 926c1e3b0a9..dcc2b793420 100644\n--- a/src/cascadia/TerminalControl/ControlInteractivity.idl\n+++ b/src/cascadia/TerminalControl/ControlInteractivity.idl\n@@ -32,7 +32,7 @@ namespace Microsoft.Terminal.Control\n \r\n         InteractivityAutomationPeer OnCreateAutomationPeer();\r\n \r\n-        Boolean CopySelectionToClipboard(Boolean singleLine, Windows.Foundation.IReference<CopyFormat> formats);\r\n+        Boolean CopySelectionToClipboard(Boolean singleLine, Boolean withControlSequences, Windows.Foundation.IReference<CopyFormat> formats);\r\n         void RequestPasteTextFromClipboard();\r\n         void SetEndSelectionPoint(Microsoft.Terminal.Core.Point point);\r\n \r\ndiff --git a/src/cascadia/TerminalControl/HwndTerminal.cpp b/src/cascadia/TerminalControl/HwndTerminal.cpp\nindex 905de2ce988..b3cc4edf688 100644\n--- a/src/cascadia/TerminalControl/HwndTerminal.cpp\n+++ b/src/cascadia/TerminalControl/HwndTerminal.cpp\n@@ -116,7 +116,7 @@ try\n                     const auto lock = publicTerminal->_terminal->LockForWriting();\r\n                     if (publicTerminal->_terminal->IsSelectionActive())\r\n                     {\r\n-                        const auto bufferData = publicTerminal->_terminal->RetrieveSelectedTextFromBuffer(false, true, true);\r\n+                        const auto bufferData = publicTerminal->_terminal->RetrieveSelectedTextFromBuffer(false, false, true, true);\r\n                         LOG_IF_FAILED(publicTerminal->_CopyTextToSystemClipboard(bufferData.plainText, bufferData.html, bufferData.rtf));\r\n                         publicTerminal->_ClearSelection();\r\n                         return 0;\r\ndiff --git a/src/cascadia/TerminalControl/TermControl.cpp b/src/cascadia/TerminalControl/TermControl.cpp\nindex f76c8c59403..88857713a1f 100644\n--- a/src/cascadia/TerminalControl/TermControl.cpp\n+++ b/src/cascadia/TerminalControl/TermControl.cpp\n@@ -2543,16 +2543,17 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n     // Arguments:\r\n     // - dismissSelection: dismiss the text selection after copy\r\n     // - singleLine: collapse all of the text to one line\r\n+    // - withControlSequences: if enabled, the copied plain text contains color/style ANSI escape codes from the selection\r\n     // - formats: which formats to copy (defined by action's CopyFormatting arg). nullptr\r\n     //             if we should defer which formats are copied to the global setting\r\n-    bool TermControl::CopySelectionToClipboard(bool dismissSelection, bool singleLine, const Windows::Foundation::IReference<CopyFormat>& formats)\r\n+    bool TermControl::CopySelectionToClipboard(bool dismissSelection, bool singleLine, bool withControlSequences, const Windows::Foundation::IReference<CopyFormat>& formats)\r\n     {\r\n         if (_IsClosing())\r\n         {\r\n             return false;\r\n         }\r\n \r\n-        const auto successfulCopy = _interactivity.CopySelectionToClipboard(singleLine, formats);\r\n+        const auto successfulCopy = _interactivity.CopySelectionToClipboard(singleLine, withControlSequences, formats);\r\n \r\n         if (dismissSelection)\r\n         {\r\n@@ -4189,7 +4190,7 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n                                           const IInspectable& /*args*/)\r\n     {\r\n         // formats = nullptr -> copy all formats\r\n-        _interactivity.CopySelectionToClipboard(false, nullptr);\r\n+        _interactivity.CopySelectionToClipboard(false, false, nullptr);\r\n         ContextMenu().Hide();\r\n         SelectionContextMenu().Hide();\r\n     }\r\ndiff --git a/src/cascadia/TerminalControl/TermControl.h b/src/cascadia/TerminalControl/TermControl.h\nindex d8a44161dbf..7e35585aa59 100644\n--- a/src/cascadia/TerminalControl/TermControl.h\n+++ b/src/cascadia/TerminalControl/TermControl.h\n@@ -60,7 +60,7 @@ namespace winrt::Microsoft::Terminal::Control::implementation\n \r\n         hstring GetProfileName() const;\r\n \r\n-        bool CopySelectionToClipboard(bool dismissSelection, bool singleLine, const Windows::Foundation::IReference<CopyFormat>& formats);\r\n+        bool CopySelectionToClipboard(bool dismissSelection, bool singleLine, bool withControlSequences, const Windows::Foundation::IReference<CopyFormat>& formats);\r\n         void PasteTextFromClipboard();\r\n         void SelectAll();\r\n         bool ToggleBlockSelection();\r\ndiff --git a/src/cascadia/TerminalControl/TermControl.idl b/src/cascadia/TerminalControl/TermControl.idl\nindex c60b5884540..8ff69f33c5e 100644\n--- a/src/cascadia/TerminalControl/TermControl.idl\n+++ b/src/cascadia/TerminalControl/TermControl.idl\n@@ -87,7 +87,7 @@ namespace Microsoft.Terminal.Control\n         event Windows.Foundation.TypedEventHandler<Object, Object> CloseTerminalRequested;\r\n         event Windows.Foundation.TypedEventHandler<Object, Object> RestartTerminalRequested;\r\n \r\n-        Boolean CopySelectionToClipboard(Boolean dismissSelection, Boolean singleLine, Windows.Foundation.IReference<CopyFormat> formats);\r\n+        Boolean CopySelectionToClipboard(Boolean dismissSelection, Boolean singleLine, Boolean withControlSequences, Windows.Foundation.IReference<CopyFormat> formats);\r\n         void PasteTextFromClipboard();\r\n         void SelectAll();\r\n         Boolean ToggleBlockSelection();\r\ndiff --git a/src/cascadia/TerminalCore/Terminal.cpp b/src/cascadia/TerminalCore/Terminal.cpp\nindex c61c339b79e..c77ab1ab764 100644\n--- a/src/cascadia/TerminalCore/Terminal.cpp\n+++ b/src/cascadia/TerminalCore/Terminal.cpp\n@@ -1570,7 +1570,7 @@ std::wstring Terminal::CurrentCommand() const\n \r\n void Terminal::SerializeMainBuffer(const wchar_t* destination) const\r\n {\r\n-    _mainBuffer->Serialize(destination);\r\n+    _mainBuffer->SerializeToPath(destination);\r\n }\r\n \r\n void Terminal::ColorSelection(const TextAttribute& attr, winrt::Microsoft::Terminal::Core::MatchMode matchMode)\r\ndiff --git a/src/cascadia/TerminalCore/Terminal.hpp b/src/cascadia/TerminalCore/Terminal.hpp\nindex 7fdf0995013..8ac499c97e2 100644\n--- a/src/cascadia/TerminalCore/Terminal.hpp\n+++ b/src/cascadia/TerminalCore/Terminal.hpp\n@@ -320,7 +320,7 @@ class Microsoft::Terminal::Core::Terminal final :\n     til::point SelectionEndForRendering() const;\r\n     const SelectionEndpoint SelectionEndpointTarget() const noexcept;\r\n \r\n-    TextCopyData RetrieveSelectedTextFromBuffer(const bool singleLine, const bool html = false, const bool rtf = false) const;\r\n+    TextCopyData RetrieveSelectedTextFromBuffer(const bool singleLine, const bool withControlSequences = false, const bool html = false, const bool rtf = false) const;\r\n #pragma endregion\r\n \r\n #ifndef NDEBUG\r\ndiff --git a/src/cascadia/TerminalCore/TerminalSelection.cpp b/src/cascadia/TerminalCore/TerminalSelection.cpp\nindex 2cb3ee08bfd..6a800f329dd 100644\n--- a/src/cascadia/TerminalCore/TerminalSelection.cpp\n+++ b/src/cascadia/TerminalCore/TerminalSelection.cpp\n@@ -844,12 +844,13 @@ void Terminal::ClearSelection()\n // - Optionally, get the highlighted text in HTML and RTF formats\r\n // Arguments:\r\n // - singleLine: collapse all of the text to one line. (Turns off trailing whitespace trimming)\r\n+// - withControlSequences: if enabled, the copied plain text contains color/style ANSI escape codes from the selection\r\n // - html: also get text in HTML format\r\n // - rtf: also get text in RTF format\r\n // Return Value:\r\n // - Plain and formatted selected text from buffer. Empty string represents no data for that format.\r\n // - If extended to multiple lines, each line is separated by \\r\\n\r\n-Terminal::TextCopyData Terminal::RetrieveSelectedTextFromBuffer(const bool singleLine, const bool html, const bool rtf) const\r\n+Terminal::TextCopyData Terminal::RetrieveSelectedTextFromBuffer(const bool singleLine, const bool withControlSequences, const bool html, const bool rtf) const\r\n {\r\n     TextCopyData data;\r\n \r\n@@ -867,7 +868,14 @@ Terminal::TextCopyData Terminal::RetrieveSelectedTextFromBuffer(const bool singl\n     const auto& textBuffer = _activeBuffer();\r\n \r\n     const auto req = TextBuffer::CopyRequest::FromConfig(textBuffer, _selection->start, _selection->end, singleLine, _selection->blockSelection, _trimBlockSelection);\r\n-    data.plainText = textBuffer.GetPlainText(req);\r\n+    if (withControlSequences)\r\n+    {\r\n+        data.plainText = textBuffer.GetWithControlSequences(req);\r\n+    }\r\n+    else\r\n+    {\r\n+        data.plainText = textBuffer.GetPlainText(req);\r\n+    }\r\n \r\n     if (html || rtf)\r\n     {\r\ndiff --git a/src/cascadia/TerminalSettingsModel/ActionArgs.cpp b/src/cascadia/TerminalSettingsModel/ActionArgs.cpp\nindex 8b3e58a11b5..98411fd9b98 100644\n--- a/src/cascadia/TerminalSettingsModel/ActionArgs.cpp\n+++ b/src/cascadia/TerminalSettingsModel/ActionArgs.cpp\n@@ -207,6 +207,11 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n             str.append(RS_(L\"CopyTextCommandKey\"));\r\n         }\r\n \r\n+        if (WithControlSequences())\r\n+        {\r\n+            str.append(L\", withControlSequences: true\");\r\n+        }\r\n+\r\n         if (!DismissSelection())\r\n         {\r\n             str.append(L\", dismissSelection: false\");\r\ndiff --git a/src/cascadia/TerminalSettingsModel/ActionArgs.h b/src/cascadia/TerminalSettingsModel/ActionArgs.h\nindex 84c23dd2d7d..cd854b19cf3 100644\n--- a/src/cascadia/TerminalSettingsModel/ActionArgs.h\n+++ b/src/cascadia/TerminalSettingsModel/ActionArgs.h\n@@ -103,9 +103,10 @@ protected:                                                                  \\\n // false, if we don't really care if the parameter is required or not.\r\n \r\n ////////////////////////////////////////////////////////////////////////////////\r\n-#define COPY_TEXT_ARGS(X)                                      \\\r\n-    X(bool, DismissSelection, \"dismissSelection\", false, true) \\\r\n-    X(bool, SingleLine, \"singleLine\", false, false)            \\\r\n+#define COPY_TEXT_ARGS(X)                                               \\\r\n+    X(bool, DismissSelection, \"dismissSelection\", false, true)          \\\r\n+    X(bool, SingleLine, \"singleLine\", false, false)                     \\\r\n+    X(bool, WithControlSequences, \"withControlSequences\", false, false) \\\r\n     X(Windows::Foundation::IReference<Control::CopyFormat>, CopyFormatting, \"copyFormatting\", false, nullptr)\r\n \r\n ////////////////////////////////////////////////////////////////////////////////\r\ndiff --git a/src/cascadia/TerminalSettingsModel/ActionArgs.idl b/src/cascadia/TerminalSettingsModel/ActionArgs.idl\nindex 02f0c4d0413..5f6bf22cd5f 100644\n--- a/src/cascadia/TerminalSettingsModel/ActionArgs.idl\n+++ b/src/cascadia/TerminalSettingsModel/ActionArgs.idl\n@@ -180,6 +180,7 @@ namespace Microsoft.Terminal.Settings.Model\n         CopyTextArgs();\r\n         Boolean DismissSelection { get; };\r\n         Boolean SingleLine { get; };\r\n+        Boolean WithControlSequences { get; };\r\n         Windows.Foundation.IReference<Microsoft.Terminal.Control.CopyFormat> CopyFormatting { get; };\r\n     };\r\n \r\n", "instance_id": "microsoft__terminal-17059", "clarity": 2, "difficulty": 0.65, "clarity_explanation": "\nThe problem statement for \"Copy with Control Sequences\" is mostly clear in its intent to add a feature for copying text from a terminal with ANSI escape sequences included, which is useful for preserving styling in copied output. The goal is well-defined, referencing a similar feature in iTerm2 and providing a use case (e.g., copying styled output to markdown with ANSI support). However, there are minor ambiguities and missing details that prevent it from being comprehensive. For instance, the problem statement does not explicitly define how the ANSI sequences should be handled (e.g., whether to preserve original sequences or recreate them as a best-effort approach, though it mentions both as options). It also lacks specifics on input/output formats, constraints, or edge cases (e.g., how to handle invalid or unsupported sequences, large selections, or performance implications). Additionally, there are no examples of expected input and output, which would help clarify the feature's behavior. While the proposed technical implementation is optional and provides some direction, it does not fully address these gaps. Therefore, I rate the clarity as \"Mostly Clear\" with a score of 2.\n", "difficulty_explanation": "\nI assess the difficulty of this problem as 0.65, placing it in the \"Hard\" range (0.6-0.8), due to the following factors:\n\n1. **Scope and Depth of Code Changes**: The code changes are extensive, spanning multiple files and modules within what appears to be a terminal emulator codebase (likely Windows Terminal, given the context of \"Cascadia\"). Modifications include updates to the text buffer logic (`TextBuffer.cpp`), user interface interactions (`TerminalControl`, `TerminalPage`), settings schema (`profiles.schema.json`), and action handling (`ActionArgs`). The changes involve adding a new method for copying text with ANSI sequences (`GetWithControlSequences`), refactoring existing serialization logic (`SerializeToPath`), and propagating a new parameter (`withControlSequences`) through various layers of the application. While the changes do not appear to impact the core architecture fundamentally, they require a broad understanding of how different components (text buffer, clipboard handling, UI interactions) interact, making the scope moderately complex.\n\n2. **Number of Technical Concepts**: Solving this problem requires familiarity with several technical concepts, including:\n   - **ANSI Escape Sequences**: Understanding how these sequences represent text styling (e.g., colors, bold, underline) and how to serialize them correctly.\n   - **Text Buffer Management**: Deep knowledge of how the terminal's text buffer stores and retrieves text and attributes, as seen in the detailed logic for handling text runs, attributes, and line renditions.\n   - **Clipboard Handling**: Familiarity with how text is copied to the clipboard in different formats (plain text, HTML, RTF) and extending this to include ANSI sequences.\n   - **C++ Programming**: Proficiency in C++ (given the codebase), including string manipulation (`std::wstring`), iterators, and low-level file operations.\n   - **Windows Terminal Architecture**: Understanding the interaction between various components like `TerminalCore`, `TerminalControl`, and settings models.\n   These concepts are moderately advanced, especially the handling of ANSI sequences and text buffer serialization, which require domain-specific knowledge of terminal emulation.\n\n3. **Potential Edge Cases and Error Handling**: The problem statement does not explicitly mention edge cases, but the code changes reveal several that need consideration, such as:\n   - Handling empty selections or invalid copy requests (addressed with a simple check in `GetWithControlSequences`).\n   - Managing attribute transitions between text runs (e.g., turning off/on styles like bold or faint, handled with complex logic in `_SerializeRow`).\n   - Dealing with line breaks and wrapping behavior (addressed with `delayedLineBreak` logic).\n   - Ensuring compatibility with different terminal outputs or clipboard consumers that may or may not support ANSI sequences.\n   The code changes show significant effort in handling these cases, particularly in serializing rows with correct styling and line rendition. However, performance implications for large selections or buffers with many style changes are not addressed, which could be a concern.\n\n4. **Overall Complexity**: The implementation requires a deep understanding of the existing codebase to ensure that the new feature integrates seamlessly without breaking existing functionality (e.g., plain text copying, HTML/RTF formats). The logic in `_SerializeRow` is intricate, involving state tracking across rows (`previousTextAttr`, `delayedLineBreak`) and handling various text attributes and escape sequences. This level of detail, combined with the need to modify multiple parts of the codebase, pushes the difficulty into the \"Hard\" category. However, it does not reach \"Very Hard\" (0.8-1.0) because it does not involve system-level changes, advanced algorithms, or highly specialized domain knowledge beyond terminal emulation.\n\nIn summary, the problem requires significant technical expertise, careful handling of edge cases, and modifications across multiple files, justifying a difficulty score of 0.65.\n", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
{"problem_statement": "Ability to save selected text as a `sendInput` action\nI write some long command. I need to use this frequently (or infrequently), but I don't want to have to remember all the args. I want to be able to pull it up straight from the command palette. So I want to write the command once, select it, and {perform some action}[^1] that lets me save it as a `sendInput` action.\r\n\r\nThe action should\r\n* immediately save it.\r\n* provide a UI[^2] for immediately editing[^3] the name, contents of this action, because `Send \"git log --graph --abbrev-commit --decorate...\" to the Terminal` is not useful to anyone.\r\n\r\nJust doing the immediate save would be a good enough start on this, to the point I'd consider that an easy starter. The UI - that's **H**ard, for reasons listed below. \r\n\r\n\r\n> **Note**\r\n> ## Walkthrough\r\n\r\nAs an initial version of this, it's more than good enough to just save the selected text as an action without the UI. We can iterate on the UI in follow-ups. \r\n\r\n* Probably start with something like [`dev/migrie/fhl/save-command`](https://github.com/microsoft/terminal/compare/6f5b9fb...1cde67ac466e19394eea1eb3a41405513d160a6f)\r\n* We probably want to skip all the `AppCommandlineArgs` stuff for now. That's spicier.\r\n* in `TerminalPage::_HandleSaveTask`, we will want to try and save the current selection as a `sendInput` action, if there's no `commandline` specified. \r\n* AppActionHandlers.cpp has plenty of examples of getting the active control. Should be easy enough to get the selected text from it. \r\n* We'll probably want to generate the name of this action (without a commandline) as \"Save Task...\"\r\n* Over and above: It would be valuable to `Toast` the user with a message \"Saved selected text as a new action\".  `TerminalPage::IdentifyWindow` has an example of a `Toast`\r\n\r\n[^1]: Obviously, easiest way is via cmdpal or keybinding. Also consider a right-click context menu entry, #3337\r\n\r\n[^2]: This has it's own challenges. It can't be a `ContentDialog` (https://github.com/microsoft/microsoft-ui-xaml/issues/3804). It could be nested in a `Flyout`, maybe. Hopefully the dialog thing is limited just to ContentDialogs and not all Flyouts. It probably shouldn't be a `TeachingTip` (#12798). We _could_ roll our own ContentDialog for this of course (#11308).\r\n\r\n[^3]: Might be tricky - we'd have to hand on to an instance of the actual `Command` itself, so we can edit it... in place? and hopefully writing to the settings would then just refresh all the other name->command maps instantly.\n", "patch": "diff --git a/src/cascadia/TerminalApp/AppActionHandlers.cpp b/src/cascadia/TerminalApp/AppActionHandlers.cpp\nindex 724f7dafb70..ac01af8cb3b 100644\n--- a/src/cascadia/TerminalApp/AppActionHandlers.cpp\n+++ b/src/cascadia/TerminalApp/AppActionHandlers.cpp\n@@ -1264,6 +1264,113 @@ namespace winrt::TerminalApp::implementation\n         }\r\n     }\r\n \r\n+    void TerminalPage::_HandleSaveSnippet(const IInspectable& /*sender*/,\r\n+                                          const ActionEventArgs& args)\r\n+    {\r\n+        if constexpr (!Feature_SaveSnippet::IsEnabled())\r\n+        {\r\n+            return;\r\n+        }\r\n+\r\n+        if (args)\r\n+        {\r\n+            if (const auto& realArgs = args.ActionArgs().try_as<SaveSnippetArgs>())\r\n+            {\r\n+                auto commandLine = realArgs.Commandline();\r\n+                if (commandLine.empty())\r\n+                {\r\n+                    if (const auto termControl{ _GetActiveControl() })\r\n+                    {\r\n+                        if (termControl.HasSelection())\r\n+                        {\r\n+                            const auto selections{ termControl.SelectedText(true) };\r\n+                            const auto selection = std::accumulate(selections.begin(), selections.end(), std::wstring());\r\n+                            commandLine = selection;\r\n+                        }\r\n+                    }\r\n+                }\r\n+\r\n+                if (commandLine.empty())\r\n+                {\r\n+                    ActionSaveFailed(L\"CommandLine is Required\");\r\n+                    return;\r\n+                }\r\n+\r\n+                try\r\n+                {\r\n+                    KeyChord keyChord = nullptr;\r\n+                    if (!realArgs.KeyChord().empty())\r\n+                    {\r\n+                        keyChord = KeyChordSerialization::FromString(winrt::to_hstring(realArgs.KeyChord()));\r\n+                    }\r\n+                    _settings.GlobalSettings().ActionMap().AddSendInputAction(realArgs.Name(), commandLine, keyChord);\r\n+                    _settings.WriteSettingsToDisk();\r\n+                    ActionSaved(commandLine, realArgs.Name(), realArgs.KeyChord());\r\n+                }\r\n+                catch (const winrt::hresult_error& ex)\r\n+                {\r\n+                    auto code = ex.code();\r\n+                    auto message = ex.message();\r\n+                    ActionSaveFailed(message);\r\n+                    args.Handled(true);\r\n+                    return;\r\n+                }\r\n+\r\n+                args.Handled(true);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    void TerminalPage::ActionSaved(winrt::hstring input, winrt::hstring name, winrt::hstring keyChord)\r\n+    {\r\n+        // If we haven't ever loaded the TeachingTip, then do so now and\r\n+        // create the toast for it.\r\n+        if (_actionSavedToast == nullptr)\r\n+        {\r\n+            if (auto tip{ FindName(L\"ActionSavedToast\").try_as<MUX::Controls::TeachingTip>() })\r\n+            {\r\n+                _actionSavedToast = std::make_shared<Toast>(tip);\r\n+                // Make sure to use the weak ref when setting up this\r\n+                // callback.\r\n+                tip.Closed({ get_weak(), &TerminalPage::_FocusActiveControl });\r\n+            }\r\n+        }\r\n+        _UpdateTeachingTipTheme(ActionSavedToast().try_as<winrt::Windows::UI::Xaml::FrameworkElement>());\r\n+\r\n+        SavedActionName(name);\r\n+        SavedActionKeyChord(keyChord);\r\n+        SavedActionCommandLine(input);\r\n+\r\n+        if (_actionSavedToast != nullptr)\r\n+        {\r\n+            _actionSavedToast->Open();\r\n+        }\r\n+    }\r\n+\r\n+    void TerminalPage::ActionSaveFailed(winrt::hstring message)\r\n+    {\r\n+        // If we haven't ever loaded the TeachingTip, then do so now and\r\n+        // create the toast for it.\r\n+        if (_actionSaveFailedToast == nullptr)\r\n+        {\r\n+            if (auto tip{ FindName(L\"ActionSaveFailedToast\").try_as<MUX::Controls::TeachingTip>() })\r\n+            {\r\n+                _actionSaveFailedToast = std::make_shared<Toast>(tip);\r\n+                // Make sure to use the weak ref when setting up this\r\n+                // callback.\r\n+                tip.Closed({ get_weak(), &TerminalPage::_FocusActiveControl });\r\n+            }\r\n+        }\r\n+        _UpdateTeachingTipTheme(ActionSaveFailedToast().try_as<winrt::Windows::UI::Xaml::FrameworkElement>());\r\n+\r\n+        ActionSaveFailedMessage().Text(message);\r\n+\r\n+        if (_actionSaveFailedToast != nullptr)\r\n+        {\r\n+            _actionSaveFailedToast->Open();\r\n+        }\r\n+    }\r\n+\r\n     void TerminalPage::_HandleSelectCommand(const IInspectable& /*sender*/,\r\n                                             const ActionEventArgs& args)\r\n     {\r\ndiff --git a/src/cascadia/TerminalApp/AppCommandlineArgs.cpp b/src/cascadia/TerminalApp/AppCommandlineArgs.cpp\nindex b7a6b581a05..c1154f56728 100644\n--- a/src/cascadia/TerminalApp/AppCommandlineArgs.cpp\n+++ b/src/cascadia/TerminalApp/AppCommandlineArgs.cpp\n@@ -209,6 +209,7 @@ void AppCommandlineArgs::_buildParser()\n     _buildMovePaneParser();\r\n     _buildSwapPaneParser();\r\n     _buildFocusPaneParser();\r\n+    _buildSaveSnippetParser();\r\n }\r\n \r\n // Method Description:\r\n@@ -537,6 +538,72 @@ void AppCommandlineArgs::_buildFocusPaneParser()\n     setupSubcommand(_focusPaneShort);\r\n }\r\n \r\n+void AppCommandlineArgs::_buildSaveSnippetParser()\r\n+{\r\n+    _saveCommand = _app.add_subcommand(\"x-save-snippet\", RS_A(L\"SaveSnippetDesc\"));\r\n+\r\n+    auto setupSubcommand = [this](auto* subcommand) {\r\n+        subcommand->add_option(\"--name,-n\", _saveInputName, RS_A(L\"SaveSnippetArgDesc\"));\r\n+        subcommand->add_option(\"--keychord,-k\", _keyChordOption, RS_A(L\"KeyChordArgDesc\"));\r\n+        subcommand->add_option(\"command,\", _commandline, RS_A(L\"CmdCommandArgDesc\"));\r\n+        subcommand->positionals_at_end(true);\r\n+\r\n+        // When ParseCommand is called, if this subcommand was provided, this\r\n+        // callback function will be triggered on the same thread. We can be sure\r\n+        // that `this` will still be safe - this function just lets us know this\r\n+        // command was parsed.\r\n+        subcommand->callback([&, this]() {\r\n+            // Build the action from the values we've parsed on the commandline.\r\n+            ActionAndArgs saveSnippet{};\r\n+            saveSnippet.Action(ShortcutAction::SaveSnippet);\r\n+            // First, parse out the commandline in the same way that\r\n+            // _getNewTerminalArgs does it\r\n+            SaveSnippetArgs args{};\r\n+\r\n+            if (!_commandline.empty())\r\n+            {\r\n+                std::ostringstream cmdlineBuffer;\r\n+\r\n+                for (const auto& arg : _commandline)\r\n+                {\r\n+                    if (cmdlineBuffer.tellp() != 0)\r\n+                    {\r\n+                        // If there's already something in here, prepend a space\r\n+                        cmdlineBuffer << ' ';\r\n+                    }\r\n+\r\n+                    if (arg.find(\" \") != std::string::npos)\r\n+                    {\r\n+                        cmdlineBuffer << '\"' << arg << '\"';\r\n+                    }\r\n+                    else\r\n+                    {\r\n+                        cmdlineBuffer << arg;\r\n+                    }\r\n+                }\r\n+\r\n+                args.Commandline(winrt::to_hstring(cmdlineBuffer.str()));\r\n+            }\r\n+\r\n+            if (!_keyChordOption.empty())\r\n+            {\r\n+                args.KeyChord(winrt::to_hstring(_keyChordOption));\r\n+            }\r\n+\r\n+            if (!_saveInputName.empty())\r\n+            {\r\n+                winrt::hstring hString = winrt::to_hstring(_saveInputName);\r\n+                args.Name(hString);\r\n+            }\r\n+\r\n+            saveSnippet.Args(args);\r\n+            _startupActions.push_back(saveSnippet);\r\n+        });\r\n+    };\r\n+\r\n+    setupSubcommand(_saveCommand);\r\n+}\r\n+\r\n // Method Description:\r\n // - Add the `NewTerminalArgs` parameters to the given subcommand. This enables\r\n //   that subcommand to support all the properties in a NewTerminalArgs.\r\n@@ -710,7 +777,8 @@ bool AppCommandlineArgs::_noCommandsProvided()\n              *_focusPaneCommand ||\r\n              *_focusPaneShort ||\r\n              *_newPaneShort.subcommand ||\r\n-             *_newPaneCommand.subcommand);\r\n+             *_newPaneCommand.subcommand ||\r\n+             *_saveCommand);\r\n }\r\n \r\n // Method Description:\r\ndiff --git a/src/cascadia/TerminalApp/AppCommandlineArgs.h b/src/cascadia/TerminalApp/AppCommandlineArgs.h\nindex 7eb5a34f93d..7eb2516bb38 100644\n--- a/src/cascadia/TerminalApp/AppCommandlineArgs.h\n+++ b/src/cascadia/TerminalApp/AppCommandlineArgs.h\n@@ -93,6 +93,7 @@ class TerminalApp::AppCommandlineArgs final\n     CLI::App* _swapPaneCommand;\r\n     CLI::App* _focusPaneCommand;\r\n     CLI::App* _focusPaneShort;\r\n+    CLI::App* _saveCommand;\r\n \r\n     // Are you adding a new sub-command? Make sure to update _noCommandsProvided!\r\n \r\n@@ -123,6 +124,8 @@ class TerminalApp::AppCommandlineArgs final\n     bool _focusPrevTab{ false };\r\n \r\n     int _focusPaneTarget{ -1 };\r\n+    std::string _saveInputName;\r\n+    std::string _keyChordOption;\r\n     // Are you adding more args here? Make sure to reset them in _resetStateToDefault\r\n \r\n     const Commandline* _currentCommandline{ nullptr };\r\n@@ -141,6 +144,7 @@ class TerminalApp::AppCommandlineArgs final\n     winrt::Microsoft::Terminal::Settings::Model::NewTerminalArgs _getNewTerminalArgs(NewTerminalSubcommand& subcommand);\r\n     void _addNewTerminalArgs(NewTerminalSubcommand& subcommand);\r\n     void _buildParser();\r\n+    void _buildSaveSnippetParser();\r\n     void _buildNewTabParser();\r\n     void _buildSplitPaneParser();\r\n     void _buildFocusTabParser();\r\ndiff --git a/src/cascadia/TerminalApp/Resources/en-US/Resources.resw b/src/cascadia/TerminalApp/Resources/en-US/Resources.resw\nindex 15b79c40ffc..efe3e1278e2 100644\n--- a/src/cascadia/TerminalApp/Resources/en-US/Resources.resw\n+++ b/src/cascadia/TerminalApp/Resources/en-US/Resources.resw\n@@ -288,6 +288,15 @@\n   <data name=\"CmdCommandArgDesc\" xml:space=\"preserve\">\r\n     <value>An optional command, with arguments, to be spawned in the new tab or pane</value>\r\n   </data>\r\n+  <data name=\"SaveSnippetDesc\" xml:space=\"preserve\">\r\n+    <value>Save command line as input action</value>\r\n+  </data>\r\n+  <data name=\"SaveSnippetArgDesc\" xml:space=\"preserve\">\r\n+    <value>An optional argument</value>\r\n+  </data>\r\n+  <data name=\"KeyChordArgDesc\" xml:space=\"preserve\">\r\n+    <value>An optional argument</value>\r\n+  </data>\r\n   <data name=\"CmdFocusTabDesc\" xml:space=\"preserve\">\r\n     <value>Move focus to another tab</value>\r\n   </data>\r\n@@ -898,4 +907,10 @@\n   <data name=\"RestartConnectionToolTip\" xml:space=\"preserve\">\r\n     <value>Restart the active pane connection</value>\r\n   </data>\r\n+  <data name=\"ActionSavedToast.Title\" xml:space=\"preserve\">\r\n+    <value>Action saved</value>\r\n+  </data>\r\n+  <data name=\"ActionSaveFailedToast.Title\" xml:space=\"preserve\">\r\n+    <value>Action save failed</value>\r\n+  </data>\r\n </root>\r\ndiff --git a/src/cascadia/TerminalApp/TerminalAppLib.vcxproj b/src/cascadia/TerminalApp/TerminalAppLib.vcxproj\nindex d0629da8036..238fecf9afc 100644\n--- a/src/cascadia/TerminalApp/TerminalAppLib.vcxproj\n+++ b/src/cascadia/TerminalApp/TerminalAppLib.vcxproj\n@@ -357,7 +357,9 @@\n   </ItemGroup>\r\n   <!-- ========================= Misc Files ======================== -->\r\n   <ItemGroup>\r\n-    <PRIResource Include=\"Resources\\en-US\\Resources.resw\" />\r\n+    <PRIResource Include=\"Resources\\en-US\\Resources.resw\">\r\n+      <SubType>Designer</SubType>\r\n+    </PRIResource>\r\n     <PRIResource Include=\"Resources\\en-US\\ContextMenu.resw\" />\r\n     <OCResourceDirectory Include=\"Resources\" />\r\n   </ItemGroup>\r\n@@ -466,10 +468,8 @@\n   </ItemDefinitionGroup>\r\n   <!-- ========================= Globals ======================== -->\r\n   <Import Project=\"$(OpenConsoleDir)src\\cppwinrt.build.post.props\" />\r\n-\r\n   <!-- This -must- go after cppwinrt.build.post.props because that includes many VS-provided props including appcontainer.common.props, which stomps on what cppwinrt.targets did. -->\r\n   <Import Project=\"$(OpenConsoleDir)src\\common.nugetversions.targets\" />\r\n-\r\n   <!--\r\n     By default, the PRI file will contain resource paths beginning with the\r\n     project name. Since we enabled XBF embedding, this *also* includes App.xbf.\r\n@@ -490,4 +490,4 @@\n     </ItemGroup>\r\n   </Target>\r\n   <Import Project=\"$(SolutionDir)build\\rules\\CollectWildcardResources.targets\" />\r\n-</Project>\r\n+</Project>\n\\ No newline at end of file\ndiff --git a/src/cascadia/TerminalApp/TerminalPage.h b/src/cascadia/TerminalApp/TerminalPage.h\nindex 0a6f5d70957..07dbf173242 100644\n--- a/src/cascadia/TerminalApp/TerminalPage.h\n+++ b/src/cascadia/TerminalApp/TerminalPage.h\n@@ -146,6 +146,8 @@ namespace winrt::TerminalApp::implementation\n         winrt::hstring KeyboardServiceDisabledText();\n \n         winrt::fire_and_forget IdentifyWindow();\n+        void ActionSaved(winrt::hstring input, winrt::hstring name, winrt::hstring keyChord);\n+        void ActionSaveFailed(winrt::hstring message);\n         winrt::fire_and_forget RenameFailed();\n         winrt::fire_and_forget ShowTerminalWorkingDirectory();\n \n@@ -199,6 +201,10 @@ namespace winrt::TerminalApp::implementation\n         WINRT_OBSERVABLE_PROPERTY(winrt::Windows::UI::Xaml::Media::Brush, TitlebarBrush, PropertyChanged.raise, nullptr);\n         WINRT_OBSERVABLE_PROPERTY(winrt::Windows::UI::Xaml::Media::Brush, FrameBrush, PropertyChanged.raise, nullptr);\n \n+        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, SavedActionName, PropertyChanged.raise, L\"\");\n+        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, SavedActionKeyChord, PropertyChanged.raise, L\"\");\n+        WINRT_OBSERVABLE_PROPERTY(winrt::hstring, SavedActionCommandLine, PropertyChanged.raise, L\"\");\n+\n     private:\n         friend struct TerminalPageT<TerminalPage>; // for Xaml to bind events\n         std::optional<HWND> _hostingHwnd;\n@@ -258,6 +264,8 @@ namespace winrt::TerminalApp::implementation\n         bool _isEmbeddingInboundListener{ false };\n \n         std::shared_ptr<Toast> _windowIdToast{ nullptr };\n+        std::shared_ptr<Toast> _actionSavedToast{ nullptr };\n+        std::shared_ptr<Toast> _actionSaveFailedToast{ nullptr };\n         std::shared_ptr<Toast> _windowRenameFailedToast{ nullptr };\n         std::shared_ptr<Toast> _windowCwdToast{ nullptr };\n \ndiff --git a/src/cascadia/TerminalApp/TerminalPage.idl b/src/cascadia/TerminalApp/TerminalPage.idl\nindex 667350056b8..9e272351406 100644\n--- a/src/cascadia/TerminalApp/TerminalPage.idl\n+++ b/src/cascadia/TerminalApp/TerminalPage.idl\n@@ -72,6 +72,10 @@ namespace TerminalApp\n         void IdentifyWindow();\n         void RenameFailed();\n \n+        String SavedActionName { get; };\n+        String SavedActionKeyChord { get; };\n+        String SavedActionCommandLine { get; };\n+\n         // We cannot use the default XAML APIs because we want to make sure\n         // that there's only one application-global dialog visible at a time,\n         // and because of GH#5224.\ndiff --git a/src/cascadia/TerminalApp/TerminalPage.xaml b/src/cascadia/TerminalApp/TerminalPage.xaml\nindex c8aa837bf82..ce6fc576071 100644\n--- a/src/cascadia/TerminalApp/TerminalPage.xaml\n+++ b/src/cascadia/TerminalApp/TerminalPage.xaml\n@@ -8,6 +8,7 @@\n       xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\r\n       xmlns:local=\"using:TerminalApp\"\r\n       xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\r\n+      xmlns:mtu=\"using:Microsoft.Terminal.UI\"\r\n       xmlns:mux=\"using:Microsoft.UI.Xaml.Controls\"\r\n       Background=\"Transparent\"\r\n       mc:Ignorable=\"d\">\r\n@@ -204,5 +205,43 @@\n                          Title=\"{x:Bind WindowProperties.VirtualWorkingDirectory, Mode=OneWay}\"\r\n                          x:Load=\"False\"\r\n                          IsLightDismissEnabled=\"True\" />\r\n+\r\n+        <mux:TeachingTip x:Name=\"ActionSavedToast\"\r\n+                         x:Uid=\"ActionSavedToast\"\r\n+                         Title=\"Action Saved\"\r\n+                         HorizontalAlignment=\"Stretch\"\r\n+                         x:Load=\"False\"\r\n+                         IsLightDismissEnabled=\"True\">\r\n+            <mux:TeachingTip.Content>\r\n+                <StackPanel HorizontalAlignment=\"Stretch\"\r\n+                            Orientation=\"Vertical\">\r\n+                    <TextBlock x:Name=\"ActionSavedNameText\"\r\n+                               Visibility=\"{x:Bind mtu:Converters.StringNotEmptyToVisibility(SavedActionName), Mode=OneWay}\">\r\n+                        <Run Text=\"Name: \" />\r\n+                        <Run Text=\"{x:Bind SavedActionName, Mode=OneWay}\" />\r\n+                    </TextBlock>\r\n+                    <TextBlock x:Name=\"ActionSavedKeyChordText\"\r\n+                               Visibility=\"{x:Bind mtu:Converters.StringNotEmptyToVisibility(SavedActionKeyChord), Mode=OneWay}\">\r\n+                        <Run Text=\"Key Chord: \" />\r\n+                        <Run Text=\"{x:Bind SavedActionKeyChord, Mode=OneWay}\" />\r\n+                    </TextBlock>\r\n+                    <TextBlock x:Name=\"ActionSavedCommandLineText\"\r\n+                               Visibility=\"{x:Bind mtu:Converters.StringNotEmptyToVisibility(SavedActionCommandLine), Mode=OneWay}\">\r\n+                        <Run Text=\"Input: \" />\r\n+                        <Run Text=\"{x:Bind SavedActionCommandLine, Mode=OneWay}\" />\r\n+                    </TextBlock>\r\n+                </StackPanel>\r\n+            </mux:TeachingTip.Content>\r\n+        </mux:TeachingTip>\r\n+        <mux:TeachingTip x:Name=\"ActionSaveFailedToast\"\r\n+                         x:Uid=\"ActionSaveFailedToast\"\r\n+                         Title=\"Action Save Failed\"\r\n+                         x:Load=\"False\"\r\n+                         IsLightDismissEnabled=\"True\">\r\n+            <mux:TeachingTip.Content>\r\n+                <TextBlock x:Name=\"ActionSaveFailedMessage\"\r\n+                           Text=\"\" />\r\n+            </mux:TeachingTip.Content>\r\n+        </mux:TeachingTip>\r\n     </Grid>\r\n </Page>\r\ndiff --git a/src/cascadia/TerminalSettingsModel/ActionAndArgs.cpp b/src/cascadia/TerminalSettingsModel/ActionAndArgs.cpp\nindex 7bba13bc4cc..9b2ef821f58 100644\n--- a/src/cascadia/TerminalSettingsModel/ActionAndArgs.cpp\n+++ b/src/cascadia/TerminalSettingsModel/ActionAndArgs.cpp\n@@ -52,6 +52,7 @@ static constexpr std::string_view SwitchToTabKey{ \"switchToTab\" };\n static constexpr std::string_view TabSearchKey{ \"tabSearch\" };\n static constexpr std::string_view ToggleAlwaysOnTopKey{ \"toggleAlwaysOnTop\" };\n static constexpr std::string_view ToggleCommandPaletteKey{ \"commandPalette\" };\n+static constexpr std::string_view SaveSnippetKey{ \"experimental.saveSnippet\" };\n static constexpr std::string_view SuggestionsKey{ \"showSuggestions\" };\n static constexpr std::string_view ToggleFocusModeKey{ \"toggleFocusMode\" };\n static constexpr std::string_view SetFocusModeKey{ \"setFocusMode\" };\n@@ -389,6 +390,7 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n                 { ShortcutAction::TabSearch, RS_(L\"TabSearchCommandKey\") },\n                 { ShortcutAction::ToggleAlwaysOnTop, RS_(L\"ToggleAlwaysOnTopCommandKey\") },\n                 { ShortcutAction::ToggleCommandPalette, MustGenerate },\n+                { ShortcutAction::SaveSnippet, MustGenerate },\n                 { ShortcutAction::Suggestions, MustGenerate },\n                 { ShortcutAction::ToggleFocusMode, RS_(L\"ToggleFocusModeCommandKey\") },\n                 { ShortcutAction::SetFocusMode, MustGenerate },\ndiff --git a/src/cascadia/TerminalSettingsModel/ActionArgs.cpp b/src/cascadia/TerminalSettingsModel/ActionArgs.cpp\nindex 24f4e445953..d018b6019e4 100644\n--- a/src/cascadia/TerminalSettingsModel/ActionArgs.cpp\n+++ b/src/cascadia/TerminalSettingsModel/ActionArgs.cpp\n@@ -33,6 +33,7 @@\n #include \"ScrollToMarkArgs.g.cpp\"\r\n #include \"AddMarkArgs.g.cpp\"\r\n #include \"FindMatchArgs.g.cpp\"\r\n+#include \"SaveSnippetArgs.g.cpp\"\r\n #include \"ToggleCommandPaletteArgs.g.cpp\"\r\n #include \"SuggestionsArgs.g.cpp\"\r\n #include \"NewWindowArgs.g.cpp\"\r\n@@ -947,6 +948,29 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n         }\r\n     }\r\n \r\n+    winrt::hstring SaveSnippetArgs::GenerateName() const\r\n+    {\r\n+        if (Feature_SaveSnippet::IsEnabled())\r\n+        {\r\n+            std::wstringstream ss;\r\n+\r\n+            ss << RS_(L\"SaveSnippetNamePrefix\").c_str() << L\" commandline: \" << Commandline().c_str();\r\n+\r\n+            if (!Name().empty())\r\n+            {\r\n+                ss << L\", name: \" << Name().c_str();\r\n+            }\r\n+\r\n+            if (!KeyChord().empty())\r\n+            {\r\n+                ss << L\", keyChord \" << KeyChord().c_str();\r\n+            }\r\n+\r\n+            return winrt::hstring{ ss.str() };\r\n+        }\r\n+        return L\"\";\r\n+    }\r\n+\r\n     static winrt::hstring _FormatColorString(const Control::SelectionColor& selectionColor)\r\n     {\r\n         if (!selectionColor)\r\ndiff --git a/src/cascadia/TerminalSettingsModel/ActionArgs.h b/src/cascadia/TerminalSettingsModel/ActionArgs.h\nindex ae3d7d50029..84c23dd2d7d 100644\n--- a/src/cascadia/TerminalSettingsModel/ActionArgs.h\n+++ b/src/cascadia/TerminalSettingsModel/ActionArgs.h\n@@ -34,6 +34,7 @@\n #include \"ScrollToMarkArgs.g.h\"\r\n #include \"AddMarkArgs.g.h\"\r\n #include \"MoveTabArgs.g.h\"\r\n+#include \"SaveSnippetArgs.g.h\"\r\n #include \"ToggleCommandPaletteArgs.g.h\"\r\n #include \"SuggestionsArgs.g.h\"\r\n #include \"FindMatchArgs.g.h\"\r\n@@ -215,6 +216,12 @@ protected:                                                                  \\\n #define TOGGLE_COMMAND_PALETTE_ARGS(X) \\\r\n     X(CommandPaletteLaunchMode, LaunchMode, \"launchMode\", false, CommandPaletteLaunchMode::Action)\r\n \r\n+////////////////////////////////////////////////////////////////////////////////\r\n+#define SAVE_TASK_ARGS(X)                                                           \\\r\n+    X(winrt::hstring, Name, \"name\", false, L\"\")                                     \\\r\n+    X(winrt::hstring, Commandline, \"commandline\", args->Commandline().empty(), L\"\") \\\r\n+    X(winrt::hstring, KeyChord, \"keyChord\", false, L\"\")\r\n+\r\n ////////////////////////////////////////////////////////////////////////////////\r\n #define SUGGESTIONS_ARGS(X)                                                 \\\r\n     X(SuggestionsSource, Source, \"source\", false, SuggestionsSource::Tasks) \\\r\n@@ -819,6 +826,8 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n \r\n     ACTION_ARGS_STRUCT(ToggleCommandPaletteArgs, TOGGLE_COMMAND_PALETTE_ARGS);\r\n \r\n+    ACTION_ARGS_STRUCT(SaveSnippetArgs, SAVE_TASK_ARGS);\r\n+\r\n     ACTION_ARGS_STRUCT(SuggestionsArgs, SUGGESTIONS_ARGS);\r\n \r\n     ACTION_ARGS_STRUCT(FindMatchArgs, FIND_MATCH_ARGS);\r\n@@ -941,6 +950,7 @@ namespace winrt::Microsoft::Terminal::Settings::Model::factory_implementation\n     BASIC_FACTORY(CloseTabArgs);\r\n     BASIC_FACTORY(MoveTabArgs);\r\n     BASIC_FACTORY(OpenSettingsArgs);\r\n+    BASIC_FACTORY(SaveSnippetArgs);\r\n     BASIC_FACTORY(FindMatchArgs);\r\n     BASIC_FACTORY(NewWindowArgs);\r\n     BASIC_FACTORY(FocusPaneArgs);\r\ndiff --git a/src/cascadia/TerminalSettingsModel/ActionArgs.idl b/src/cascadia/TerminalSettingsModel/ActionArgs.idl\nindex 5992f2d5217..02f0c4d0413 100644\n--- a/src/cascadia/TerminalSettingsModel/ActionArgs.idl\n+++ b/src/cascadia/TerminalSettingsModel/ActionArgs.idl\n@@ -357,6 +357,15 @@ namespace Microsoft.Terminal.Settings.Model\n         FindMatchDirection Direction { get; };\r\n     };\r\n \r\n+    [default_interface] runtimeclass SaveSnippetArgs : IActionArgs\r\n+    {\r\n+        SaveSnippetArgs();\r\n+        SaveSnippetArgs(String Name, String Commandline, String KeyChord);\r\n+        String Name;\r\n+        String Commandline;\r\n+        String KeyChord;\r\n+    };\r\n+\r\n     [default_interface] runtimeclass NewWindowArgs : IActionArgs\r\n     {\r\n         NewWindowArgs(INewContentArgs contentArgs);\r\ndiff --git a/src/cascadia/TerminalSettingsModel/ActionMap.cpp b/src/cascadia/TerminalSettingsModel/ActionMap.cpp\nindex 4468014c5a8..86a88c36858 100644\n--- a/src/cascadia/TerminalSettingsModel/ActionMap.cpp\n+++ b/src/cascadia/TerminalSettingsModel/ActionMap.cpp\n@@ -882,6 +882,22 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n         return results;\r\n     }\r\n \r\n+    void ActionMap::AddSendInputAction(winrt::hstring name, winrt::hstring input, const Control::KeyChord keys)\r\n+    {\r\n+        auto newAction = winrt::make<ActionAndArgs>();\r\n+        newAction.Action(ShortcutAction::SendInput);\r\n+        auto sendInputArgs = winrt::make<SendInputArgs>(input);\r\n+        newAction.Args(sendInputArgs);\r\n+        auto cmd{ make_self<Command>() };\r\n+        if (!name.empty())\r\n+        {\r\n+            cmd->Name(name);\r\n+        }\r\n+        cmd->ActionAndArgs(newAction);\r\n+        cmd->GenerateID();\r\n+        AddAction(*cmd, keys);\r\n+    }\r\n+\r\n     IVector<Model::Command> ActionMap::FilterToSendInput(\r\n         winrt::hstring currentCommandline)\r\n     {\r\ndiff --git a/src/cascadia/TerminalSettingsModel/ActionMap.h b/src/cascadia/TerminalSettingsModel/ActionMap.h\nindex 2b815214dcb..22428ee5eda 100644\n--- a/src/cascadia/TerminalSettingsModel/ActionMap.h\n+++ b/src/cascadia/TerminalSettingsModel/ActionMap.h\n@@ -78,6 +78,7 @@ namespace winrt::Microsoft::Terminal::Settings::Model::implementation\n         bool RebindKeys(const Control::KeyChord& oldKeys, const Control::KeyChord& newKeys);\r\n         void DeleteKeyBinding(const Control::KeyChord& keys);\r\n         void RegisterKeyBinding(Control::KeyChord keys, Model::ActionAndArgs action);\r\n+        void AddSendInputAction(winrt::hstring name, winrt::hstring input, const Control::KeyChord keys);\r\n \r\n         Windows::Foundation::Collections::IVector<Model::Command> ExpandedCommands();\r\n         void ExpandCommands(const Windows::Foundation::Collections::IVectorView<Model::Profile>& profiles,\r\ndiff --git a/src/cascadia/TerminalSettingsModel/ActionMap.idl b/src/cascadia/TerminalSettingsModel/ActionMap.idl\nindex 594872f6b70..1849e0680a4 100644\n--- a/src/cascadia/TerminalSettingsModel/ActionMap.idl\n+++ b/src/cascadia/TerminalSettingsModel/ActionMap.idl\n@@ -31,5 +31,6 @@ namespace Microsoft.Terminal.Settings.Model\n         void DeleteKeyBinding(Microsoft.Terminal.Control.KeyChord keys);\r\n \r\n         void RegisterKeyBinding(Microsoft.Terminal.Control.KeyChord keys, ActionAndArgs action);\r\n+        void AddSendInputAction(String name, String input, Microsoft.Terminal.Control.KeyChord keys);\r\n     }\r\n }\r\ndiff --git a/src/cascadia/TerminalSettingsModel/AllShortcutActions.h b/src/cascadia/TerminalSettingsModel/AllShortcutActions.h\nindex 28ba4281e69..86ff9d49c9b 100644\n--- a/src/cascadia/TerminalSettingsModel/AllShortcutActions.h\n+++ b/src/cascadia/TerminalSettingsModel/AllShortcutActions.h\n@@ -75,6 +75,7 @@\n     ON_ALL_ACTIONS(CloseTabsAfter)          \\\r\n     ON_ALL_ACTIONS(TabSearch)               \\\r\n     ON_ALL_ACTIONS(MoveTab)                 \\\r\n+    ON_ALL_ACTIONS(SaveSnippet)             \\\r\n     ON_ALL_ACTIONS(BreakIntoDebugger)       \\\r\n     ON_ALL_ACTIONS(TogglePaneReadOnly)      \\\r\n     ON_ALL_ACTIONS(EnablePaneReadOnly)      \\\r\n@@ -148,6 +149,7 @@\n     ON_ALL_ACTIONS_WITH_ARGS(SplitPane)            \\\r\n     ON_ALL_ACTIONS_WITH_ARGS(SwitchToTab)          \\\r\n     ON_ALL_ACTIONS_WITH_ARGS(ToggleCommandPalette) \\\r\n+    ON_ALL_ACTIONS_WITH_ARGS(SaveSnippet)          \\\r\n     ON_ALL_ACTIONS_WITH_ARGS(FocusPane)            \\\r\n     ON_ALL_ACTIONS_WITH_ARGS(ExportBuffer)         \\\r\n     ON_ALL_ACTIONS_WITH_ARGS(ClearBuffer)          \\\r\ndiff --git a/src/cascadia/TerminalSettingsModel/Resources/en-US/Resources.resw b/src/cascadia/TerminalSettingsModel/Resources/en-US/Resources.resw\nindex 6179099bdf5..b65b7eabcd4 100644\n--- a/src/cascadia/TerminalSettingsModel/Resources/en-US/Resources.resw\n+++ b/src/cascadia/TerminalSettingsModel/Resources/en-US/Resources.resw\n@@ -1,17 +1,17 @@\n <?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n <root>\r\n-  <!-- \r\n-    Microsoft ResX Schema \r\n-    \r\n+  <!--\r\n+    Microsoft ResX Schema\r\n+\r\n     Version 2.0\r\n-    \r\n-    The primary goals of this format is to allow a simple XML format \r\n-    that is mostly human readable. The generation and parsing of the \r\n-    various data types are done through the TypeConverter classes \r\n+\r\n+    The primary goals of this format is to allow a simple XML format\r\n+    that is mostly human readable. The generation and parsing of the\r\n+    various data types are done through the TypeConverter classes\r\n     associated with the data types.\r\n-    \r\n+\r\n     Example:\r\n-    \r\n+\r\n     ... ado.net/XML headers & schema ...\r\n     <resheader name=\"resmimetype\">text/microsoft-resx</resheader>\r\n     <resheader name=\"version\">2.0</resheader>\r\n@@ -26,36 +26,36 @@\n         <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>\r\n         <comment>This is a comment</comment>\r\n     </data>\r\n-                \r\n-    There are any number of \"resheader\" rows that contain simple \r\n+\r\n+    There are any number of \"resheader\" rows that contain simple\r\n     name/value pairs.\r\n-    \r\n-    Each data row contains a name, and value. The row also contains a \r\n-    type or mimetype. Type corresponds to a .NET class that support \r\n-    text/value conversion through the TypeConverter architecture. \r\n-    Classes that don't support this are serialized and stored with the \r\n+\r\n+    Each data row contains a name, and value. The row also contains a\r\n+    type or mimetype. Type corresponds to a .NET class that support\r\n+    text/value conversion through the TypeConverter architecture.\r\n+    Classes that don't support this are serialized and stored with the\r\n     mimetype set.\r\n-    \r\n-    The mimetype is used for serialized objects, and tells the \r\n-    ResXResourceReader how to depersist the object. This is currently not \r\n+\r\n+    The mimetype is used for serialized objects, and tells the\r\n+    ResXResourceReader how to depersist the object. This is currently not\r\n     extensible. For a given mimetype the value must be set accordingly:\r\n-    \r\n-    Note - application/x-microsoft.net.object.binary.base64 is the format \r\n-    that the ResXResourceWriter will generate, however the reader can \r\n+\r\n+    Note - application/x-microsoft.net.object.binary.base64 is the format\r\n+    that the ResXResourceWriter will generate, however the reader can\r\n     read any of the formats listed below.\r\n-    \r\n+\r\n     mimetype: application/x-microsoft.net.object.binary.base64\r\n-    value   : The object must be serialized with \r\n+    value   : The object must be serialized with\r\n             : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter\r\n             : and then encoded with base64 encoding.\r\n-    \r\n+\r\n     mimetype: application/x-microsoft.net.object.soap.base64\r\n-    value   : The object must be serialized with \r\n+    value   : The object must be serialized with\r\n             : System.Runtime.Serialization.Formatters.Soap.SoapFormatter\r\n             : and then encoded with base64 encoding.\r\n \r\n     mimetype: application/x-microsoft.net.object.bytearray.base64\r\n-    value   : The object must be serialized into a byte array \r\n+    value   : The object must be serialized into a byte array\r\n             : using a System.ComponentModel.TypeConverter\r\n             : and then encoded with base64 encoding.\r\n     -->\r\n@@ -727,4 +727,7 @@\n     <value>Open about dialog</value>\r\n     <comment>This will open the \"about\" dialog, to display version info and other documentation</comment>\r\n   </data>\r\n-</root>\n\\ No newline at end of file\n+  <data name=\"SaveSnippetNamePrefix\" xml:space=\"preserve\">\r\n+    <value>Save Snippet</value>\r\n+  </data>\r\n+</root>\r\ndiff --git a/src/features.xml b/src/features.xml\nindex 47d86790f9d..b87e09bb7c4 100644\n--- a/src/features.xml\n+++ b/src/features.xml\n@@ -155,6 +155,17 @@\n         </alwaysEnabledBrandingTokens>\r\n     </feature>\r\n \r\n+    <feature>\r\n+        <name>Feature_SaveSnippet</name>\r\n+        <description>Save Snippet</description>\r\n+        <id>9971</id>\r\n+        <stage>AlwaysDisabled</stage>\r\n+        <alwaysEnabledBrandingTokens>\r\n+            <brandingToken>Dev</brandingToken>\r\n+            <brandingToken>Canary</brandingToken>\r\n+        </alwaysEnabledBrandingTokens>\r\n+    </feature>\r\n+\r\n     <feature>\r\n         <name>Feature_QuickFix</name>\r\n         <description>Enables the Quick Fix menu</description>\r\n", "instance_id": "microsoft__terminal-16513", "clarity": 2, "difficulty": 0.55, "clarity_explanation": "\nThe problem statement is mostly clear in describing the goal of saving selected text as a `sendInput` action for reuse via a command palette or keybinding. It specifies the initial scope (immediate save of selected text) and mentions a more complex UI component as a follow-up, which is explicitly marked as hard. The statement provides some implementation hints, such as referencing specific files and methods (`TerminalPage::_HandleSaveTask`, `AppActionHandlers.cpp`) and suggesting a basic name generation for the action. However, there are minor ambiguities and missing details. For instance, it does not fully clarify how the saved action should integrate with existing systems (e.g., persistence mechanism details or conflict resolution with existing actions). Edge cases, such as handling empty selections or invalid input, are not explicitly addressed in the problem statement, though the code changes attempt to handle some of these. Additionally, the UI component's challenges are mentioned but not detailed beyond references to GitHub issues, leaving some uncertainty about the full scope of potential follow-ups. Overall, the statement is valid and mostly clear but lacks comprehensive coverage of edge cases and integration specifics.\n", "difficulty_explanation": "\nI assign a difficulty score of 0.55, placing this problem in the medium range, due to the following factors:\n\n1. **Scope and Depth of Code Changes**: The code changes span multiple files (`AppActionHandlers.cpp`, `AppCommandlineArgs.cpp`, `TerminalPage.h/.xaml/.idl`, and several settings/model files), indicating a moderate impact across the codebase. The modifications involve adding new functionality for saving snippets as actions, integrating with command-line parsing, updating UI elements (toasts), and extending the action map to support new `sendInput` actions. While the changes are not architecturally disruptive, they require understanding and modifying several interconnected components, including settings persistence and UI feedback mechanisms.\n\n2. **Number of Technical Concepts**: Solving this problem requires familiarity with several concepts, including C++ (with WinRT for Windows UI interactions), XAML for UI definitions, and the Microsoft Terminal's internal architecture (e.g., action handling, command palette integration, and settings model). Specific knowledge of the `TeachingTip` UI component for toast notifications, string handling in WinRT (`winrt::hstring`), and key chord serialization is necessary. Additionally, the feature flag system (`Feature_SaveSnippet`) and resource file management (`.resw`) are involved. While these concepts are not extremely advanced, their combination and the need to navigate a large, complex codebase increase the difficulty to a medium level.\n\n3. **Potential Edge Cases and Error Handling**: The code changes address some basic edge cases, such as checking for empty command lines or selections and handling save failures with a toast notification. However, the problem statement does not explicitly discuss edge cases like duplicate action names, invalid key chords, or selection text with special characters. The error handling implemented in the code (e.g., catching `winrt::hresult_error`) is straightforward but requires ensuring robustness across different user inputs and system states. The complexity of edge cases is moderate, as they are not deeply intricate but still require careful consideration.\n\n4. **Overall Complexity**: The initial implementation (saving selected text as an action) is relatively straightforward, as noted in the problem statement, and could be considered an \"easy starter.\" However, the provided code changes go beyond this by including command-line parsing, key chord support, and UI feedback via toasts, which add to the complexity. The problem also hints at future UI challenges (marked as hard), but since the current scope excludes this, I focus on the implemented functionality. The need to integrate with existing systems, modify multiple files, and ensure proper error handling pushes this into the medium difficulty range. It does not reach the hard range (0.6-0.8) because it does not involve deep architectural changes, complex algorithms, or significant performance considerations.\n\nIn summary, this problem requires a moderate level of expertise in C++ and WinRT, an understanding of multiple codebase components, and careful handling of basic edge cases, justifying a difficulty score of 0.55.\n", "clarity_label": -1, "difficulty_label": -1, "human_clarity": -1, "human_difficulty": -1}
