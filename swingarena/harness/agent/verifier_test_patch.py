from swebench.harness.constants.swing_constants import SwingbenchInstance

patch = SwingbenchInstance(repo='rustzx/rustzx', instance_id='rustzx__rustzx-60', base_commit='bbde543e33354c7748c655b9e77608998dfad259', patch='diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml\nindex 5f78e0b..93aaa56 100644\n--- a/.github/workflows/ci.yml\n+++ b/.github/workflows/ci.yml\n@@ -14,7 +14,7 @@ jobs:\n     runs-on: ${{ matrix.os }}\n     strategy:\n       matrix:\n-        os: [ubuntu-latest, windows-latest]\n+        os: [ubuntu-latest, windows-latest, macos-latest]\n     steps:\n       - uses: actions/checkout@v2\n       - uses: actions-rs/toolchain@v1\n@@ -38,6 +38,16 @@ jobs:\n         with:\n           command: build\n           args: --release --all --all-features --verbose\n+      - name: Lib build - Minimal\n+        uses: actions-rs/cargo@v1\n+        with:\n+          command: build\n+          args: --release -p rustzx-core --verbose\n+      - name: Lib build - Without AY\n+        uses: actions-rs/cargo@v1\n+        with:\n+          command: build\n+          args: --release -p rustzx-core --features without-ay --verbose\n       - name: Test\n         uses: actions-rs/cargo@v1\n         with:\ndiff --git a/CHANGELOG.md b/CHANGELOG.md\nnew file mode 100644\nindex 0000000..5a0e921\n--- /dev/null\n+++ b/CHANGELOG.md\n@@ -0,0 +1,78 @@\n+### RustZX v0.11\n+Authors:\n+- Vladyslav Nikonov (@pacmancoder)\n+\n+Changes:\n+- **[Feature]** Separated project to `rustzx` application and `no_std`-capable `rustzx-core` crate\n+- **[Feature]** Updated CLI\n+    - More features now enabled by default\n+    - File autodetect from CLI\n+    - Added configurable sound sample rate\n+    - Removed redundant args\n+- **[Dependencies]** Switched to bundled `sdl` crate mode, making build almost dependecy-free (CMake and C compiller are still requird)\n+- **[Infrastructure]** Moved CI to _Github Actions_\n+    - Added `rustfmt` step to CI\n+    - Added `clippy` step to CI\n+- **[Refactroing]** Performed deep global refactoring of the project\n+    - Updated to Rust 2018 edition\n+    - Updated dependencies\n+    - Fixed all `clippy` errors\n+    - Minimized `rustzx-core` public interface\n+    - Added feature gates for resource-hungry `rustzx-core` features\n+    - Eliminated a lot of not redundant code\n+    - Made groundwork for a future emulator features\n+\n+### RustZX v0.9\n+Authors:\n+- Konstantin Mochalov (@kolen)\n+\n+Changes:\n+- **[Feature]** Drag-n-drop support for TAP and SNA files\n+- **[Refactoring]** Multiple small refactoring changes\n+- **[Dependencies]** Updated `sdl` crate\n+\n+### Pre-pelease\n+Authors:\n+- Vladyslav Nikonov (@pacmancoder)\n+\n+Changes:\n+- **[19.08.2016]** RustzxApp and RustzxSettings refactoring\n+- **[18.08.2016]** Moved sound, video, event to sdl lib.\n+- **[15.08.2016]** Moving from **portaudio** to **cpal**\n+- **[14.08.2016]** Kempston Joystick\n+- **[14.08.2016]** AY implementation finished\n+- **[12.08.2016]** AY implementation start\n+- **[09.08.2016]** Refactoring\n+- **[08.08.2016]** Aspect ratio correction, custom 128K rom loading\n+- **[08.08.2016]** Window scale selection with `--scale` option\n+- **[07.07.2016]** ZXScreen rewrite\n+- **[06.07.2016]** Base 128K features implemented\n+- **[05.07.2016]** v0.8 development started in branch `develop`\n+- **[27.06.2016]** Release v0.7.1\n+- **[26.06.2016]** Beeper sound implemented :notes:, release planed to July 1 :rocket:\n+- **[12.06.2016]** Some Comand line arguments fixes/enchantments\n+- **[12.06.2016]** SNA files loading\n+- **[11.06.2016]** Command line arguments using **clap** crate\n+- **[11.06.2016]** Tap files fast loading implemented, finnaly!\n+- **[07.06.2016]** Speed improvements (maybe :smile:) in flag setting [z80]\n+- **[04.06.2016]** Border FX implemented\n+- **[28.05.2016]** Some architecture rewrite, working on border\n+- **[21.05.2016]** OVERSCAN and SHOCK demo\'s passed! :sparkles:\n+- **[21.05.2016]** Screen reorganization and OpenGL rendering part fix\n+- **[19.05.2016]** Documentation, Rustfmt\n+- **[15.05.2016]** Fixed bug in INC/DEC (IX/IY + dd). After 2 weeks :smile:\n+- **[12.05.2016]** Fixed CALL timings\n+- **[06.05.2016]** Floating bus fix\n+- **[28.04.2016]** All contentions implemented!\n+- **[24.04.2016]** Almost all contentions working perfectly (IO still broken)\n+- **[24.04.2016]** IM2 bug fixed, finally I found it! :smile:\n+- **[24.04.2016]** new Z80Bus interface, serious z80 emulation part rewrite\n+- **[22.04.2016]** work on implementing correct timings started.\n+- **[18.04.2016]** fixed many instruction bugs (IO section still not finished)\n+- **[12.04.2016]** fixed shader bug causing bad performance - palette was declared as non-const\n+- **[12.04.2016]** log file added\n+- **[29.03.2016]** Screen emulation, keyboard, test run of ROMs\n+- **[14.03.2016]** All features of CPU have been implemented :sunglasses:\n+- **[11.03.2016]** Serious code reorganization\n+- **[06.03.2016]** All Z80 instruction groups have been implemented! :tada:\n+- **[02.02.2016]** First commit\ndiff --git a/Cargo.lock b/Cargo.lock\nindex ed18f98..0077fcc 100644\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -17,6 +17,15 @@ dependencies = [\n  "memchr",\n ]\n \n+[[package]]\n+name = "ansi_term"\n+version = "0.11.0"\n+source = "registry+https://github.com/rust-lang/crates.io-index"\n+checksum = "ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b"\n+dependencies = [\n+ "winapi",\n+]\n+\n [[package]]\n name = "anyhow"\n version = "1.0.40"\n@@ -74,36 +83,19 @@ checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"\n \n [[package]]\n name = "clap"\n-version = "3.0.0-beta.2"\n+version = "2.33.3"\n source = "registry+https://github.com/rust-lang/crates.io-index"\n-checksum = "4bd1061998a501ee7d4b6d449020df3266ca3124b941ec56cf2005c3779ca142"\n+checksum = "37e58ac78573c40708d45522f0d80fa2f01cc4f9b4e2bf749807255454312002"\n dependencies = [\n+ "ansi_term",\n  "atty",\n  "bitflags",\n- "clap_derive",\n- "indexmap",\n- "lazy_static",\n- "os_str_bytes",\n- "strsim 0.10.0",\n- "termcolor",\n+ "strsim 0.8.0",\n  "textwrap",\n  "unicode-width",\n  "vec_map",\n ]\n \n-[[package]]\n-name = "clap_derive"\n-version = "3.0.0-beta.2"\n-source = "registry+https://github.com/rust-lang/crates.io-index"\n-checksum = "370f715b81112975b1b69db93e0b56ea4cd4e5002ac43b2da8474106a54096a1"\n-dependencies = [\n- "heck",\n- "proc-macro-error",\n- "proc-macro2",\n- "quote",\n- "syn",\n-]\n-\n [[package]]\n name = "cmake"\n version = "0.1.45"\n@@ -259,12 +251,6 @@ version = "0.3.55"\n source = "registry+https://github.com/rust-lang/crates.io-index"\n checksum = "8f5f3913fa0bfe7ee1fd8248b6b9f42a5af4b9d65ec2dd2c3c26132b950ecfc2"\n \n-[[package]]\n-name = "hashbrown"\n-version = "0.9.1"\n-source = "registry+https://github.com/rust-lang/crates.io-index"\n-checksum = "d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04"\n-\n [[package]]\n name = "heck"\n version = "0.3.2"\n@@ -295,16 +281,6 @@ version = "1.0.1"\n source = "registry+https://github.com/rust-lang/crates.io-index"\n checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"\n \n-[[package]]\n-name = "indexmap"\n-version = "1.6.2"\n-source = "registry+https://github.com/rust-lang/crates.io-index"\n-checksum = "824845a0bf897a9042383849b02c1bc219c2383772efcd5c6f9766fa4b81aef3"\n-dependencies = [\n- "autocfg",\n- "hashbrown",\n-]\n-\n [[package]]\n name = "lazy_static"\n version = "1.4.0"\n@@ -348,12 +324,6 @@ version = "1.7.2"\n source = "registry+https://github.com/rust-lang/crates.io-index"\n checksum = "af8b08b04175473088b46763e51ee54da5f9a164bc162f615b91bc179dbf15a3"\n \n-[[package]]\n-name = "os_str_bytes"\n-version = "2.4.0"\n-source = "registry+https://github.com/rust-lang/crates.io-index"\n-checksum = "afb2e1c3ee07430c2cf76151675e583e0f19985fa6efae47d6848a3e2c824f85"\n-\n [[package]]\n name = "proc-macro-error"\n version = "1.0.4"\n@@ -424,21 +394,22 @@ checksum = "24d5f089152e60f62d28b835fbff2cd2e8dc0baf1ac13343bef92ab7eed84548"\n \n [[package]]\n name = "rustzx"\n-version = "0.10.0"\n+version = "0.11.0"\n dependencies = [\n  "anyhow",\n- "clap",\n  "env_logger",\n  "log",\n  "rustzx-core",\n  "sdl2",\n+ "structopt",\n ]\n \n [[package]]\n name = "rustzx-core"\n-version = "0.10.0"\n+version = "0.11.0"\n dependencies = [\n  "ayumi",\n+ "bitflags",\n  "displaydoc",\n  "enum_dispatch",\n  "from_variants",\n@@ -472,6 +443,12 @@ dependencies = [\n  "version-compare",\n ]\n \n+[[package]]\n+name = "strsim"\n+version = "0.8.0"\n+source = "registry+https://github.com/rust-lang/crates.io-index"\n+checksum = "8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a"\n+\n [[package]]\n name = "strsim"\n version = "0.9.3"\n@@ -479,10 +456,28 @@ source = "registry+https://github.com/rust-lang/crates.io-index"\n checksum = "6446ced80d6c486436db5c078dde11a9f73d42b57fb273121e160b84f63d894c"\n \n [[package]]\n-name = "strsim"\n-version = "0.10.0"\n+name = "structopt"\n+version = "0.3.21"\n+source = "registry+https://github.com/rust-lang/crates.io-index"\n+checksum = "5277acd7ee46e63e5168a80734c9f6ee81b1367a7d8772a2d765df2a3705d28c"\n+dependencies = [\n+ "clap",\n+ "lazy_static",\n+ "structopt-derive",\n+]\n+\n+[[package]]\n+name = "structopt-derive"\n+version = "0.4.14"\n source = "registry+https://github.com/rust-lang/crates.io-index"\n-checksum = "73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623"\n+checksum = "5ba9cdfda491b814720b6b06e0cac513d922fc407582032e8706e9f137976f90"\n+dependencies = [\n+ "heck",\n+ "proc-macro-error",\n+ "proc-macro2",\n+ "quote",\n+ "syn",\n+]\n \n [[package]]\n name = "syn"\n@@ -517,9 +512,9 @@ dependencies = [\n \n [[package]]\n name = "textwrap"\n-version = "0.12.1"\n+version = "0.11.0"\n source = "registry+https://github.com/rust-lang/crates.io-index"\n-checksum = "203008d98caf094106cfaba70acfed15e18ed3ddb7d94e49baec153a2b462789"\n+checksum = "d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060"\n dependencies = [\n  "unicode-width",\n ]\ndiff --git a/LOG.md b/LOG.md\ndeleted file mode 100644\nindex 9ba1d08..0000000\n--- a/LOG.md\n+++ /dev/null\n@@ -1,40 +0,0 @@\n-**[19.08.2016]** RustzxApp and RustzxSettings refactoring  \n-**[18.08.2016]** Moved sound, video, event to sdl lib.  \n-**[15.08.2016]** Moving from **portaudio** to **cpal**  \n-**[14.08.2016]** Kempston Joystick  \n-**[14.08.2016]** AY implementation finished  \n-**[12.08.2016]** AY implementation start  \n-**[09.08.2016]** Refactoring  \n-**[08.08.2016]** Aspect ratio correction, custom 128K rom loading  \n-**[08.08.2016]** Window scale selection with `--scale` option  \n-**[07.07.2016]** ZXScreen rewrite  \n-**[06.07.2016]** Base 128K features implemented  \n-**[05.07.2016]** v0.8 development started in branch `develop`  \n-**[27.06.2016]** Release v0.7.1  \n-**[26.06.2016]** Beeper sound implemented :notes:, release planed to July 1 :rocket:  \n-**[12.06.2016]** Some Comand line arguments fixes/enchantments  \n-**[12.06.2016]** SNA files loading  \n-**[11.06.2016]** Command line arguments using **clap** crate  \n-**[11.06.2016]** Tap files fast loading implemented, finnaly!  \n-**[07.06.2016]** Speed improvements (maybe :smile:) in flag setting [z80]    \n-**[04.06.2016]** Border FX implemented  \n-**[28.05.2016]** Some architecture rewrite, working on border    \n-**[21.05.2016]** OVERSCAN and SHOCK demo\'s passed! :sparkles:     \n-**[21.05.2016]** Screen reorganization and OpenGL rendering part fix  \n-**[19.05.2016]** Documentation, Rustfmt  \n-**[15.05.2016]** Fixed bug in INC/DEC (IX/IY + dd). After 2 weeks :smile:  \n-**[12.05.2016]** Fixed CALL timings  \n-**[06.05.2016]** Floating bus fix  \n-**[28.04.2016]** All contentions implemented!  \n-**[24.04.2016]** Almost all contentions working perfectly (IO still broken)  \n-**[24.04.2016]** IM2 bug fixed, finally I found it! :smile:  \n-**[24.04.2016]** new Z80Bus interface, serious z80 emulation part rewrite  \n-**[22.04.2016]** work on implementing correct timings started.  \n-**[18.04.2016]** fixed many instruction bugs (IO section still not finished)  \n-**[12.04.2016]** fixed shader bug causing bad performance - palette was declared as non-const  \n-**[12.04.2016]** log file added  \n-**[29.03.2016]** Screen emulation, keyboard, test run of ROMs    \n-**[14.03.2016]** All features of CPU have been implemented :sunglasses:  \n-**[11.03.2016]** Serious code reorganization  \n-**[06.03.2016]** All Z80 instruction groups have been implemented! :tada:  \n-**[02.02.2016]** First commit  \ndiff --git a/README.md b/README.md\nindex ed9b3bb..d54c4b5 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,60 +1,54 @@\n-# rustzx\n-![logo](assets/logo_small.png)\n+RustZX\n+===============================\n+\n+[![RustZX CI](https://github.com/pacmancoder/rustzx/actions/workflows/ci.yml/badge.svg)](https://github.com/pacmancoder/rustzx/actions/workflows/ci.yml)\n \n-ZX Spectrum emulator which I writing in rust.\n-I develop this project just for fun and for learning the basics of computer\n-architecture.\n-Licensed under MIT License.\n+![logo](assets/logo_small.png)\n \n-**Watch [this](https://youtu.be/Xho3GWFyP2I) video showcase!**\n+ZX Spectrum emulator written in Rust\n+- Watch [this](https://youtu.be/Xho3GWFyP2I) video showcase (`v0.9.x`)\n+- Read [CHANGELOG.md](CHANGELOG.md) for info on the latest version (`v0.11.x`) changes\n \n-[![Build Status](https://travis-ci.org/pacmancoder/rustzx.svg?branch=master)](https://travis-ci.org/pacmancoder/rustzx)\n ## Features\n - Written in pure rust\n - Cross-platform\n-- Documented source\n - Full ZX Spectrum 48K and 128K emulation\n - Perfect emulation of Z80 core\n - Highly precise AY chip emulation with Ayumi library\n - Beeper sound emulation\n-- Can handle tap, sna files\n+- Supported formats: TAP, SNA\n - Fast loading of tap files with standard loader\n-- Emulates border\n-- Kempston joystick emulation\n-- Correct contentons\n-\n-## Download [v0.9.2]\n-Packages are available in github releases.\n-**Note:** On linux platforms sdl2 library must be installed\n+- Precise timings\n+- Full border emulation\n+- Joystick emulation: Kempston\n+- Separate `no_std` core library which can be used to port emulator\n+  almost anywhere.\n+    - Global allocator is still needed, but all dynamic\n+       allocations were minimized\n+    - All resource-heavy features are configurable via cargo `features`\n \n-## Compiling\n-Before compiling make shure that you have C compiller and CMate to\n+## Compiling from the latest master\n+1. Sure that you have C compiller and CMake to\n build bundled `sdl2`\n-\n-Then just install it with cargo\n-\n+2. Install it with cargo\n ```bash\n-cargo install\n+cargo install --path ./rustzx\n ```\n-For advanced info use `--help` flag\n \n ## How to use\n-Here some examples of usage:\n ```bash\n-rustzx --help\n-rustzx --fastload --tap test.tap\n-rustzx -f --128k --AY abc --tap test128.tap\n-rustzx --rom tester.rom --scale 3 --volume 50\n+rustzx --help # Show help\n+rustzx test.tap # Autodetect file type and run in 48K mode\n+rustzx --ay test.tap # Run in 48K mode with AY sound chip\n+rustzx -m128 --tape test128.tap # Run in 128K mode with tape\n+rustzx --rom tester.rom -s3 # Run with custom rom and 3x screen scaling\n+rustzx --nofastload test.tap # Run without fast tape loading\n ```\n For loading tape in 48K mode, press `j` then `Ctrl+p` twice, as on real Spectrum.\n-You must see `LOAD ""` on emulator\'s screen. And then press `Enter`.\n-If you `--fastload` option before launching, game will be launched, in other\n-case press `Insert` to insert tape. `Delete` can be used for ejecting tape from\n-tape reader. `--128k` flag launches emulator in 128K mode. For loading tape just\n-press `Enter`.\n+You should see `LOAD ""` on emulator\'s screen, then press `Enter` (in 128K mode just press enter).\n+In `--nofastload` mode, press `Insert` to play the tape and `Delete` to stop\n \n-If you have some audio troubles - use `--latency` flag with bigger samples\n-count.\n+If you have choppy audio, try `--sound-latency` option with bigger values.\n \n Use keys `F3 - F5` to set speed of emulation - this can be usefull when skipping some boring stuff.\n Use `F6` to display FPS in window title.\n@@ -64,13 +58,11 @@ Use `F6` to display FPS in window title.\n ![](screenshots/q.png)\n ![](screenshots/arkanoid.png)\n ![](screenshots/sentinel.png)\n-## Log\n-Watch [LOG](LOG.md) for details and github issues\n-for current plans and help requests.\n+\n ## References\n-Of course, I used many resources to find out, how to build my first\n-emulator in life. So there is a list of useful references, from where I dig most\n-information about Z80, ULA and other ZX Spectrum hardware parts:\n+Many resources were used to find out, how to buildthis emulator.\n+Huge thanks to the following resources which helped to figure out a lot of\n+defails about ZX Spectrum.\n - Of course [z80.info](http://www.z80.info/)\n     - [Decoding Z80 opcodes](http://www.z80.info/decoding.htm)\n     - [Opcodes list](http://www.z80.info/z80code.txt)\n@@ -93,6 +85,8 @@ information about Z80, ULA and other ZX Spectrum hardware parts:\n - [FUSE](http://fuse-emulator.sourceforge.net/) emulator source for finding out correct timings\n \n ## ROM\'s\n-Emulator contains ROM\'s, created by by Sinclair Research Ltd (now owned by Amstrad plc),\n-Amstrad was given permissions for distributing their ROM\'s with emulators, so they are\n-included in source of emulator (mod zx::roms). More about this read [here](https://groups.google.com/forum/?hl=en#!msg/comp.sys.amstrad.8bit/HtpBU2Bzv_U/HhNDSU3MksAJ)\n+Emulator contains ROMs, created by by Sinclair Research Ltd (now owned by Amstrad plc),\n+Amstrad has [given](https://groups.google.com/forum/?hl=en#!msg/comp.sys.amstrad.8bit/HtpBU2Bzv_U/HhNDSU3MksAJ)\n+permission to distribute their ROM\'s in conjunction with emulators.\n+In RustZX these ROMs included in source of the core emulator library `mod rustzx_core::zx::roms`. Embedded roms\n+can be opted-out from the core library by disabling feature `embedded-roms`.\ndiff --git a/rustfmt.toml b/rustfmt.toml\nindex 4301c1c..c5d444e 100644\n--- a/rustfmt.toml\n+++ b/rustfmt.toml\n@@ -1,11 +1,13 @@\n use_field_init_shorthand = true\n use_try_shorthand = true\n+# Available in nightly, but does not affect success of\n+# stable rustfmt\n+report_fixme = "Unnumbered"\n+report_todo = "Unnumbered"\n+imports_granularity = "Crate"\n+normalize_comments = true\n+condense_wildcard_suffixes = true\n+format_strings = true\n+reorder_impl_items = true\n # Uncomment following if available in stable rustfmt\n-# imports_granularity = "Crate"\n-# normalize_comments = true\n-# condense_wildcard_suffixes = true\n-# format_strings = true\n # imports_layout = "HorizontalVertical"\n-# reorder_impl_items = true\n-# report_fixme = "Unnumbered"\n-# report_todo = "Unnumbered"\ndiff --git a/rustzx-core/Cargo.toml b/rustzx-core/Cargo.toml\nindex 7a8bcc6..497f36b 100644\n--- a/rustzx-core/Cargo.toml\n+++ b/rustzx-core/Cargo.toml\n@@ -1,17 +1,26 @@\n [package]\n name = "rustzx-core"\n-version = "0.10.0"\n+version = "0.11.0"\n authors = ["Vladyslav Nikonov <mail@pacmancoder.xyz>"]\n-publish = false\n description = "ZX Spectum emulator core library"\n repository = "https://github.com/pacmancoder/rustzx"\n keywords = ["emulator", "game", "z80", "no_std"]\n license = "MIT"\n edition = "2018"\n \n+[features]\n+default = []\n+full = ["ay", "precise-border", "embedded-roms"]\n+without-ay = ["sound", "precise-border", "embedded-roms"]\n+precise-border = []\n+embedded-roms = []\n+sound = []\n+ay = ["ayumi", "sound"]\n+\n [dependencies]\n-lazy_static = "1.4"\n+bitflags = "1"\n+lazy_static = "1"\n displaydoc = { version = "0.2", default-features = false }\n from_variants = "0.6"\n enum_dispatch = "0.3"\n-ayumi = { git = "https://github.com/pacmancoder/rust-ayumi.git", rev = "9e57902" }\n+ayumi = { git = "https://github.com/pacmancoder/rust-ayumi.git", rev = "9e57902", optional = true }\ndiff --git a/rustzx-core/src/emulator/loaders/sna.rs b/rustzx-core/src/emulator/loaders/sna.rs\nindex 6297782..8464cb1 100644\n--- a/rustzx-core/src/emulator/loaders/sna.rs\n+++ b/rustzx-core/src/emulator/loaders/sna.rs\n@@ -3,58 +3,53 @@ use crate::{\n     host::{Host, LoadableAsset},\n     utils::{make_word, Clocks},\n     z80::{opcodes::execute_pop_16, RegName16},\n-    zx::colors::ZXColor,\n+    zx::video::colors::ZXColor,\n     Result,\n };\n-use alloc::vec::Vec;\n \n /// SNA snapshot loading function\n pub fn load_sna<H: Host>(emulator: &mut Emulator<H>, mut asset: H::SnapshotAsset) -> Result<()> {\n-    // TODO(#54): Eliminate loading a whole file to vector in sna loader\n-    let mut data = Vec::new();\n-    asset.read_to_end(&mut data)?;\n-    assert!(data.len() == 49179);\n+    const SNA_HEADER_SIZE: usize = 27;\n+    let mut header = [0u8; SNA_HEADER_SIZE];\n+    asset.read_exact(&mut header)?;\n+\n     // i-reg\n-    emulator.cpu.regs.set_i(data[0]);\n+    emulator.cpu.regs.set_i(header[0]);\n     // alt-regs\n-    emulator.cpu.regs.set_hl(make_word(data[2], data[1]));\n-    emulator.cpu.regs.set_de(make_word(data[4], data[3]));\n-    emulator.cpu.regs.set_bc(make_word(data[6], data[5]));\n+    emulator.cpu.regs.set_hl(make_word(header[2], header[1]));\n+    emulator.cpu.regs.set_de(make_word(header[4], header[3]));\n+    emulator.cpu.regs.set_bc(make_word(header[6], header[5]));\n     emulator.cpu.regs.exx();\n     // af\'\n-    emulator.cpu.regs.set_af(make_word(data[8], data[7]));\n+    emulator.cpu.regs.set_af(make_word(header[8], header[7]));\n     emulator.cpu.regs.swap_af_alt();\n     // regs\n-    emulator.cpu.regs.set_hl(make_word(data[10], data[9]));\n-    emulator.cpu.regs.set_de(make_word(data[12], data[11]));\n-    emulator.cpu.regs.set_bc(make_word(data[14], data[13]));\n+    emulator.cpu.regs.set_hl(make_word(header[10], header[9]));\n+    emulator.cpu.regs.set_de(make_word(header[12], header[11]));\n+    emulator.cpu.regs.set_bc(make_word(header[14], header[13]));\n     // index regs\n-    emulator.cpu.regs.set_iy(make_word(data[16], data[15]));\n-    emulator.cpu.regs.set_ix(make_word(data[18], data[17]));\n+    emulator.cpu.regs.set_iy(make_word(header[16], header[15]));\n+    emulator.cpu.regs.set_ix(make_word(header[18], header[17]));\n     // iff1, iff2\n-    let iff = (data[19] & 0x04) != 0;\n+    let iff = (header[19] & 0x04) != 0;\n     emulator.cpu.regs.set_iff1(iff);\n     emulator.cpu.regs.set_iff2(iff);\n     // r\n-    emulator.cpu.regs.set_r(data[20]);\n+    emulator.cpu.regs.set_r(header[20]);\n     // af\n-    emulator.cpu.regs.set_af(make_word(data[22], data[21]));\n+    emulator.cpu.regs.set_af(make_word(header[22], header[21]));\n     // sp\n-    emulator.cpu.regs.set_sp(make_word(data[24], data[23]));\n+    emulator.cpu.regs.set_sp(make_word(header[24], header[23]));\n     // interrupt mode\n-    emulator.cpu.set_im(data[25] & 0x03);\n-    // set border\n+    emulator.cpu.set_im(header[25] & 0x03);\n     emulator\n         .controller\n-        .border\n-        .set_border(Clocks(0), ZXColor::from_bits(data[26] & 0x07));\n+        .set_border_color(Clocks(0), ZXColor::from_bits(header[26] & 0x07));\n     // ram pages\n-    let page = emulator.controller.memory.ram_page_data_mut(0);\n-    page.copy_from_slice(&data[27..16411]);\n-    let page = emulator.controller.memory.ram_page_data_mut(1);\n-    page.copy_from_slice(&data[16411..32795]);\n-    let page = emulator.controller.memory.ram_page_data_mut(2);\n-    page.copy_from_slice(&data[32795..49179]);\n+    for page_index in 0..3 {\n+        let page = emulator.controller.memory.ram_page_data_mut(page_index);\n+        asset.read_exact(page)?;\n+    }\n \n     // RET\n     execute_pop_16(\ndiff --git a/rustzx-core/src/emulator/loaders/tap.rs b/rustzx-core/src/emulator/loaders/tap.rs\nindex 9b62c13..934d579 100644\n--- a/rustzx-core/src/emulator/loaders/tap.rs\n+++ b/rustzx-core/src/emulator/loaders/tap.rs\n@@ -3,13 +3,12 @@ use crate::{\n     emulator::Emulator,\n     host::Host,\n     utils::{make_word, Clocks},\n-    z80::*,\n+    z80::{opcodes, RegName16, Z80Bus, FLAG_CARRY, FLAG_ZERO},\n     zx::tape::TapeImpl,\n+    Result,\n };\n \n-pub fn fast_load_tap<H: Host>(emulator: &mut Emulator<H>) {\n-    // resetting tape pos to beginning.\n-    emulator.controller.tape.reset_pos_in_block();\n+pub fn fast_load_tap<H: Host>(emulator: &mut Emulator<H>) -> Result<()> {\n     // So, at current moment we at 0x056C in 48K Rom.\n     // AF contains some garbage. so we need to swap if wtih A\'F\'\n     emulator.cpu.regs.swap_af_alt();\n@@ -18,20 +17,22 @@ pub fn fast_load_tap<H: Host>(emulator: &mut Emulator<H>) {\n     let mut acc = emulator.cpu.regs.get_acc();\n     // variable to store resulting flags\n     let mut result_flags;\n-    // pos relative to block start\n-    let mut pos = 0;\n     // destination address in RAM\n     let mut dest = emulator.cpu.regs.get_reg_16(RegName16::IX);\n     // remaining length\n     let mut length = emulator.cpu.regs.get_reg_16(RegName16::DE);\n     // parity accumulator and current byte (h, l) regs\n     let (mut parity_acc, mut current_byte) = (0, 0);\n+    // move to next block\n+    if !emulator.controller.tape.next_block()? {\n+        return Ok(());\n+    }\n+\n     \'loader: loop {\n         // if we still on block\n-        if let Some(byte) = emulator.controller.tape.block_byte(pos) {\n+        if let Some(byte) = emulator.controller.tape.next_block_byte()? {\n             // set current byte, shift position and do parity check iteration\n             current_byte = byte;\n-            pos += 1;\n             parity_acc ^= current_byte;\n             // no bytes left, set A to parity accumulator (works as in ROM)\n             // and check parity last time\n@@ -98,6 +99,5 @@ pub fn fast_load_tap<H: Host>(emulator: &mut Emulator<H>) {\n         );\n     }\n     emulator.cpu.regs.set_flags(f);\n-    // move to next block\n-    emulator.controller.tape.next_block();\n+    Ok(())\n }\ndiff --git a/rustzx-core/src/emulator/mod.rs b/rustzx-core/src/emulator/mod.rs\nindex a83b22a..f112991 100644\n--- a/rustzx-core/src/emulator/mod.rs\n+++ b/rustzx-core/src/emulator/mod.rs\n@@ -5,27 +5,32 @@ use crate::{\n     error::RomLoadError,\n     host::{Host, LoadableAsset, RomFormat, RomSet, Snapshot, Tape},\n     settings::RustzxSettings,\n-    utils::*,\n-    z80::*,\n+    utils::EmulationSpeed,\n+    z80::Z80,\n     zx::{\n+        controller::ZXController,\n+        events::EmulationEvents,\n         joy::kempston::KempstonKey,\n-        sound::sample::SoundSample,\n+        keys::ZXKey,\n         tape::{Tap, TapeImpl},\n-        ZXController, ZXKey,\n+        video::colors::ZXColor,\n     },\n     Result,\n };\n \n+#[cfg(feature = "sound")]\n+use crate::zx::sound::sample::SoundSample;\n+\n use core::time::Duration;\n \n /// Represents main Emulator structure\n pub struct Emulator<H: Host> {\n     settings: RustzxSettings,\n     cpu: Z80,\n-    // TODO(#52): eliminate direct access to the controller\n-    pub controller: ZXController<H>,\n+    controller: ZXController<H>,\n     speed: EmulationSpeed,\n     fast_load: bool,\n+    #[cfg(feature = "sound")]\n     sound_enabled: bool,\n }\n \n@@ -38,13 +43,14 @@ impl<H: Host> Emulator<H> {\n     /// Constructs new emulator\n     /// # Arguments\n     /// `settings` - emulator settings\n-    pub fn new(settings: RustzxSettings) -> Result<Self> {\n+    pub fn new(settings: RustzxSettings, context: H::Context) -> Result<Self> {\n         let speed = settings.emulation_speed;\n         let fast_load = settings.tape_fastload;\n+        #[cfg(feature = "sound")]\n         let sound_enabled = settings.sound_enabled;\n \n         let cpu = Z80::default();\n-        let controller = ZXController::<H>::new(&settings);\n+        let controller = ZXController::<H>::new(&settings, context);\n \n         let this = Self {\n             settings,\n@@ -52,6 +58,7 @@ impl<H: Host> Emulator<H> {\n             controller,\n             speed,\n             fast_load,\n+            #[cfg(feature = "sound")]\n             sound_enabled,\n         };\n \n@@ -69,11 +76,13 @@ impl<H: Host> Emulator<H> {\n     }\n \n     /// changes sound playback flag\n+    #[cfg(feature = "sound")]\n     pub fn set_sound(&mut self, value: bool) {\n         self.sound_enabled = value;\n     }\n \n     /// function for sound generation request check\n+    #[cfg(feature = "sound")]\n     pub fn have_sound(&self) -> bool {\n         // enable sound only if speed is normal\n         if let EmulationSpeed::Definite(1) = self.speed {\n@@ -125,6 +134,19 @@ impl<H: Host> Emulator<H> {\n         self.controller.tape.stop();\n     }\n \n+    pub fn screen_buffer(&self) -> &H::FrameBuffer {\n+        self.controller.screen.frame_buffer()\n+    }\n+\n+    #[cfg(feature = "precise-border")]\n+    pub fn border_buffer(&self) -> &H::FrameBuffer {\n+        self.controller.border.frame_buffer()\n+    }\n+\n+    pub fn border_color(&self) -> ZXColor {\n+        self.controller.border_color\n+    }\n+\n     pub fn send_key(&mut self, key: ZXKey, pressed: bool) {\n         self.controller.send_key(key, pressed);\n     }\n@@ -135,32 +157,25 @@ impl<H: Host> Emulator<H> {\n         }\n     }\n \n+    #[cfg(feature = "sound")]\n     pub fn next_audio_sample(&mut self) -> Option<SoundSample<f32>> {\n         self.controller.mixer.pop()\n     }\n \n-    fn process_event(&mut self, event: Event) {\n-        let Event { kind: e, time: _ } = event;\n-        match e {\n-            // Fast tape loading found, use it\n-            EventKind::FastTapeLoad if self.controller.tape.can_fast_load() && self.fast_load => {\n-                loaders::tap::fast_load_tap(self);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    // processes all events, happened at frame emulation cycle\n-    fn process_all_events(&mut self) {\n-        while let Some(event) = self.controller.pop_event() {\n-            self.process_event(event);\n+    fn process_events(&mut self, event: EmulationEvents) -> Result<()> {\n+        if event.contains(EmulationEvents::TAPE_FAST_LOAD_TRIGGER_DETECTED)\n+            && self.controller.tape.can_fast_load()\n+            && self.fast_load\n+        {\n+            loaders::tap::fast_load_tap(self)?;\n         }\n+        Ok(())\n     }\n \n     /// Emulate frames, maximum in `max_time` time, returns emulation time in nanoseconds\n     /// in most cases time is max 1/50 of second, even when using\n     /// loader acceleration\n-    pub fn emulate_frames<S>(&mut self, max_time: Duration, stopwatch: &mut S) -> Duration\n+    pub fn emulate_frames<S>(&mut self, max_time: Duration, stopwatch: &mut S) -> Result<Duration>\n     where\n         S: Stopwatch,\n     {\n@@ -172,17 +187,19 @@ impl<H: Host> Emulator<H> {\n             self.controller.reset_frame_counter();\n             \'cpu: loop {\n                 // Emulation step. if instant event happened then accept in and execute\n-                if !self.cpu.emulate(&mut self.controller) {\n-                    if let Some(event) = self.controller.pop_event() {\n-                        self.process_event(event);\n-                    }\n+                self.cpu.emulate(&mut self.controller);\n+                if let Some(e) = self.controller.take_last_emulation_error() {\n+                    return Err(e);\n+                }\n+                if !self.controller.events().is_empty() {\n+                    self.process_events(self.controller.events())?;\n+                    self.controller.clear_events();\n                 }\n                 // If speed is defined\n                 if let EmulationSpeed::Definite(multiplier) = self.speed {\n                     if self.controller.frames_count() >= multiplier {\n                         // no more frames\n-                        self.controller.clear_events();\n-                        return stopwatch.measure();\n+                        return Ok(stopwatch.measure());\n                     };\n                 // if speed is maximal.\n                 } else {\n@@ -198,7 +215,6 @@ impl<H: Host> Emulator<H> {\n                 break \'frame;\n             }\n         }\n-        self.controller.clear_events();\n-        time\n+        Ok(time)\n     }\n }\ndiff --git a/rustzx-core/src/error.rs b/rustzx-core/src/error.rs\nindex 8dbd531..5c96cf6 100644\n--- a/rustzx-core/src/error.rs\n+++ b/rustzx-core/src/error.rs\n@@ -7,6 +7,8 @@ pub enum Error {\n     AssetRead(AssetReadError),\n     /// Failed to load rom\n     RomLoad(RomLoadError),\n+    /// Failed to load rom\n+    TapeLoad(TapeLoadError),\n }\n \n #[derive(Debug, Display)]\n@@ -22,3 +24,9 @@ pub enum RomLoadError {\n     /// More assets required to load rom\n     MoreAssetsRequired,\n }\n+\n+#[derive(Debug, Display)]\n+pub enum TapeLoadError {\n+    /// Provided tap file is invalid\n+    InvalidTapFile,\n+}\ndiff --git a/rustzx-core/src/host/frame_buffer.rs b/rustzx-core/src/host/frame_buffer.rs\nnew file mode 100644\nindex 0000000..56620a4\n--- /dev/null\n+++ b/rustzx-core/src/host/frame_buffer.rs\n@@ -0,0 +1,14 @@\n+use crate::zx::video::colors::{ZXBrightness, ZXColor};\n+\n+pub enum FrameBufferSource {\n+    Screen,\n+    Border,\n+}\n+\n+pub trait FrameBuffer {\n+    type Context: Clone;\n+    /// Creates canvas size with required dimensions (`width`, `height`)\n+    fn new(width: usize, height: usize, source: FrameBufferSource, context: Self::Context) -> Self;\n+    /// Set `color` with `brightness` for pixel on canvas at (`x`, `y`)\n+    fn set_color(&mut self, x: usize, y: usize, color: ZXColor, brightness: ZXBrightness);\n+}\ndiff --git a/rustzx-core/src/host/io.rs b/rustzx-core/src/host/io.rs\nindex 504e648..9ba902a 100644\n--- a/rustzx-core/src/host/io.rs\n+++ b/rustzx-core/src/host/io.rs\n@@ -36,14 +36,4 @@ pub trait LoadableAsset {\n \n         Ok(())\n     }\n-\n-    fn read_to_end(&mut self, buf: &mut alloc::vec::Vec<u8>) -> Result<()> {\n-        let mut buffer = [0u8; 1024];\n-        let mut read_bytes = self.read(&mut buffer)?;\n-        while read_bytes != 0 {\n-            buf.extend_from_slice(&buffer[0..read_bytes]);\n-            read_bytes = self.read(&mut buffer)?;\n-        }\n-        Ok(())\n-    }\n }\ndiff --git a/rustzx-core/src/host/mod.rs b/rustzx-core/src/host/mod.rs\nindex 1f9ca8e..d1c97c2 100644\n--- a/rustzx-core/src/host/mod.rs\n+++ b/rustzx-core/src/host/mod.rs\n@@ -1,5 +1,7 @@\n+mod frame_buffer;\n mod io;\n \n+pub use frame_buffer::{FrameBuffer, FrameBufferSource};\n pub use io::{LoadableAsset, SeekFrom};\n \n pub enum Snapshot<LoadableAssetImpl: LoadableAsset> {\n@@ -23,13 +25,22 @@ pub trait RomSet {\n     fn next_asset(&mut self) -> Option<Self::Asset>;\n }\n \n+pub trait HostContext<H: Host + ?Sized>: Sized {\n+    fn frame_buffer_context(&self) -> <H::FrameBuffer as FrameBuffer>::Context;\n+}\n+\n /// Represents set of required types for emulator implementation\n /// based on `rustzx-core`.\n pub trait Host {\n+    /// Immutable `Context` implementation which is used to obtain host-specific\n+    /// context objects for host-defined emulator parts construction (e.g. FrameBuffers)\n+    type Context: HostContext<Self>;\n     /// File-like type implementation for tape loading\n     type TapeAsset: LoadableAsset;\n     /// File-like type implementation for snapshot loading\n     type SnapshotAsset: LoadableAsset;\n     /// File-like type implementation for rom loading\n     type RomSet: RomSet;\n+    /// Frame buffer implementation\n+    type FrameBuffer: FrameBuffer;\n }\ndiff --git a/rustzx-core/src/lib.rs b/rustzx-core/src/lib.rs\nindex 6c0c18b..bbd415c 100644\n--- a/rustzx-core/src/lib.rs\n+++ b/rustzx-core/src/lib.rs\n@@ -1,15 +1,19 @@\n #![no_std]\n #![allow(dead_code)]\n \n-pub mod emulator;\n+pub(crate) mod emulator;\n+pub(crate) mod settings;\n+pub(crate) mod utils;\n+pub(crate) mod z80;\n+\n pub mod error;\n pub mod host;\n-pub mod settings;\n-pub mod utils;\n-pub mod z80;\n pub mod zx;\n \n+pub use emulator::{Emulator, Stopwatch};\n+pub use settings::RustzxSettings;\n+pub use utils::EmulationSpeed;\n+\n extern crate alloc;\n \n-pub use crate::error::Error;\n-pub type Result<T> = core::result::Result<T, Error>;\n+pub type Result<T> = core::result::Result<T, error::Error>;\ndiff --git a/rustzx-core/src/settings.rs b/rustzx-core/src/settings.rs\nindex 637ace7..c60d79a 100644\n--- a/rustzx-core/src/settings.rs\n+++ b/rustzx-core/src/settings.rs\n@@ -1,17 +1,25 @@\n-use crate::{\n-    utils::EmulationSpeed,\n-    zx::{machine::ZXMachine, sound::ay::ZXAYMode},\n-};\n+use crate::{utils::EmulationSpeed, zx::machine::ZXMachine};\n+\n+#[cfg(all(feature = "sound", feature = "ay"))]\n+use crate::zx::sound::ay::ZXAYMode;\n \n pub struct RustzxSettings {\n     pub machine: ZXMachine,\n     pub emulation_speed: EmulationSpeed,\n     pub tape_fastload: bool,\n     pub enable_kempston: bool,\n+    #[cfg(all(feature = "sound", feature = "ay"))]\n     pub ay_mode: ZXAYMode,\n+    #[cfg(all(feature = "sound", feature = "ay"))]\n     pub ay_enabled: bool,\n+    #[cfg(feature = "sound")]\n     pub beeper_enabled: bool,\n+    #[cfg(feature = "sound")]\n     pub sound_enabled: bool,\n+    #[cfg(feature = "sound")]\n     pub sound_volume: u8,\n+    #[cfg(feature = "sound")]\n+    pub sound_sample_rate: usize,\n+    #[cfg(feature = "embedded-roms")]\n     pub load_default_rom: bool,\n }\ndiff --git a/rustzx-core/src/utils/events.rs b/rustzx-core/src/utils/events.rs\ndeleted file mode 100644\nindex a8eed0c..0000000\n--- a/rustzx-core/src/utils/events.rs\n+++ /dev/null\n@@ -1,50 +0,0 @@\n-use crate::utils::{Clocks, EmulationSpeed};\n-use alloc::collections::VecDeque;\n-\n-/// Type of happened event\n-pub enum EventKind {\n-    Accelerate(EmulationSpeed),\n-    Deaccelerate,\n-    FastTapeLoad,\n-}\n-\n-/// event, have information about kind and time of event\n-pub struct Event {\n-    pub kind: EventKind,\n-    pub time: Clocks,\n-}\n-\n-impl Event {\n-    /// constructs new event\n-    pub fn new(kind: EventKind, time: Clocks) -> Event {\n-        Event { kind, time }\n-    }\n-}\n-\n-/// Queue-based event container\n-#[derive(Default)]\n-pub struct EventQueue {\n-    deque: VecDeque<Event>,\n-}\n-\n-impl EventQueue {\n-    /// addd new event\n-    pub fn send_event(&mut self, e: Event) {\n-        self.deque.push_back(e);\n-    }\n-\n-    /// pops last event from deque\n-    pub fn receive_event(&mut self) -> Option<Event> {\n-        self.deque.pop_front()\n-    }\n-\n-    /// returns true if container is empty\n-    pub fn is_empty(&self) -> bool {\n-        self.deque.is_empty()\n-    }\n-\n-    /// removes all events\n-    pub fn clear(&mut self) {\n-        self.deque.clear();\n-    }\n-}\ndiff --git a/rustzx-core/src/utils/instantflag.rs b/rustzx-core/src/utils/instantflag.rs\ndeleted file mode 100644\nindex 7a7faa3..0000000\n--- a/rustzx-core/src/utils/instantflag.rs\n+++ /dev/null\n@@ -1,32 +0,0 @@\n-use core::cell::Cell;\n-\n-/// Instant flag - type, which resets self on immutable read\n-pub struct InstantFlag {\n-    f: Cell<bool>,\n-}\n-\n-impl InstantFlag {\n-    /// constructs self from initial value\n-    pub fn new(value: bool) -> InstantFlag {\n-        InstantFlag {\n-            f: Cell::new(value),\n-        }\n-    }\n-\n-    /// immutable read with reset\n-    pub fn pick(&self) -> bool {\n-        let value = self.f.get();\n-        self.f.set(false);\n-        value\n-    }\n-\n-    /// read, but not reset\n-    pub fn get_direct(&self) -> bool {\n-        self.f.get()\n-    }\n-\n-    /// set flag\n-    pub fn set(&mut self) {\n-        self.f.set(true);\n-    }\n-}\ndiff --git a/rustzx-core/src/utils/mod.rs b/rustzx-core/src/utils/mod.rs\nindex 9245209..1ed947e 100644\n--- a/rustzx-core/src/utils/mod.rs\n+++ b/rustzx-core/src/utils/mod.rs\n@@ -1,11 +1,10 @@\n //! Some emulator-related utils\n \n pub mod clocks;\n-pub mod events;\n-pub mod instantflag;\n pub mod screen;\n pub mod smallnum;\n-pub use self::{clocks::*, events::*, instantflag::*, smallnum::*};\n+\n+pub use self::{clocks::*, smallnum::*};\n \n #[derive(Copy, Clone)]\n pub enum EmulationSpeed {\ndiff --git a/rustzx-core/src/utils/screen.rs b/rustzx-core/src/utils/screen.rs\nindex 400585c..f19e097 100644\n--- a/rustzx-core/src/utils/screen.rs\n+++ b/rustzx-core/src/utils/screen.rs\n@@ -1,5 +1,5 @@\n use super::split_word;\n-use crate::zx::constants::*;\n+use crate::zx::constants::{ATTR_BASE_REL, ATTR_COLS, ATTR_MAX_REL, CANVAS_HEIGHT};\n \n /// Encode line number to read memory address\n pub fn bitmap_line_addr(line: usize) -> u16 {\ndiff --git a/rustzx-core/src/utils/smallnum.rs b/rustzx-core/src/utils/smallnum.rs\nindex 539327b..7c7be30 100644\n--- a/rustzx-core/src/utils/smallnum.rs\n+++ b/rustzx-core/src/utils/smallnum.rs\n@@ -4,6 +4,7 @@\n pub enum U1 {\n     N0, N1,\n }\n+\n impl U1 {\n     /// Constructs self from byte\n     /// # Panics\n@@ -24,12 +25,14 @@ impl U1 {\n         }\n     }\n }\n+\n #[derive(Clone, Copy, PartialEq, Eq)]\n #[rustfmt::skip]\n /// 2 bit unsigned\n pub enum U2 {\n     N0, N1, N2, N3,\n }\n+\n impl U2 {\n     /// Constructs self from byte\n     /// # Panics\n@@ -54,12 +57,14 @@ impl U2 {\n         }\n     }\n }\n+\n #[derive(Clone, Copy, PartialEq, Eq)]\n #[rustfmt::skip]\n /// 3 bit unsigned\n pub enum U3 {\n     N0, N1, N2, N3, N4, N5, N6, N7,\n }\n+\n impl U3 {\n     /// Constructs self from byte\n     /// # Panics\ndiff --git a/rustzx-core/src/z80/bus.rs b/rustzx-core/src/z80/bus.rs\nindex eaaec45..309dd2c 100644\n--- a/rustzx-core/src/z80/bus.rs\n+++ b/rustzx-core/src/z80/bus.rs\n@@ -1,4 +1,4 @@\n-use crate::utils::*;\n+use crate::utils::{make_word, split_word, Clocks};\n \n /// Z80 processor System bus\n /// Implement it for communication with CPU.\n@@ -61,8 +61,6 @@ pub trait Z80Bus {\n     fn int_active(&self) -> bool;\n     /// Checks nmi signal\n     fn nmi_active(&self) -> bool;\n-    /// Must return true if devices on bus invoked events\n-    fn instant_event(&self) -> bool;\n     /// invokes breakpoints check on bus device\n     fn pc_callback(&mut self, addr: u16);\n }\ndiff --git a/rustzx-core/src/z80/cpu.rs b/rustzx-core/src/z80/cpu.rs\nindex ef8a4e6..2fa1f81 100644\n--- a/rustzx-core/src/z80/cpu.rs\n+++ b/rustzx-core/src/z80/cpu.rs\n@@ -1,8 +1,11 @@\n //! Z80 CPU module\n \n use crate::{\n-    utils::*,\n-    z80::{opcodes::*, *},\n+    utils::{make_word, Clocks},\n+    z80::{\n+        opcodes::{execute_bits, execute_extended, execute_normal, execute_push_16, Opcode},\n+        IntMode, Prefix, RegName16, Regs, Z80Bus,\n+    },\n };\n \n /// Z80 Processor struct\n@@ -75,7 +78,7 @@ impl Z80 {\n     /// Main emulation step function\n     /// return `false` if execution can be continued or true if last event must be executed\n     /// instantly\n-    pub fn emulate(&mut self, bus: &mut dyn Z80Bus) -> bool {\n+    pub fn emulate(&mut self, bus: &mut dyn Z80Bus) {\n         // check interrupts\n         if !self.skip_interrupt {\n             // at first check nmi\n@@ -194,11 +197,7 @@ impl Z80 {\n             let opcode = Opcode::from_byte(byte1);\n             execute_normal(self, bus, opcode, Prefix::None);\n         };\n-        // check events on bus\n-        // if some events found, then signal that emulator must process events before\n-        // next cpu step\n+        // Allow bus implementation to process pc-based events\n         bus.pc_callback(self.regs.get_pc());\n-        // return true if events happened\n-        bus.instant_event()\n     }\n }\ndiff --git a/rustzx-core/src/z80/opcodes/group_bits.rs b/rustzx-core/src/z80/opcodes/group_bits.rs\nindex 944fe56..3775928 100644\n--- a/rustzx-core/src/z80/opcodes/group_bits.rs\n+++ b/rustzx-core/src/z80/opcodes/group_bits.rs\n@@ -1,7 +1,11 @@\n-use super::*;\n use crate::{\n-    utils::*,\n-    z80::{tables::*, *},\n+    utils::{bool_to_u8, word_displacement, Clocks, U2},\n+    z80::{\n+        opcodes::{execute_rot, BitOperand8, Opcode},\n+        tables::F3F5_TABLE,\n+        Prefix, RegName16, RegName8, Z80Bus, FLAG_CARRY, FLAG_HALF_CARRY, FLAG_PV, FLAG_SIGN,\n+        FLAG_ZERO, Z80,\n+    },\n };\n \n /// Instruction group which operatis with bits\ndiff --git a/rustzx-core/src/z80/opcodes/group_extended.rs b/rustzx-core/src/z80/opcodes/group_extended.rs\nindex dcac441..4048406 100644\n--- a/rustzx-core/src/z80/opcodes/group_extended.rs\n+++ b/rustzx-core/src/z80/opcodes/group_extended.rs\n@@ -1,7 +1,16 @@\n-use super::*;\n use crate::{\n-    utils::*,\n-    z80::{tables::*, *},\n+    utils::{bool_to_u8, Clocks, U1, U2, U3},\n+    z80::{\n+        opcodes::{\n+            execute_cpi_cpd, execute_ini_ind, execute_ldi_ldd, execute_outi_outd, execute_pop_16,\n+            BlockDir, Opcode,\n+        },\n+        tables::{\n+            lookup16_r12, lookup8_r12, HALF_CARRY_ADD_TABLE, HALF_CARRY_SUB_TABLE,\n+            OVERFLOW_ADD_TABLE, OVERFLOW_SUB_TABLE, SZF3F5_TABLE, SZPF3F5_TABLE,\n+        },\n+        Flag, IntMode, RegName16, RegName8, Z80Bus, FLAG_CARRY, FLAG_PV, FLAG_SUB, FLAG_ZERO, Z80,\n+    },\n };\n \n /// Extended instruction group (ED-prefixed)\ndiff --git a/rustzx-core/src/z80/opcodes/group_nonprefixed.rs b/rustzx-core/src/z80/opcodes/group_nonprefixed.rs\nindex 40db9aa..88d7088 100644\n--- a/rustzx-core/src/z80/opcodes/group_nonprefixed.rs\n+++ b/rustzx-core/src/z80/opcodes/group_nonprefixed.rs\n@@ -1,7 +1,14 @@\n-use super::*;\n use crate::{\n-    utils::*,\n-    z80::{tables::*, *},\n+    utils::{bool_to_u8, make_word, split_word, word_displacement, Clocks, U1, U2, U3},\n+    z80::{\n+        opcodes::{execute_alu_8, execute_pop_16, execute_push_16, LoadOperand8, Opcode},\n+        tables::{\n+            lookup16_r12, lookup8_r12, F3F5_TABLE, HALF_CARRY_ADD_TABLE, HALF_CARRY_SUB_TABLE,\n+            SZF3F5_TABLE, SZPF3F5_TABLE,\n+        },\n+        Condition, Flag, Prefix, RegName16, RegName8, Z80Bus, FLAG_CARRY, FLAG_F3, FLAG_F5,\n+        FLAG_HALF_CARRY, FLAG_PV, FLAG_SIGN, FLAG_SUB, FLAG_ZERO, Z80,\n+    },\n };\n \n /// normal execution group, can be modified with prefixes DD, FD, providing\ndiff --git a/rustzx-core/src/z80/opcodes/internal_alu.rs b/rustzx-core/src/z80/opcodes/internal_alu.rs\nindex b914b24..29f301d 100644\n--- a/rustzx-core/src/z80/opcodes/internal_alu.rs\n+++ b/rustzx-core/src/z80/opcodes/internal_alu.rs\n@@ -1,6 +1,12 @@\n use crate::{\n-    utils::*,\n-    z80::{tables::*, *},\n+    utils::{bool_to_u8, U3},\n+    z80::{\n+        tables::{\n+            lookup8_r12, F3F5_TABLE, HALF_CARRY_ADD_TABLE, HALF_CARRY_SUB_TABLE,\n+            OVERFLOW_ADD_TABLE, OVERFLOW_SUB_TABLE, PARITY_TABLE,\n+        },\n+        Flag, FLAG_CARRY, FLAG_HALF_CARRY, FLAG_SIGN, FLAG_SUB, FLAG_ZERO, Z80,\n+    },\n };\n \n /// 8-bit ALU operations\ndiff --git a/rustzx-core/src/z80/opcodes/internal_block.rs b/rustzx-core/src/z80/opcodes/internal_block.rs\nindex 250e68f..10e73b5 100644\n--- a/rustzx-core/src/z80/opcodes/internal_block.rs\n+++ b/rustzx-core/src/z80/opcodes/internal_block.rs\n@@ -1,7 +1,11 @@\n-use super::*;\n use crate::{\n-    utils::*,\n-    z80::{tables::*, *},\n+    utils::{bool_to_u8, Clocks},\n+    z80::{\n+        opcodes::BlockDir,\n+        tables::{lookup8_r12, HALF_CARRY_SUB_TABLE, PARITY_TABLE, SZF3F5_TABLE},\n+        RegName16, RegName8, Z80Bus, FLAG_CARRY, FLAG_F3, FLAG_F5, FLAG_HALF_CARRY, FLAG_PV,\n+        FLAG_SIGN, FLAG_SUB, FLAG_ZERO, Z80,\n+    },\n };\n \n /// ldi or ldd instruction\ndiff --git a/rustzx-core/src/z80/opcodes/internal_rot.rs b/rustzx-core/src/z80/opcodes/internal_rot.rs\nindex dfb8b52..592c2d3 100644\n--- a/rustzx-core/src/z80/opcodes/internal_rot.rs\n+++ b/rustzx-core/src/z80/opcodes/internal_rot.rs\n@@ -1,7 +1,6 @@\n-use super::*;\n use crate::{\n-    utils::*,\n-    z80::{tables::*, *},\n+    utils::{bool_to_u8, Clocks, U3},\n+    z80::{opcodes::BitOperand8, tables::SZPF3F5_TABLE, Flag, Z80Bus, FLAG_CARRY, Z80},\n };\n \n /// Rotate operations (RLC, RRC, RL, RR, SLA, SRA, SLL, SRL)\ndiff --git a/rustzx-core/src/z80/opcodes/internal_stack.rs b/rustzx-core/src/z80/opcodes/internal_stack.rs\nindex dbe63aa..ef924f7 100644\n--- a/rustzx-core/src/z80/opcodes/internal_stack.rs\n+++ b/rustzx-core/src/z80/opcodes/internal_stack.rs\n@@ -1,6 +1,6 @@\n use crate::{\n     utils::{make_word, split_word, Clocks},\n-    z80::*,\n+    z80::{RegName16, Z80Bus, Z80},\n };\n \n /// Pushes 16 bit value to the stack. Clocks count using for each byte write\ndiff --git a/rustzx-core/src/z80/opcodes/mod.rs b/rustzx-core/src/z80/opcodes/mod.rs\nindex 63eb7bf..6641900 100644\n--- a/rustzx-core/src/z80/opcodes/mod.rs\n+++ b/rustzx-core/src/z80/opcodes/mod.rs\n@@ -9,7 +9,7 @@ mod internal_rot;\n mod internal_stack;\n mod types;\n \n-// re-export all functions\n+// re-export all public functions\n pub use self::{\n     group_bits::*, group_extended::*, group_nonprefixed::*, internal_alu::*, internal_block::*,\n     internal_rot::*, internal_stack::*, types::*,\ndiff --git a/rustzx-core/src/z80/opcodes/types.rs b/rustzx-core/src/z80/opcodes/types.rs\nindex 721f762..ccbc1cf 100644\n--- a/rustzx-core/src/z80/opcodes/types.rs\n+++ b/rustzx-core/src/z80/opcodes/types.rs\n@@ -1,4 +1,7 @@\n-use crate::{utils::*, z80::*};\n+use crate::{\n+    utils::{U1, U2, U3},\n+    z80::RegName8,\n+};\n \n /// Operand for 8-bit LD instructions\n pub enum LoadOperand8 {\ndiff --git a/rustzx-core/src/z80/registers.rs b/rustzx-core/src/z80/registers.rs\nindex 89f433d..efcdb6c 100644\n--- a/rustzx-core/src/z80/registers.rs\n+++ b/rustzx-core/src/z80/registers.rs\n@@ -1,5 +1,8 @@\n //! Module which contains Z80 registers implementation\n-use crate::{utils::*, z80::Prefix};\n+use crate::{\n+    utils::{make_word, split_word, word_displacement, U2, U3},\n+    z80::Prefix,\n+};\n use core::fmt;\n \n // Flag register bits\ndiff --git a/rustzx-core/src/z80/tables/mod.rs b/rustzx-core/src/z80/tables/mod.rs\nindex 7cc515d..626f207 100644\n--- a/rustzx-core/src/z80/tables/mod.rs\n+++ b/rustzx-core/src/z80/tables/mod.rs\n@@ -1,6 +1,5 @@\n //! Contains internal emulator tables\n-\n-use crate::z80::registers::*;\n+use crate::z80::{FLAG_F3, FLAG_F5, FLAG_HALF_CARRY, FLAG_PV, FLAG_SIGN, FLAG_ZERO};\n use lazy_static::lazy_static;\n \n // TABLES FORM FUSE ZX SPECTRUM EMULATOR:\ndiff --git a/rustzx-core/src/zx/constants.rs b/rustzx-core/src/zx/constants.rs\nindex 3418e2b..1c3c510 100644\n--- a/rustzx-core/src/zx/constants.rs\n+++ b/rustzx-core/src/zx/constants.rs\n@@ -1,31 +1,31 @@\n //! Module contains constants\n-/// addresses\n-pub const BITMAP_BASE_ADDR: u16 = 0x4000;\n-pub const ATTR_BASE_ADDR: u16 = 0x5800;\n-pub const ATTR_MAX_ADDR: u16 = 0x5AFF;\n-/// relative addresses\n-pub const BITMAP_MAX_REL: u16 = 0x17FF;\n-pub const ATTR_BASE_REL: u16 = 0x1800;\n-pub const ATTR_MAX_REL: u16 = 0x1AFF;\n+\n /// main spectrum screen (canvas) constants\n pub const CANVAS_WIDTH: usize = 256;\n pub const CANVAS_HEIGHT: usize = 192;\n pub const CANVAS_X: usize = 32;\n pub const CANVAS_Y: usize = 24;\n-/// on all spectrums theese values are fixed\n-pub const CLOCKS_PER_COL: usize = 4;\n-pub const PIXELS_PER_CLOCK: usize = 2;\n-/// size of screen in rows, cols\n-pub const ATTR_COLS: usize = CANVAS_WIDTH / 8;\n-pub const ATTR_ROWS: usize = CANVAS_HEIGHT / 8;\n-pub const BORDER_COLS: usize = 4;\n-pub const BORDER_ROWS: usize = 3;\n /// canvas (emulated screen) constants\n pub const SCREEN_WIDTH: usize = CANVAS_WIDTH + BORDER_COLS * 8 * 2;\n pub const SCREEN_HEIGHT: usize = CANVAS_HEIGHT + BORDER_ROWS * 8 * 2;\n-pub const PIXEL_COUNT: usize = SCREEN_HEIGHT * SCREEN_WIDTH;\n-pub const BYTES_PER_PIXEL: usize = 4;\n /// Frames per second\n pub const FPS: usize = 50;\n+\n+/// addresses\n+pub(crate) const BITMAP_BASE_ADDR: u16 = 0x4000;\n+pub(crate) const ATTR_BASE_ADDR: u16 = 0x5800;\n+pub(crate) const ATTR_MAX_ADDR: u16 = 0x5AFF;\n+/// relative addresses\n+pub(crate) const BITMAP_MAX_REL: u16 = 0x17FF;\n+pub(crate) const ATTR_BASE_REL: u16 = 0x1800;\n+pub(crate) const ATTR_MAX_REL: u16 = 0x1AFF;\n+/// on all spectrums theese values are fixed\n+pub(crate) const CLOCKS_PER_COL: usize = 4;\n+pub(crate) const PIXELS_PER_CLOCK: usize = 2;\n+/// size of screen in rows, cols\n+pub(crate) const ATTR_COLS: usize = CANVAS_WIDTH / 8;\n+pub(crate) const ATTR_ROWS: usize = CANVAS_HEIGHT / 8;\n+pub(crate) const BORDER_COLS: usize = 4;\n+pub(crate) const BORDER_ROWS: usize = 3;\n /// Tape loading trap at LD-BREAK routine in ROM\n-pub const ADDR_LD_BREAK: u16 = 0x056B;\n+pub(crate) const ADDR_LD_BREAK: u16 = 0x056B;\ndiff --git a/rustzx-core/src/zx/controller.rs b/rustzx-core/src/zx/controller.rs\nindex 218a6fe..793fb83 100644\n--- a/rustzx-core/src/zx/controller.rs\n+++ b/rustzx-core/src/zx/controller.rs\n@@ -1,63 +1,64 @@\n //! Contains ZX Spectrum System contrller (like ula or so) of emulator\n use crate::{\n-    host::Host,\n+    error::Error,\n+    host::{Host, HostContext},\n     settings::RustzxSettings,\n-    utils::{events::*, screen::*, split_word, Clocks, InstantFlag},\n+    utils::{screen::bitmap_line_addr, split_word, Clocks},\n     z80::Z80Bus,\n     zx::{\n-        constants::*,\n-        joy::kempston::*,\n+        constants::{ADDR_LD_BREAK, CANVAS_HEIGHT, CLOCKS_PER_COL},\n+        events::EmulationEvents,\n+        joy::kempston::KempstonJoy,\n+        keys::ZXKey,\n         machine::ZXMachine,\n-        memory::{Page, PAGE_SIZE},\n-        roms::*,\n-        screen::{\n-            border::ZXBorder,\n-            canvas::ZXCanvas,\n-            colors::{ZXColor, ZXPalette},\n-        },\n-        sound::mixer::ZXMixer,\n-        tape::{Tap, TapeImpl, ZXTape},\n-        RamType, RomType, ZXKey, ZXMemory,\n+        memory::{Page, RamType, RomType, ZXMemory, PAGE_SIZE},\n+        tape::{TapeImpl, ZXTape},\n+        video::{colors::ZXColor, screen::ZXScreen},\n     },\n };\n \n-// TODO(#57): Feature gates for resource-heavy features\n+#[cfg(feature = "embedded-roms")]\n+use crate::zx::roms;\n+#[cfg(feature = "sound")]\n+use crate::zx::sound::mixer::ZXMixer;\n+#[cfg(feature = "precise-border")]\n+use crate::zx::video::border::ZXBorder;\n \n /// ZX System controller\n-pub struct ZXController<H: Host> {\n+pub(crate) struct ZXController<H: Host> {\n     // parts of ZX Spectum.\n     pub machine: ZXMachine,\n     pub memory: ZXMemory,\n-    pub canvas: ZXCanvas,\n-    pub tape: ZXTape,\n-    pub border: ZXBorder,\n+    pub screen: ZXScreen<H::FrameBuffer>,\n+    pub tape: ZXTape<H::TapeAsset>,\n+    #[cfg(feature = "precise-border")]\n+    pub border: ZXBorder<H::FrameBuffer>,\n     pub kempston: Option<KempstonJoy>,\n-    // pub beeper: ZXBeeper,\n+    #[cfg(feature = "sound")]\n     pub mixer: ZXMixer,\n     pub keyboard: [u8; 8],\n     // current border color\n-    border_color: u8,\n+    pub border_color: ZXColor,\n     // clocls count from frame start\n     frame_clocks: Clocks,\n     // frames count, which passed during emulation invokation\n     passed_frames: usize,\n-    // main event queue\n-    events: EventQueue,\n-    // flag, which signals emulator to break emulation and process last event immediately\n-    instant_event: InstantFlag,\n+    events: EmulationEvents,\n     // audio in\n     mic: bool,\n     // audio out\n     ear: bool,\n     paging_enabled: bool,\n     screen_bank: u8,\n-    // `H` will be used when components e.g. Tap type will depend on host impl\n-    _phantom: core::marker::PhantomData<H>,\n+    // Z80 module expected controller implementation without errors,\n+    // so we need to store the internal errors manually. For sake of simplicity,\n+    // Only last error is saved\n+    last_emulation_error: Option<Error>,\n }\n \n impl<H: Host> ZXController<H> {\n     /// Returns new ZXController from settings\n-    pub fn new(settings: &RustzxSettings) -> Self {\n+    pub fn new(settings: &RustzxSettings, host_context: H::Context) -> Self {\n         let (memory, paging, screen_bank);\n         match settings.machine {\n             ZXMachine::Sinclair48K => {\n@@ -76,36 +77,60 @@ impl<H: Host> ZXController<H> {\n         } else {\n             None\n         };\n-        let mut out = ZXController {\n+\n+        let screen = ZXScreen::new(settings.machine, host_context.frame_buffer_context());\n+        #[cfg(feature = "precise-border")]\n+        let border = ZXBorder::new(settings.machine, host_context.frame_buffer_context());\n+\n+        #[cfg(feature = "sound")]\n+        let mixer = Self::create_mixer(settings);\n+\n+        let out = ZXController {\n             machine: settings.machine,\n             memory,\n-            canvas: ZXCanvas::new(settings.machine),\n-            border: ZXBorder::new(settings.machine, ZXPalette::default()),\n+            screen,\n+            #[cfg(feature = "precise-border")]\n+            border,\n             kempston,\n-            mixer: ZXMixer::new(settings.beeper_enabled, settings.ay_enabled),\n+            #[cfg(feature = "sound")]\n+            mixer,\n             keyboard: [0xFF; 8],\n-            border_color: 0x00,\n+            border_color: ZXColor::Black,\n             frame_clocks: Clocks(0),\n             passed_frames: 0,\n-            tape: Tap::default().into(),\n-            events: EventQueue::default(),\n-            instant_event: InstantFlag::new(false),\n+            tape: Default::default(),\n+            events: Default::default(),\n             mic: false,\n             ear: false,\n             paging_enabled: paging,\n             screen_bank,\n-            _phantom: core::marker::PhantomData::default(),\n+            last_emulation_error: None,\n         };\n-        out.mixer.ay.mode(settings.ay_mode);\n-        out.mixer.volume(settings.sound_volume as f64 / 200.0);\n \n+        #[cfg(feature = "embedded-roms")]\n         if settings.load_default_rom {\n+            let mut out = out;\n             out.load_default_rom();\n+            return out;\n         }\n \n         out\n     }\n \n+    #[cfg(feature = "sound")]\n+    fn create_mixer(settings: &RustzxSettings) -> ZXMixer {\n+        let mut mixer = ZXMixer::new(\n+            settings.beeper_enabled,\n+            #[cfg(feature = "ay")]\n+            settings.ay_enabled,\n+            settings.sound_sample_rate,\n+        );\n+        #[cfg(feature = "ay")]\n+        mixer.ay.mode(settings.ay_mode);\n+        mixer.volume(settings.sound_volume as f64 / 200.0);\n+        mixer\n+    }\n+\n     /// returns current frame emulation pos in percents\n     fn frame_pos(&self) -> f64 {\n         let val = self.frame_clocks.count() as f64 / self.machine.specs().clocks_frame as f64;\n@@ -117,40 +142,28 @@ impl<H: Host> ZXController<H> {\n     }\n \n     /// loads builted-in ROM\n+    #[cfg(feature = "embedded-roms")]\n     fn load_default_rom(&mut self) {\n         match self.machine {\n             ZXMachine::Sinclair48K => {\n                 let page = self.memory.rom_page_data_mut(0);\n-                page.copy_from_slice(ROM_48K);\n+                page.copy_from_slice(roms::ROM_48K);\n             }\n             ZXMachine::Sinclair128K => {\n                 let page = self.memory.rom_page_data_mut(0);\n-                page.copy_from_slice(ROM_128K_0);\n+                page.copy_from_slice(roms::ROM_128K_0);\n                 let page = self.memory.rom_page_data_mut(1);\n-                page.copy_from_slice(ROM_128K_1);\n+                page.copy_from_slice(roms::ROM_128K_1);\n             }\n         }\n     }\n \n     /// Changes key state in controller\n     pub fn send_key(&mut self, key: ZXKey, pressed: bool) {\n-        // TODO(#49): Move row detection to ZXKey type\n-        let rownum = match key.half_port {\n-            0xFE => Some(0),\n-            0xFD => Some(1),\n-            0xFB => Some(2),\n-            0xF7 => Some(3),\n-            0xEF => Some(4),\n-            0xDF => Some(5),\n-            0xBF => Some(6),\n-            0x7F => Some(7),\n-            _ => None,\n-        };\n-        if let Some(rownum) = rownum {\n-            self.keyboard[rownum] &= !key.mask;\n-            if !pressed {\n-                self.keyboard[rownum] |= key.mask;\n-            }\n+        let row_id = key.row_id();\n+        self.keyboard[row_id] &= !key.mask();\n+        if !pressed {\n+            self.keyboard[row_id] |= key.mask();\n         }\n     }\n \n@@ -224,24 +237,21 @@ impl<H: Host> ZXController<H> {\n     /// Starts a new frame\n     fn new_frame(&mut self) {\n         self.frame_clocks -= self.machine.specs().clocks_frame;\n-        self.canvas.new_frame();\n+        self.screen.new_frame();\n+        #[cfg(feature = "precise-border")]\n         self.border.new_frame();\n+        #[cfg(feature = "sound")]\n         self.mixer.new_frame();\n     }\n \n-    /// force clears all events\n+    /// Clears all detected\n     pub fn clear_events(&mut self) {\n         self.events.clear();\n     }\n \n-    /// check events count\n-    pub fn no_events(&self) -> bool {\n-        self.events.is_empty()\n-    }\n-\n-    /// Returns last event\n-    pub fn pop_event(&mut self) -> Option<Event> {\n-        self.events.receive_event()\n+    /// Returns last events\n+    pub fn events(&self) -> EmulationEvents {\n+        self.events\n     }\n \n     /// Returns true if all frame clocks has been passed\n@@ -267,7 +277,7 @@ impl<H: Host> ZXController<H> {\n         // third block is not pageable\n         // second block is screen buffer, not pageable. but we need to change active buffer\n         let new_screen_bank = if val & 0x08 == 0 { 5 } else { 7 };\n-        self.canvas.switch_bank(new_screen_bank as usize);\n+        self.screen.switch_bank(new_screen_bank as usize);\n         self.screen_bank = new_screen_bank;\n         // remap ROM\n         self.memory.remap(0, Page::Rom((val >> 4) & 0x01));\n@@ -276,6 +286,46 @@ impl<H: Host> ZXController<H> {\n             self.paging_enabled = false;\n         }\n     }\n+\n+    #[cfg(all(feature = "sound", feature = "ay"))]\n+    fn read_ay_port(&mut self) -> u8 {\n+        self.mixer.ay.read()\n+    }\n+\n+    #[cfg(not(all(feature = "sound", feature = "ay")))]\n+    fn read_ay_port(&mut self) -> u8 {\n+        self.floating_bus_value()\n+    }\n+\n+    #[cfg(all(feature = "sound", feature = "ay"))]\n+    fn write_ay_port(&mut self, value: u8) {\n+        self.mixer.ay.write(value);\n+    }\n+\n+    #[cfg(not(all(feature = "sound", feature = "ay")))]\n+    fn write_ay_port(&mut self, _: u8) {}\n+\n+    #[cfg(all(feature = "sound", feature = "ay"))]\n+    fn select_ay_reg(&mut self, value: u8) {\n+        self.mixer.ay.select_reg(value)\n+    }\n+\n+    #[cfg(not(all(feature = "sound", feature = "ay")))]\n+    fn select_ay_reg(&mut self, _: u8) {}\n+\n+    pub(crate) fn set_border_color(\n+        &mut self,\n+        #[allow(unused_variables)] clocks: Clocks,\n+        color: ZXColor,\n+    ) {\n+        self.border_color = color;\n+        #[cfg(feature = "precise-border")]\n+        self.border.set_border(clocks, color);\n+    }\n+\n+    pub(crate) fn take_last_emulation_error(&mut self) -> Option<Error> {\n+        self.last_emulation_error.take()\n+    }\n }\n \n impl<H: Host> Z80Bus for ZXController<H> {\n@@ -293,9 +343,7 @@ impl<H: Host> Z80Bus for ZXController<H> {\n             if addr == ADDR_LD_BREAK {\n                 // Add event (Fast tape loading request) it must be executed\n                 // by emulator immediately\n-                self.events\n-                    .send_event(Event::new(EventKind::FastTapeLoad, self.frame_clocks));\n-                self.instant_event.set();\n+                self.events |= EmulationEvents::TAPE_FAST_LOAD_TRIGGER_DETECTED;\n             }\n         }\n     }\n@@ -310,7 +358,7 @@ impl<H: Host> Z80Bus for ZXController<H> {\n         self.memory.write(addr, data);\n         // if ram then compare bank to screen bank\n         if let Page::Ram(bank) = self.memory.get_page(addr) {\n-            self.canvas\n+            self.screen\n                 .update(addr % PAGE_SIZE as u16, bank as usize, data);\n         }\n     }\n@@ -318,13 +366,18 @@ impl<H: Host> Z80Bus for ZXController<H> {\n     /// Cahnges internal state on clocks count change (emualtion processing)\n     fn wait_internal(&mut self, clk: Clocks) {\n         self.frame_clocks += clk;\n-        self.tape.process_clocks(clk);\n+        if let Err(e) = self.tape.process_clocks(clk) {\n+            self.last_emulation_error = Some(e);\n+        }\n         let mic = self.tape.current_bit();\n         self.mic = mic;\n-        let pos = self.frame_pos();\n-        self.mixer.beeper.change_bit(self.mic | self.ear);\n-        self.mixer.process(pos);\n-        self.canvas.process_clocks(self.frame_clocks);\n+        #[cfg(feature = "sound")]\n+        {\n+            let pos = self.frame_pos();\n+            self.mixer.beeper.change_bit(self.mic | self.ear);\n+            self.mixer.process(pos);\n+        }\n+        self.screen.process_clocks(self.frame_clocks);\n         if self.frame_clocks.count() >= self.machine.specs().clocks_frame {\n             self.new_frame();\n             self.passed_frames += 1;\n@@ -373,8 +426,7 @@ impl<H: Host> Z80Bus for ZXController<H> {\n             // 5 and 7 unused\n             tmp\n         } else if port & 0xC002 == 0xC000 {\n-            // AY regs\n-            self.mixer.ay.read()\n+            self.read_ay_port()\n         } else if self.kempston.is_some() && (port & 0x0020 == 0) {\n             if let Some(ref joy) = self.kempston {\n                 joy.read()\n@@ -395,15 +447,14 @@ impl<H: Host> Z80Bus for ZXController<H> {\n         self.io_contention_first(port);\n         // find active port\n         if port & 0xC002 == 0xC000 {\n-            self.mixer.ay.select_reg(data);\n+            self.select_ay_reg(data);\n         } else if port & 0xC002 == 0x8000 {\n-            self.mixer.ay.write(data);\n+            self.write_ay_port(data);\n         } else if port & 0x0001 == 0 {\n-            self.border_color = data & 0x07;\n-            self.border\n-                .set_border(self.frame_clocks, ZXColor::from_bits(data & 0x07));\n+            self.set_border_color(self.frame_clocks, ZXColor::from_bits(data & 0x07));\n             self.mic = data & 0x08 != 0;\n             self.ear = data & 0x10 != 0;\n+            #[cfg(feature = "sound")]\n             self.mixer.beeper.change_bit(self.mic | self.ear);\n         } else if (port & 0x8002 == 0) && (self.machine == ZXMachine::Sinclair128K) {\n             self.write_7ffd(data);\n@@ -435,9 +486,4 @@ impl<H: Host> Z80Bus for ZXController<H> {\n \n     /// CPU calls when was being halted\n     fn halt(&mut self, _: bool) {}\n-\n-    /// checks instant events\n-    fn instant_event(&self) -> bool {\n-        self.instant_event.pick()\n-    }\n }\ndiff --git a/rustzx-core/src/zx/events.rs b/rustzx-core/src/zx/events.rs\nnew file mode 100644\nindex 0000000..7a5951b\n--- /dev/null\n+++ b/rustzx-core/src/zx/events.rs\n@@ -0,0 +1,14 @@\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    #[derive(Default)]\n+    pub struct EmulationEvents: u8 {\n+        const TAPE_FAST_LOAD_TRIGGER_DETECTED = 0b00000001;\n+    }\n+}\n+\n+impl EmulationEvents {\n+    pub fn clear(&mut self) {\n+        self.bits = 0;\n+    }\n+}\ndiff --git a/rustzx-core/src/zx/joy/kempston.rs b/rustzx-core/src/zx/joy/kempston.rs\nindex 27a025a..585bb50 100644\n--- a/rustzx-core/src/zx/joy/kempston.rs\n+++ b/rustzx-core/src/zx/joy/kempston.rs\n@@ -9,7 +9,7 @@ pub enum KempstonKey {\n \n /// Kempston Joystick\n #[derive(Default)]\n-pub struct KempstonJoy {\n+pub(crate) struct KempstonJoy {\n     state: u8,\n }\n \ndiff --git a/rustzx-core/src/zx/keys.rs b/rustzx-core/src/zx/keys.rs\nindex 4e3950b..1919c6d 100644\n--- a/rustzx-core/src/zx/keys.rs\n+++ b/rustzx-core/src/zx/keys.rs\n@@ -1,55 +1,64 @@\n //! Module with hardware key port\\masks\n \n /// Struct, which contains mast and port of key\n-pub struct ZXKey {\n-    pub half_port: u8,\n-    pub mask: u8,\n+#[rustfmt::skip]\n+#[derive(Clone, Copy)]\n+pub enum ZXKey {\n+    // Port 0xFEFE\n+    Shift, Z, X, C, V,\n+    // Port 0xFDFE\n+    A, S, D, F, G,\n+    // Port 0xFBFE\n+    Q, W, E, R, T,\n+    // Port 0xF7FE\n+    N1, N2, N3, N4, N5,\n+    // Port 0xEFFE\n+    N0, N9, N8, N7, N6,\n+    // Port 0xDFFE\n+    P, O, I, U, Y,\n+    // Port 0xBFFE\n+    Enter, L, K, J, H,\n+    // Port 0x7FFE\n+    Space, SymShift, M, N, B,\n+}\n+\n+impl ZXKey {\n+    pub(crate) fn row_id(self) -> usize {\n+        match self.half_port() {\n+            0xFE => 0,\n+            0xFD => 1,\n+            0xFB => 2,\n+            0xF7 => 3,\n+            0xEF => 4,\n+            0xDF => 5,\n+            0xBF => 6,\n+            0x7F => 7,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    pub(crate) fn mask(&self) -> u8 {\n+        use ZXKey::*;\n+        match self {\n+            Shift | A | Q | N1 | N0 | P | Enter | Space => 0x01,\n+            Z | S | W | N2 | N9 | O | L | SymShift => 0x02,\n+            X | D | E | N3 | N8 | I | K | M => 0x04,\n+            C | F | R | N4 | N7 | U | J | N => 0x08,\n+            V | G | T | N5 | N6 | Y | H | B => 0x10,\n+        }\n+    }\n+\n+    fn half_port(self) -> u8 {\n+        use ZXKey::*;\n+        match self {\n+            Shift | Z | X | C | V => 0xFE,\n+            A | S | D | F | G => 0xFD,\n+            Q | W | E | R | T => 0xFB,\n+            N1 | N2 | N3 | N4 | N5 => 0xF7,\n+            N0 | N9 | N8 | N7 | N6 => 0xEF,\n+            P | O | I | U | Y => 0xDF,\n+            Enter | L | K | J | H => 0xBF,\n+            Space | SymShift | M | N | B => 0x7F,\n+        }\n+    }\n }\n-// 0xFEFE\n-pub const ZX_KEY_SHIFT: ZXKey = ZXKey { half_port: 0xFE, mask: 0x01 };\n-pub const ZX_KEY_Z: ZXKey = ZXKey { half_port: 0xFE, mask: 0x02 };\n-pub const ZX_KEY_X: ZXKey = ZXKey { half_port: 0xFE, mask: 0x04 };\n-pub const ZX_KEY_C: ZXKey = ZXKey { half_port: 0xFE, mask: 0x08 };\n-pub const ZX_KEY_V: ZXKey = ZXKey { half_port: 0xFE, mask: 0x10 };\n-// FDFE\n-pub const ZX_KEY_A: ZXKey = ZXKey { half_port: 0xFD, mask: 0x01 };\n-pub const ZX_KEY_S: ZXKey = ZXKey { half_port: 0xFD, mask: 0x02 };\n-pub const ZX_KEY_D: ZXKey = ZXKey { half_port: 0xFD, mask: 0x04 };\n-pub const ZX_KEY_F: ZXKey = ZXKey { half_port: 0xFD, mask: 0x08 };\n-pub const ZX_KEY_G: ZXKey = ZXKey { half_port: 0xFD, mask: 0x10 };\n-// FBFE\n-pub const ZX_KEY_Q: ZXKey = ZXKey { half_port: 0xFB, mask: 0x01 };\n-pub const ZX_KEY_W: ZXKey = ZXKey { half_port: 0xFB, mask: 0x02 };\n-pub const ZX_KEY_E: ZXKey = ZXKey { half_port: 0xFB, mask: 0x04 };\n-pub const ZX_KEY_R: ZXKey = ZXKey { half_port: 0xFB, mask: 0x08 };\n-pub const ZX_KEY_T: ZXKey = ZXKey { half_port: 0xFB, mask: 0x10 };\n-// F7FE\n-pub const ZX_KEY_1: ZXKey = ZXKey { half_port: 0xF7, mask: 0x01 };\n-pub const ZX_KEY_2: ZXKey = ZXKey { half_port: 0xF7, mask: 0x02 };\n-pub const ZX_KEY_3: ZXKey = ZXKey { half_port: 0xF7, mask: 0x04 };\n-pub const ZX_KEY_4: ZXKey = ZXKey { half_port: 0xF7, mask: 0x08 };\n-pub const ZX_KEY_5: ZXKey = ZXKey { half_port: 0xF7, mask: 0x10 };\n-// EFFE\n-pub const ZX_KEY_0: ZXKey = ZXKey { half_port: 0xEF, mask: 0x01 };\n-pub const ZX_KEY_9: ZXKey = ZXKey { half_port: 0xEF, mask: 0x02 };\n-pub const ZX_KEY_8: ZXKey = ZXKey { half_port: 0xEF, mask: 0x04 };\n-pub const ZX_KEY_7: ZXKey = ZXKey { half_port: 0xEF, mask: 0x08 };\n-pub const ZX_KEY_6: ZXKey = ZXKey { half_port: 0xEF, mask: 0x10 };\n-//DFFE\n-pub const ZX_KEY_P: ZXKey = ZXKey { half_port: 0xDF, mask: 0x01 };\n-pub const ZX_KEY_O: ZXKey = ZXKey { half_port: 0xDF, mask: 0x02 };\n-pub const ZX_KEY_I: ZXKey = ZXKey { half_port: 0xDF, mask: 0x04 };\n-pub const ZX_KEY_U: ZXKey = ZXKey { half_port: 0xDF, mask: 0x08 };\n-pub const ZX_KEY_Y: ZXKey = ZXKey { half_port: 0xDF, mask: 0x10 };\n-// BFFE\n-pub const ZX_KEY_ENTER: ZXKey = ZXKey { half_port: 0xBF, mask: 0x01 };\n-pub const ZX_KEY_L: ZXKey = ZXKey { half_port: 0xBF, mask: 0x02 };\n-pub const ZX_KEY_K: ZXKey = ZXKey { half_port: 0xBF, mask: 0x04 };\n-pub const ZX_KEY_J: ZXKey = ZXKey { half_port: 0xBF, mask: 0x08 };\n-pub const ZX_KEY_H: ZXKey = ZXKey { half_port: 0xBF, mask: 0x10 };\n-// 7FFE\n-pub const ZX_KEY_SPACE: ZXKey = ZXKey { half_port: 0x7F, mask: 0x01 };\n-pub const ZX_KEY_SYM_SHIFT: ZXKey = ZXKey { half_port: 0x7F, mask: 0x02 };\n-pub const ZX_KEY_M: ZXKey = ZXKey { half_port: 0x7F, mask: 0x04 };\n-pub const ZX_KEY_N: ZXKey = ZXKey { half_port: 0x7F, mask: 0x08 };\n-pub const ZX_KEY_B: ZXKey = ZXKey { half_port: 0x7F, mask: 0x10 };\ndiff --git a/rustzx-core/src/zx/machine/mod.rs b/rustzx-core/src/zx/machine/mod.rs\nindex 16c666c..2043525 100644\n--- a/rustzx-core/src/zx/machine/mod.rs\n+++ b/rustzx-core/src/zx/machine/mod.rs\n@@ -2,14 +2,16 @@\n \n // Allow outer modules to use ZXSpecs struct, but not construct\n mod specs;\n-pub use self::specs::ZXSpecs;\n-use self::specs::ZXSpecsBuilder;\n+\n use crate::utils::Clocks;\n use lazy_static::lazy_static;\n+use specs::ZXSpecsBuilder;\n+\n+pub(crate) use specs::ZXSpecs;\n \n lazy_static! {\n     /// ZX Spectrum 48K Specs\n-    pub static ref SPECS_48K: ZXSpecs = {\n+    pub(crate) static ref SPECS_48K: ZXSpecs = {\n         ZXSpecsBuilder::new()\n             .freq_cpu(3_500_000)\n             .clocks_first_pixel(14336)\ndiff --git a/rustzx-core/src/zx/machine/specs.rs b/rustzx-core/src/zx/machine/specs.rs\nindex 350bb77..6ff7561 100644\n--- a/rustzx-core/src/zx/machine/specs.rs\n+++ b/rustzx-core/src/zx/machine/specs.rs\n@@ -1,7 +1,3 @@\n-use crate::zx::constants::BORDER_COLS;\n-use alloc::{vec, vec::Vec};\n-\n-/// Immutable type (Builder is not public in outer module)\n pub struct ZXSpecs {\n     // frequencies\n     pub freq_cpu: usize,\n@@ -13,7 +9,6 @@ pub struct ZXSpecs {\n     pub clocks_right_border: usize,\n     pub clocks_retrace: usize,\n     pub clocks_line: usize,\n-    pub clocks_line_base: Vec<usize>,\n     // some ula clocks\n     pub clocks_ula_read_shift: usize,\n     pub clocks_ula_read_origin: usize,\n@@ -54,7 +49,6 @@ impl ZXSpecsBuilder {\n                 clocks_right_border: 0,\n                 clocks_retrace: 0,\n                 clocks_line: 0,\n-                clocks_line_base: vec![],\n                 // some ula clocks\n                 clocks_ula_read_shift: 0,\n                 clocks_ula_read_origin: 0,\n@@ -83,19 +77,6 @@ impl ZXSpecsBuilder {\n     pub fn build(mut self) -> ZXSpecs {\n         self.specs.clocks_frame =\n             (self.specs.lines_all + self.specs.lines_vsync) * self.specs.clocks_line;\n-        // 4*4 is 4 border columns * 4 clocks per column\n-        self.specs.clocks_line_base.push(\n-            self.specs.clocks_first_pixel\n-                - self.specs.lines_top_border * self.specs.clocks_line\n-                - BORDER_COLS * 4,\n-        );\n-        // + 1 because TStates in calculations may be > frame length (CHECK)\n-        let lines_count = self.specs.lines_all + 1;\n-        for _ in 1..lines_count {\n-            let last = *self.specs.clocks_line_base.last().unwrap();\n-            let line_clocks = self.specs.clocks_line;\n-            self.specs.clocks_line_base.push(last + line_clocks);\n-        }\n         self.specs.clocks_ula_read_origin =\n             self.specs.clocks_first_pixel + self.specs.clocks_ula_read_shift;\n         self.specs.clocks_ula_contention_origin =\ndiff --git a/rustzx-core/src/zx/mod.rs b/rustzx-core/src/zx/mod.rs\nindex b3de060..f591012 100644\n--- a/rustzx-core/src/zx/mod.rs\n+++ b/rustzx-core/src/zx/mod.rs\n@@ -1,24 +1,16 @@\n //! Module with ZX Spectrum related things\n //! One of core platform-independent modules\n+pub(crate) mod controller;\n+pub(crate) mod events;\n+pub(crate) mod memory;\n+#[cfg(feature = "embedded-roms")]\n+pub(crate) mod roms;\n+pub(crate) mod tape;\n+\n pub mod constants;\n-pub mod controller;\n pub mod joy;\n-#[rustfmt::skip]\n pub mod keys;\n pub mod machine;\n-pub mod memory;\n-pub mod roms;\n-pub mod screen;\n+#[cfg(feature = "sound")]\n pub mod sound;\n-pub mod tape;\n-\n-// re-export most of things\n-// TODO(#48): Reorganize imports\n-pub use self::{\n-    controller::ZXController,\n-    keys::*,\n-    machine::{ZXMachine, ZXSpecs},\n-    memory::{RamType, RomType, ZXMemory},\n-    screen::*,\n-    tape::ZXTape,\n-};\n+pub mod video;\ndiff --git a/rustzx-core/src/zx/screen/colors.rs b/rustzx-core/src/zx/screen/colors.rs\ndeleted file mode 100644\nindex b40deca..0000000\n--- a/rustzx-core/src/zx/screen/colors.rs\n+++ /dev/null\n@@ -1,163 +0,0 @@\n-//! Contains Color generation related types\n-use crate::zx::constants::BYTES_PER_PIXEL;\n-\n-/// struct represents single pixel color as array of bytes\n-pub type ColorArray = [u8; BYTES_PER_PIXEL];\n-\n-/// splits usize value to 4 bytes\n-#[rustfmt::skip]\n-fn split_in_bytes(val: usize) -> ColorArray {\n-    [\n-        ((val >> 24) & 0xFF) as u8,\n-        ((val >> 16) & 0xFF) as u8,\n-        ((val >>  8) & 0xFF) as u8,\n-        (val & 0xFF) as u8\n-    ]\n-}\n-\n-/// Represents color brightness\n-#[derive(Clone, Copy)]\n-pub enum ZXBrightness {\n-    Normal,\n-    Bright,\n-}\n-\n-/// ZX Spectrum color enum\n-/// Constructs self from 3-bit value\n-#[derive(Clone, Copy)]\n-pub enum ZXColor {\n-    Black,\n-    Blue,\n-    Red,\n-    Purple,\n-    Green,\n-    Cyan,\n-    Yellow,\n-    White,\n-}\n-\n-impl ZXColor {\n-    /// Returns ZXColor from 3 bits\n-    /// # Panics\n-    /// Panics when input color is bigger than 7\n-    pub fn from_bits(bits: u8) -> ZXColor {\n-        assert!(bits <= 7);\n-        match bits {\n-            0 => ZXColor::Black,\n-            1 => ZXColor::Blue,\n-            2 => ZXColor::Red,\n-            3 => ZXColor::Purple,\n-            4 => ZXColor::Green,\n-            5 => ZXColor::Cyan,\n-            6 => ZXColor::Yellow,\n-            7 => ZXColor::White,\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n-/// ZX Spectrum attribute structure\n-/// It contains information about ink, paper color,\n-/// flash attribute and brightness\n-#[derive(Clone, Copy)]\n-pub struct ZXAttribute {\n-    pub ink: ZXColor,\n-    pub paper: ZXColor,\n-    pub brightness: ZXBrightness,\n-    pub flash: bool,\n-}\n-\n-impl ZXAttribute {\n-    /// Constructs self from byte\n-    pub fn from_byte(data: u8) -> ZXAttribute {\n-        ZXAttribute {\n-            ink: ZXColor::from_bits(data & 0x07),\n-            paper: ZXColor::from_bits((data >> 3) & 0x07),\n-            flash: (data & 0x80) != 0,\n-            brightness: if (data & 0x40) != 0 {\n-                ZXBrightness::Bright\n-            } else {\n-                ZXBrightness::Normal\n-            },\n-        }\n-    }\n-\n-    /// Returns active color of pixel in current attribute\n-    pub fn active_color(&self, state: bool, enable_flash: bool) -> ZXColor {\n-        if state ^ (self.flash && enable_flash) {\n-            self.ink\n-        } else {\n-            self.paper\n-        }\n-    }\n-}\n-\n-/// represents set of colors\n-struct ColorSet {\n-    black: ColorArray,\n-    blue: ColorArray,\n-    red: ColorArray,\n-    purple: ColorArray,\n-    green: ColorArray,\n-    cyan: ColorArray,\n-    yellow: ColorArray,\n-    white: ColorArray,\n-}\n-/// Structure, that holds palette information.\n-/// It have method to transform ZX Spectrum screen data\n-/// to 4-byte rgba bixel\n-pub struct ZXPalette {\n-    transparent: ColorArray,\n-    // 2 color sets\n-    bright: ColorSet,\n-    normal: ColorSet,\n-}\n-\n-impl ZXPalette {\n-    /// Returns default palette\n-    #[rustfmt::skip]\n-    pub fn default() -> ZXPalette {\n-        ZXPalette {\n-            transparent: split_in_bytes(0x00000000),\n-            normal: ColorSet {\n-                black:   split_in_bytes(0x000000FF),\n-                blue:    split_in_bytes(0x0000CDFF),\n-                red:     split_in_bytes(0xCD0000FF),\n-                purple:  split_in_bytes(0xCD00CDFF),\n-                green:   split_in_bytes(0x00CD00FF),\n-                cyan:    split_in_bytes(0x00CDCDFF),\n-                yellow:  split_in_bytes(0xCDCD00FF),\n-                white:   split_in_bytes(0xCDCDCDFF),\n-            },\n-            bright: ColorSet {\n-                black:   split_in_bytes(0x000000FF),\n-                blue:    split_in_bytes(0x0000FFFF),\n-                red:     split_in_bytes(0xFF0000FF),\n-                purple:  split_in_bytes(0xFF00FFFF),\n-                green:   split_in_bytes(0x00FF00FF),\n-                cyan:    split_in_bytes(0x00FFFFFF),\n-                yellow:  split_in_bytes(0xFFFF00FF),\n-                white:   split_in_bytes(0xFFFFFFFF),\n-            }\n-        }\n-    }\n-\n-    /// Returns rgba pixel from screen data\n-    pub fn get_rgba(&self, color: ZXColor, brightness: ZXBrightness) -> &ColorArray {\n-        // select palette\n-        let set = match brightness {\n-            ZXBrightness::Normal => &self.normal,\n-            ZXBrightness::Bright => &self.bright,\n-        };\n-        match color {\n-            ZXColor::Black => &set.black,\n-            ZXColor::Blue => &set.blue,\n-            ZXColor::Red => &set.red,\n-            ZXColor::Purple => &set.purple,\n-            ZXColor::Green => &set.green,\n-            ZXColor::Cyan => &set.cyan,\n-            ZXColor::Yellow => &set.yellow,\n-            ZXColor::White => &set.white,\n-        }\n-    }\n-}\ndiff --git a/rustzx-core/src/zx/sound/ay.rs b/rustzx-core/src/zx/sound/ay.rs\nindex b2ed3ec..3dc166d 100644\n--- a/rustzx-core/src/zx/sound/ay.rs\n+++ b/rustzx-core/src/zx/sound/ay.rs\n@@ -1,9 +1,6 @@\n use crate::{\n     utils::make_word,\n-    zx::sound::{\n-        sample::{SampleGenerator, SoundSample},\n-        SAMPLE_RATE,\n-    },\n+    zx::sound::sample::{SampleGenerator, SoundSample},\n };\n use ayumi::{Ayumi, ChipType, ToneChannel};\n \n@@ -20,7 +17,7 @@ pub enum ZXAYMode {\n }\n \n /// AY Chip implementation using Ayumi lib\n-pub struct ZXAyChip {\n+pub(crate) struct ZXAyChip {\n     ay: Ayumi,\n     current_reg: usize,\n     regs: [u8; 16],\n@@ -28,10 +25,10 @@ pub struct ZXAyChip {\n \n impl ZXAyChip {\n     /// Constructs new AY Chip\n-    pub fn new(mode: ZXAYMode) -> ZXAyChip {\n+    pub fn new(sample_rate: usize, mode: ZXAYMode) -> ZXAyChip {\n         // configure ayumi\n         let mut out = ZXAyChip {\n-            ay: Ayumi::new(ChipType::AY, AY_FREQ, SAMPLE_RATE as i32),\n+            ay: Ayumi::new(ChipType::AY, AY_FREQ, sample_rate as i32),\n             current_reg: 0,\n             regs: [0; 16],\n         };\ndiff --git a/rustzx-core/src/zx/sound/beeper.rs b/rustzx-core/src/zx/sound/beeper.rs\nindex b2419ff..6b25ab4 100644\n--- a/rustzx-core/src/zx/sound/beeper.rs\n+++ b/rustzx-core/src/zx/sound/beeper.rs\n@@ -2,7 +2,7 @@ use crate::zx::sound::sample::{SampleGenerator, SoundSample};\n \n /// Simple beeper implementation\n #[derive(Default)]\n-pub struct ZXBeeper {\n+pub(crate) struct ZXBeeper {\n     curr_bit: bool,\n     next_bit: bool,\n }\ndiff --git a/rustzx-core/src/zx/sound/mixer.rs b/rustzx-core/src/zx/sound/mixer.rs\nindex 51df281..4cd384b 100644\n--- a/rustzx-core/src/zx/sound/mixer.rs\n+++ b/rustzx-core/src/zx/sound/mixer.rs\n@@ -1,26 +1,35 @@\n //! Module implemets zx spectrum audio devices mixer\n-use crate::zx::sound::{\n-    ay::{ZXAYMode, ZXAyChip},\n-    beeper::ZXBeeper,\n-    sample::{SampleGenerator, SoundSample},\n-    samples_from_time, SAMPLES,\n+use crate::zx::{\n+    constants::FPS,\n+    sound::{\n+        beeper::ZXBeeper,\n+        sample::{SampleGenerator, SoundSample},\n+    },\n };\n+\n+#[cfg(feature = "ay")]\n+use crate::zx::sound::ay::{ZXAYMode, ZXAyChip};\n+\n use alloc::collections::VecDeque;\n \n /// Main sound mixer.\n-pub struct ZXMixer {\n+pub(crate) struct ZXMixer {\n     /// direct access to beeper device\n     pub beeper: ZXBeeper,\n     /// direct access to AY device\n+    #[cfg(feature = "ay")]\n     pub ay: ZXAyChip,\n     ring_buffer: VecDeque<SoundSample<f32>>,\n     last_pos: usize,\n     last_sample: SoundSample<f32>,\n     master_volume: f64,\n     beeper_volume: f64,\n+    #[cfg(feature = "ay")]\n     ay_volume: f64,\n+    #[cfg(feature = "ay")]\n     use_ay: bool,\n     use_beeper: bool,\n+    sample_rate: usize,\n }\n \n impl ZXMixer {\n@@ -28,18 +37,26 @@ impl ZXMixer {\n     /// # Arguments\n     /// - `use_beeper` - process beeper or not\n     /// - `use_ay` - process ay chip or not\n-    pub fn new(use_beeper: bool, use_ay: bool) -> ZXMixer {\n+    pub fn new(\n+        use_beeper: bool,\n+        #[cfg(feature = "ay")] use_ay: bool,\n+        sample_rate: usize,\n+    ) -> ZXMixer {\n         ZXMixer {\n             beeper: ZXBeeper::default(),\n-            ay: ZXAyChip::new(ZXAYMode::Mono),\n-            ring_buffer: VecDeque::with_capacity(SAMPLES),\n+            #[cfg(feature = "ay")]\n+            ay: ZXAyChip::new(sample_rate, ZXAYMode::Mono),\n+            ring_buffer: VecDeque::with_capacity(sample_rate),\n             last_pos: 0,\n             last_sample: SoundSample::new(0.0, 0.0),\n             master_volume: 0.5,\n             beeper_volume: 1.0,\n+            #[cfg(feature = "ay")]\n             ay_volume: 1.0,\n+            #[cfg(feature = "ay")]\n             use_ay,\n             use_beeper,\n+            sample_rate,\n         }\n     }\n \n@@ -53,11 +70,11 @@ impl ZXMixer {\n     /// Updates internal buffer of mixer and fills it with new samples\n     pub fn process(&mut self, current_time: f64) {\n         // buffer overflow\n-        if self.ring_buffer.len() >= SAMPLES {\n+        if self.ring_buffer.len() >= self.samples_per_frame() {\n             return;\n         }\n         // so at this moment we need to get new samples from devices\n-        let curr_pos = samples_from_time(current_time);\n+        let curr_pos = self.sample_count_for_frame_fraction(current_time);\n         // if we on same pos or frame passed then no new samples\n         if curr_pos <= self.last_pos {\n             return;\n@@ -73,8 +90,8 @@ impl ZXMixer {\n \n     /// fills buffer to eng on new frame\n     pub fn new_frame(&mut self) {\n-        if self.ring_buffer.len() < SAMPLES {\n-            for _ in self.ring_buffer.len()..SAMPLES {\n+        if self.ring_buffer.len() < self.samples_per_frame() {\n+            for _ in self.ring_buffer.len()..self.samples_per_frame() {\n                 self.ring_buffer.push_back(self.last_sample);\n             }\n         }\n@@ -92,6 +109,7 @@ impl ZXMixer {\n             SoundSample::new(0.0, 0.0)\n         };\n         // prevent AY sound generation if disabled [it is pretty long process]\n+        #[cfg(feature = "ay")]\n         if self.use_ay {\n             master_float.mix(&self.ay.gen_sample());\n         }\n@@ -99,4 +117,15 @@ impl ZXMixer {\n         self.last_sample = master;\n         master\n     }\n+\n+    fn samples_per_frame(&self) -> usize {\n+        self.sample_rate / FPS\n+    }\n+\n+    fn sample_count_for_frame_fraction(&self, fraction: f64) -> usize {\n+        if fraction >= 1f64 {\n+            return self.samples_per_frame();\n+        }\n+        (self.samples_per_frame() as f64 * fraction) as usize\n+    }\n }\ndiff --git a/rustzx-core/src/zx/sound/mod.rs b/rustzx-core/src/zx/sound/mod.rs\nindex dbd6782..acd95bc 100644\n--- a/rustzx-core/src/zx/sound/mod.rs\n+++ b/rustzx-core/src/zx/sound/mod.rs\n@@ -1,23 +1,7 @@\n //! Module implements emulation of sound chip AY, Spectrum Beeper and Mixer\n+#[cfg(feature = "ay")]\n pub mod ay;\n-pub mod beeper;\n-pub mod mixer;\n pub mod sample;\n \n-use crate::zx::constants::FPS;\n-\n-pub const SAMPLE_RATE: usize = 44100;\n-/// samples per frame\n-pub const SAMPLES: usize = SAMPLE_RATE / FPS;\n-pub const CHANNELS: usize = 2;\n-\n-/// Returns, which must be already processed at this time\n-pub fn samples_from_time(time: f64) -> usize {\n-    if time >= 1.0 {\n-        SAMPLES\n-    } else if time <= 0.0 {\n-        0\n-    } else {\n-        (SAMPLES as f64 * time) as usize\n-    }\n-}\n+pub(crate) mod beeper;\n+pub(crate) mod mixer;\ndiff --git a/rustzx-core/src/zx/sound/sample.rs b/rustzx-core/src/zx/sound/sample.rs\nindex c83e339..8a3d141 100644\n--- a/rustzx-core/src/zx/sound/sample.rs\n+++ b/rustzx-core/src/zx/sound/sample.rs\n@@ -2,6 +2,7 @@ use core::{\n     i16,\n     ops::{Add, Mul, MulAssign, Sub},\n };\n+\n /// Raw Sample can be only f64 or i16\n pub trait RawSample: Clone + Copy + MulAssign + Mul + Add + Sub {}\n impl RawSample for f64 {}\n@@ -58,30 +59,6 @@ impl SoundSample<f64> {\n         self\n     }\n \n-    /// Transforms normalized float sample to i16 sample\n-    pub fn into_i16(self) -> SoundSample<i16> {\n-        // here is some thick hack :D\n-        // we have value in 0.0..1.0. We need value in min_i16...max_i16 (signed)\n-        // so we unly need one float multiplication, one floor and one XOR with highest bit\n-        // multiplication + floor => 0...max_u16\n-        // XOR =>  4 bit example {\n-        //      0b0000 [0] => 0b1000 [-8]\n-        //      0b0001 [1] => 0b1000 [-7]\n-        //      ...\n-        //      0b0111 [7] => 0b1111 [-1]\n-        //      0b1000 [8] => 0b0000 [0]\n-        //      0b1000 [9] => 0b0001 [1]\n-        //      ...\n-        //      0b1111 [15] => 0b0111 [7]\n-        // }\n-        // So we can easily get range expansion only with XOR operation in MSb\n-        // NOTE: `i16 as u16` and `u16 as i16` have no cost\n-        SoundSample {\n-            left: ((self.left * (u16::max_value() - ERROR_SIZE) as f64) as u16 ^ 0x8000) as i16,\n-            right: ((self.right * (u16::max_value() - ERROR_SIZE) as f64) as u16 ^ 0x8000) as i16,\n-        }\n-    }\n-\n     /// transform into f32\n     pub fn into_f32(self) -> SoundSample<f32> {\n         SoundSample {\n@@ -105,7 +82,7 @@ impl SoundSample<f64> {\n }\n \n /// Trait which signals that structure can generate SoundSamples\n-pub trait SampleGenerator<T>\n+pub(crate) trait SampleGenerator<T>\n where\n     T: RawSample,\n {\ndiff --git a/rustzx-core/src/zx/tape/empty.rs b/rustzx-core/src/zx/tape/empty.rs\nnew file mode 100644\nindex 0000000..205d94e\n--- /dev/null\n+++ b/rustzx-core/src/zx/tape/empty.rs\n@@ -0,0 +1,33 @@\n+use crate::{utils::Clocks, zx::tape::TapeImpl, Result};\n+\n+pub struct Empty;\n+\n+impl TapeImpl for Empty {\n+    fn can_fast_load(&self) -> bool {\n+        false\n+    }\n+\n+    fn next_block_byte(&mut self) -> Result<Option<u8>> {\n+        Ok(None)\n+    }\n+\n+    fn next_block(&mut self) -> Result<bool> {\n+        Ok(false)\n+    }\n+\n+    fn current_bit(&self) -> bool {\n+        false\n+    }\n+\n+    fn process_clocks(&mut self, _clocks: Clocks) -> Result<()> {\n+        Ok(())\n+    }\n+\n+    fn stop(&mut self) {}\n+\n+    fn play(&mut self) {}\n+\n+    fn rewind(&mut self) -> Result<()> {\n+        Ok(())\n+    }\n+}\ndiff --git a/rustzx-core/src/zx/tape/mod.rs b/rustzx-core/src/zx/tape/mod.rs\nindex 847022b..1188910 100644\n--- a/rustzx-core/src/zx/tape/mod.rs\n+++ b/rustzx-core/src/zx/tape/mod.rs\n@@ -1,42 +1,37 @@\n-//! Contains Tape handling type and functions\n-\n+mod empty;\n mod tap;\n-// reexport Tap Tape player\n-pub use self::tap::Tap;\n \n-use crate::utils::Clocks;\n+pub use self::{empty::Empty, tap::Tap};\n+\n+use crate::{host::LoadableAsset, utils::Clocks, Result};\n \n use enum_dispatch::enum_dispatch;\n \n #[enum_dispatch(TapeImpl)]\n-pub enum ZXTape {\n-    Tap(Tap),\n+pub enum ZXTape<A: LoadableAsset> {\n+    Tap(Tap<A>),\n+    Empty(Empty),\n+}\n+\n+impl<A: LoadableAsset> Default for ZXTape<A> {\n+    fn default() -> Self {\n+        Self::Empty(Empty)\n+    }\n }\n \n #[enum_dispatch]\n pub trait TapeImpl {\n-    // -----------------\n-    // FAST LOAD SECTION\n-    // -----------------\n-    /// is this type of tape is allowed to fast load blocks?\n     fn can_fast_load(&self) -> bool;\n-    /// Returns byte of current block or `None` if offset exceeds block Size\n-    fn block_byte(&self, offset: usize) -> Option<u8>;\n-    /// Moves tape pointer to next block\n-    fn next_block(&mut self);\n-    /// Resets relative position in block to zero\n-    fn reset_pos_in_block(&mut self);\n-    // -----------------\n-    //  GENERAL SECTION\n-    // -----------------\n-    /// Returns current ear bit\n+    /// Returns byte of current block or `None` if block has ended\n+    fn next_block_byte(&mut self) -> Result<Option<u8>>;\n+    /// Loads next block. Retruns false if end of the tape is reached\n+    fn next_block(&mut self) -> Result<bool>;\n+    /// Returns current tape (`ear`) bit\n     fn current_bit(&self) -> bool;\n-    /// Makes procession of type in definite time\n-    fn process_clocks(&mut self, clocks: Clocks);\n-    /// stops tape\n+    /// Perform tape processing emulation within `clocks` time limit\n+    fn process_clocks(&mut self, clocks: Clocks) -> Result<()>;\n     fn stop(&mut self);\n-    /// plays tape\n     fn play(&mut self);\n-    /// rewinds tape\n-    fn rewind(&mut self);\n+    /// Rewinds tape content to the beginning\n+    fn rewind(&mut self) -> Result<()>;\n }\ndiff --git a/rustzx-core/src/zx/tape/tap.rs b/rustzx-core/src/zx/tape/tap.rs\nindex feaa5e7..ca66c9e 100644\n--- a/rustzx-core/src/zx/tape/tap.rs\n+++ b/rustzx-core/src/zx/tape/tap.rs\n@@ -1,9 +1,11 @@\n-//! TAP file tape player\n+use crate::{\n+    error::TapeLoadError,\n+    host::{LoadableAsset, SeekFrom},\n+    utils::{make_word, Clocks},\n+    zx::tape::TapeImpl,\n+    Result,\n+};\n \n-use crate::{host::LoadableAsset, utils::Clocks, zx::tape::TapeImpl, Result};\n-use alloc::vec::Vec;\n-\n-// main constants\n const PILOT_LENGTH: usize = 2168;\n const PILOT_PULSES_HEADER: usize = 8063;\n const PILOT_PULSES_DATA: usize = 3223;\n@@ -12,335 +14,263 @@ const SYNC2_LENGTH: usize = 735;\n const BIT_ONE_LENGTH: usize = 1710;\n const BIT_ZERO_LENGTH: usize = 855;\n const PAUSE_LENGTH: usize = 3_500_000;\n+const BUFFER_SIZE: usize = 128;\n \n-/// state of tape player\n #[derive(PartialEq, Eq, Clone, Copy)]\n enum TapeState {\n     Stop,\n     Play,\n-    Pilot,\n+    Pilot { pulses_left: usize },\n     Sync,\n     NextByte,\n-    NextBit,\n-    BitHalf(usize),\n+    NextBit { mask: u8 },\n+    BitHalf { half_bit_delay: usize, mask: u8 },\n     Pause,\n }\n \n-/// information about block of tape\n-#[derive(Clone, Copy)]\n-struct BlockInfo {\n-    length: usize,\n-    pos: usize,\n-    end: usize,\n-}\n-\n-// TODO(#53): Eliminate loading a whole file to vector in tap loader\n-\n-pub struct Tap {\n-    /// state of tape\n+pub struct Tap<A: LoadableAsset> {\n+    asset: A,\n     state: TapeState,\n-    /// previous state\n     prev_state: TapeState,\n-    /// data of tape\n-    data: Vec<u8>,\n-    /// fields for pulse making from byte\n+    buffer: [u8; BUFFER_SIZE],\n+    bufer_offset: usize,\n+    block_bytes_read: usize,\n+    current_block_size: Option<usize>,\n+    tape_ended: bool,\n+    // Non-fastload related fields\n     curr_bit: bool,\n     curr_byte: u8,\n-    curr_mask: u8,\n-    // pulses left to next state\n-    pulse_counter: usize,\n-    /// block info\n-    block_info: Vec<BlockInfo>,\n-    block: usize,\n-    pos_in_block: usize,\n-    /// between-state timings\n     delay: Clocks,\n-    acc_clocks: Clocks,\n }\n \n-impl Default for Tap {\n-    fn default() -> Self {\n-        Self {\n+impl<A: LoadableAsset> Tap<A> {\n+    pub fn from_asset(asset: A) -> Result<Self> {\n+        let tap = Self {\n             prev_state: TapeState::Stop,\n             state: TapeState::Stop,\n-            data: Vec::new(),\n             curr_bit: false,\n             curr_byte: 0x00,\n-            curr_mask: 0x80,\n-            pulse_counter: 0,\n-            block_info: Vec::new(),\n-            block: 0,\n-            pos_in_block: 0,\n+            buffer: [0u8; BUFFER_SIZE],\n+            bufer_offset: 0,\n+            block_bytes_read: 0,\n+            current_block_size: None,\n             delay: Clocks(0),\n-            acc_clocks: Clocks(0),\n-        }\n+            asset,\n+            tape_ended: false,\n+        };\n+        Ok(tap)\n     }\n }\n \n-impl Tap {\n-    /// updates internal structure according new tape file\n-    pub fn from_asset(mut asset: impl LoadableAsset) -> Result<Self> {\n-        use crate::utils::make_word;\n-\n-        let mut tap = Self::default();\n+impl<A: LoadableAsset> TapeImpl for Tap<A> {\n+    fn can_fast_load(&self) -> bool {\n+        self.state == TapeState::Stop\n+    }\n \n-        let mut buffer = [0u8; 1024];\n-        let mut read_bytes = asset.read(&mut buffer)?;\n-        while read_bytes != 0 {\n-            tap.data.extend_from_slice(&buffer[0..read_bytes]);\n-            read_bytes = asset.read(&mut buffer)?;\n+    fn next_block_byte(&mut self) -> Result<Option<u8>> {\n+        if self.tape_ended {\n+            return Ok(None);\n         }\n \n-        tap.block_info.clear();\n-        // get all blocks data\n-        let mut p = 0;\n-        \'blocks: loop {\n-            // get length of the block\n-            let len = make_word(tap.data[p + 1], tap.data[p]) as usize;\n-            // push to vector of blocks\n-            tap.block_info.push(BlockInfo {\n-                length: len,\n-                pos: p + 2,\n-                end: p + 2 + len - 1,\n-            });\n-            // shift pos\n-            p += 2 + len;\n-            // check bounds\n-            if p >= tap.data.len() {\n-                break \'blocks;\n+        if let Some(block_size) = self.current_block_size {\n+            if self.block_bytes_read >= block_size {\n+                return Ok(None);\n             }\n-        }\n-        tap.reset_state();\n \n-        Ok(tap)\n-    }\n+            let mut buffer_read_pos = self.block_bytes_read - self.bufer_offset;\n \n-    /// resets internal tape state\n-    fn reset_state(&mut self) {\n-        self.state = TapeState::Stop;\n-        self.curr_bit = false;\n-        self.curr_byte = 0x00;\n-        self.curr_mask = 0x80;\n-        self.block = 0;\n-        self.pos_in_block = 0;\n-        self.delay = Clocks(0);\n-        self.acc_clocks = Clocks(0);\n-    }\n-}\n+            // Read new buffer if required\n+            if buffer_read_pos >= BUFFER_SIZE {\n+                let bytes_to_read = (block_size - self.bufer_offset - BUFFER_SIZE).min(BUFFER_SIZE);\n+                self.asset.read_exact(&mut self.buffer[0..bytes_to_read])?;\n+                self.bufer_offset += BUFFER_SIZE;\n+                buffer_read_pos = 0;\n+            }\n \n-impl TapeImpl for Tap {\n-    /// can autoload only if tape stopped\n-    fn can_fast_load(&self) -> bool {\n-        self.state == TapeState::Stop\n-    }\n+            // Check last byte in block\n+            if self.block_bytes_read >= block_size {\n+                self.current_block_size = None;\n+                self.block_bytes_read = 0;\n+                return Ok(None);\n+            }\n \n-    /// returns byte of block\n-    fn block_byte(&self, offset: usize) -> Option<u8> {\n-        if self.block_info.is_empty() {\n-            return None;\n-        };\n-        let block = self.block_info[self.block];\n-        if offset < block.length {\n-            Some(self.data[block.pos + offset])\n-        } else {\n-            None\n+            // Perform actual read and advance position\n+            let result = self.buffer[buffer_read_pos];\n+            self.block_bytes_read += 1;\n+            return Ok(Some(result));\n         }\n+\n+        Ok(None)\n     }\n \n-    /// switches tape player to next block\n-    fn next_block(&mut self) {\n-        self.block += 1;\n-        // make loop\n-        if self.block >= self.block_info.len() {\n-            self.block = 0;\n+    fn next_block(&mut self) -> Result<bool> {\n+        if self.tape_ended {\n+            return Ok(false);\n         }\n-        self.state = TapeState::Stop;\n-    }\n \n-    /// resets position in block to 0\n-    fn reset_pos_in_block(&mut self) {\n-        self.pos_in_block = 0;\n+        // Skip leftovers from the previous block\n+        while self.next_block_byte()?.is_some() {}\n+\n+        let mut block_size_buffer = [0u8; 2];\n+        if self.asset.read_exact(&mut block_size_buffer).is_err() {\n+            self.tape_ended = true;\n+            return Ok(false);\n+        }\n+        let block_size = make_word(block_size_buffer[1], block_size_buffer[0]) as usize;\n+        let block_bytes_to_read = block_size.min(BUFFER_SIZE);\n+        self.asset\n+            .read_exact(&mut self.buffer[0..block_bytes_to_read])?;\n+\n+        self.bufer_offset = 0;\n+        self.block_bytes_read = 0;\n+        self.current_block_size = Some(block_size);\n+\n+        Ok(true)\n     }\n \n-    /// returns current bit\n     fn current_bit(&self) -> bool {\n         self.curr_bit\n     }\n \n-    /// makes internal state change based on clocks count\n-    fn process_clocks(&mut self, clocks: Clocks) {\n-        // if there are no blocks\n-        if self.block_info.is_empty() {\n-            return;\n-        }\n-        // get block info, check bunds\n-        let block = if self.block >= self.block_info.len() {\n-            self.block_info[0]\n-        } else {\n-            self.block_info[self.block]\n-        };\n-        // clocks\n-        let clocks = clocks.count();\n+    fn process_clocks(&mut self, clocks: Clocks) -> Result<()> {\n         if self.state == TapeState::Stop {\n-            return;\n+            return Ok(());\n         }\n-        // check delay\n+\n         if self.delay.count() > 0 {\n-            // accumulate clocks for delay\n-            self.acc_clocks += clocks;\n-            // if enough accumulated clocks then clear delay and drop some accumulated clocks\n-            if self.acc_clocks.count() >= self.delay.count() {\n-                self.acc_clocks -= self.delay;\n+            if clocks > self.delay {\n                 self.delay = Clocks(0);\n+            } else {\n+                self.delay -= clocks;\n             }\n-            // return anyway, it is delay!\n-            return;\n-        } else {\n-            // clear accumulated clocks\n-            self.acc_clocks = Clocks(0);\n+            return Ok(());\n         }\n-        // state machine. Wrapped into the loop for sequental non-clock-consuming state execution\n+\n         \'state_machine: loop {\n             match self.state {\n-                // Stop state.\n                 TapeState::Stop => {\n-                    // Tape stopped, return HI bit, set current block pos to zero\n-                    self.curr_bit = false;\n-                    self.pos_in_block = 0;\n-                    // action maked, break state machine\n+                    // Reset tape but leave in Stopped state\n+                    self.rewind()?;\n+                    self.state = TapeState::Stop;\n                     break \'state_machine;\n                 }\n-                // Play state. Starts the tape\n                 TapeState::Play => {\n-                    // out of range play\n-                    if self.block >= self.block_info.len() {\n-                        // if play state happened when position is out of range,\n-                        // loop will be breaked on next iteration and next block will be with\n-                        // number zero\n-                        self.block = 0;\n+                    if !self.next_block()? {\n                         self.state = TapeState::Stop;\n                     } else {\n-                        // select appropriate pulse count for Pilot sequence\n-                        self.pulse_counter = if self.data[block.pos] < 128 {\n+                        let first_byte = self\n+                            .next_block_byte()?\n+                            .ok_or(TapeLoadError::InvalidTapFile)?;\n+\n+                        // Select appropriate pulse count for Pilot sequence\n+                        let pulses_left = if first_byte == 0x00 {\n                             PILOT_PULSES_HEADER\n                         } else {\n                             PILOT_PULSES_DATA\n                         };\n-                        // so, ok seems to be ok, we can make output bit low\n+                        self.curr_byte = first_byte;\n                         self.curr_bit = true;\n-                        // set delay before next state to one pilot pulse\n                         self.delay = Clocks(PILOT_LENGTH);\n-                        self.state = TapeState::Pilot;\n-                        // break state machine, delay must be emulated\n+                        self.state = TapeState::Pilot { pulses_left };\n                         break \'state_machine;\n                     }\n                 }\n-                // Pilot pulses\n-                TapeState::Pilot => {\n-                    // invert bit;\n+                TapeState::Pilot { mut pulses_left } => {\n                     self.curr_bit = !self.curr_bit;\n-                    // one pulse passed\n-                    self.pulse_counter -= 1;\n-                    if self.pulse_counter > 0 {\n-                        // add new delay and break\n-                        self.delay = Clocks(PILOT_LENGTH);\n-                    } else {\n-                        // change state to first sync\n-                        self.state = TapeState::Sync;\n+                    pulses_left -= 1;\n+                    if pulses_left == 0 {\n                         self.delay = Clocks(SYNC1_LENGTH);\n+                        self.state = TapeState::Sync;\n+                    } else {\n+                        self.delay = Clocks(PILOT_LENGTH);\n+                        self.state = TapeState::Pilot { pulses_left };\n                     }\n-                    // break anyway for delay\n                     break \'state_machine;\n                 }\n-                // sync pulse\n                 TapeState::Sync => {\n                     self.curr_bit = !self.curr_bit;\n                     self.delay = Clocks(SYNC2_LENGTH);\n-                    self.state = TapeState::NextByte;\n+                    self.state = TapeState::NextBit { mask: 0x80 };\n                     break \'state_machine;\n                 }\n-                // read next byte\n                 TapeState::NextByte => {\n-                    // read from most singificant bit\n-                    self.curr_mask = 0x80;\n-                    self.curr_byte = 0x00;\n-                    // break not needed, state doesn\'t require any time\n-                    self.state = TapeState::NextBit;\n+                    self.state = if let Some(byte) = self.next_block_byte()? {\n+                        self.curr_byte = byte;\n+                        TapeState::NextBit { mask: 0x80 }\n+                    } else {\n+                        TapeState::Pause\n+                    }\n                 }\n-                // next bit\n-                TapeState::NextBit => {\n-                    // invert bit\n+                TapeState::NextBit { mask } => {\n                     self.curr_bit = !self.curr_bit;\n-                    // depending on bit state select timing and switch to new state\n-                    if (self.data[block.pos + self.pos_in_block] & self.curr_mask) == 0 {\n+                    if (self.curr_byte & mask) == 0 {\n                         self.delay = Clocks(BIT_ZERO_LENGTH);\n-                        self.state = TapeState::BitHalf(BIT_ZERO_LENGTH);\n+                        self.state = TapeState::BitHalf {\n+                            half_bit_delay: BIT_ZERO_LENGTH,\n+                            mask,\n+                        };\n                     } else {\n                         self.delay = Clocks(BIT_ONE_LENGTH);\n-                        self.state = TapeState::BitHalf(BIT_ONE_LENGTH);\n-                        self.curr_byte |= self.curr_mask;\n+                        self.state = TapeState::BitHalf {\n+                            half_bit_delay: BIT_ONE_LENGTH,\n+                            mask,\n+                        };\n                     };\n                     break \'state_machine;\n                 }\n-                // half of a bit\n-                TapeState::BitHalf(pulse_length) => {\n-                    // invert bit\n+                TapeState::BitHalf {\n+                    half_bit_delay,\n+                    mut mask,\n+                } => {\n                     self.curr_bit = !self.curr_bit;\n-                    // set timeout same as before\n-                    self.delay = Clocks(pulse_length);\n-                    // shift right, to the next bit\n-                    self.curr_mask >>= 1;\n-                    if self.curr_mask == 0 {\n-                        self.pos_in_block += 1;\n-                        // check if we heve next byte in block\n-                        self.state = if self.pos_in_block < block.length {\n-                            TapeState::NextByte\n-                        } else {\n-                            TapeState::Pause\n-                        };\n+                    self.delay = Clocks(half_bit_delay);\n+                    mask >>= 1;\n+                    self.state = if mask == 0 {\n+                        TapeState::NextByte\n                     } else {\n-                        // fetch next bit\n-                        self.state = TapeState::NextBit;\n-                    }\n+                        TapeState::NextBit { mask }\n+                    };\n                     break \'state_machine;\n                 }\n-                // pause after block\n                 TapeState::Pause => {\n                     self.curr_bit = !self.curr_bit;\n-                    // make delay and go to another block. `Play` state can datermine\n-                    // the end of tape\n                     self.delay = Clocks(PAUSE_LENGTH);\n-                    self.block += 1;\n-                    self.pos_in_block = 0;\n+                    // Next block or end of the tape\n                     self.state = TapeState::Play;\n-                    // break directly for delay\n                     break \'state_machine;\n                 }\n             }\n         }\n+\n+        Ok(())\n     }\n \n-    /// stops tape playback, sets `Stop` state\n     fn stop(&mut self) {\n         let state = self.state;\n         self.prev_state = state;\n         self.state = TapeState::Stop;\n     }\n \n-    /// starts playback\n     fn play(&mut self) {\n         if self.state == TapeState::Stop {\n             if self.prev_state == TapeState::Stop {\n                 self.state = TapeState::Play;\n             } else {\n-                let prev_state = self.prev_state;\n-                self.state = prev_state;\n+                self.state = self.prev_state;\n             }\n         }\n     }\n \n-    /// rewinds tape to start\n-    fn rewind(&mut self) {\n-        self.reset_state();\n+    fn rewind(&mut self) -> Result<()> {\n+        self.state = TapeState::Stop;\n+        self.curr_bit = false;\n+        self.curr_byte = 0x00;\n+        self.block_bytes_read = 0;\n+        self.bufer_offset = 0;\n+        self.current_block_size = None;\n+        self.delay = Clocks(0);\n+        self.asset.seek(SeekFrom::Start(0))?;\n+        self.tape_ended = false;\n+        Ok(())\n     }\n }\ndiff --git a/rustzx-core/src/zx/screen/border.rs b/rustzx-core/src/zx/video/border.rs\nsimilarity index 82%\nrename from rustzx-core/src/zx/screen/border.rs\nrename to rustzx-core/src/zx/video/border.rs\nindex 28828a1..94bc9d0 100644\n--- a/rustzx-core/src/zx/screen/border.rs\n+++ b/rustzx-core/src/zx/video/border.rs\n@@ -1,10 +1,15 @@\n //! Contains ZXSpectrum border implementation\n-use super::colors::*;\n+use super::colors::{ZXBrightness, ZXColor};\n use crate::{\n+    host::{FrameBuffer, FrameBufferSource},\n     utils::Clocks,\n-    zx::{constants::*, machine::*},\n+    zx::{\n+        constants::{\n+            BORDER_COLS, BORDER_ROWS, CLOCKS_PER_COL, PIXELS_PER_CLOCK, SCREEN_HEIGHT, SCREEN_WIDTH,\n+        },\n+        machine::ZXMachine,\n+    },\n };\n-use alloc::boxed::Box;\n \n /// Internal struct, which contains information about beam position and color\n #[derive(Clone, Copy)]\n@@ -37,21 +42,24 @@ impl BeamInfo {\n }\n \n /// ZX Spectrum Border Device\n-pub struct ZXBorder {\n+pub struct ZXBorder<FB: FrameBuffer> {\n     machine: ZXMachine,\n-    palette: ZXPalette,\n-    buffer: Box<[u8; PIXEL_COUNT * BYTES_PER_PIXEL]>,\n+    buffer: FB,\n     beam_last: BeamInfo,\n     border_changed: bool,\n     beam_block: bool,\n }\n-impl ZXBorder {\n+impl<FB: FrameBuffer> ZXBorder<FB> {\n     /// Returns new instance of border device\n-    pub fn new(machine: ZXMachine, palette: ZXPalette) -> ZXBorder {\n+    pub fn new(machine: ZXMachine, context: FB::Context) -> Self {\n         ZXBorder {\n             machine,\n-            palette,\n-            buffer: Box::new([0; PIXEL_COUNT * BYTES_PER_PIXEL]),\n+            buffer: FB::new(\n+                SCREEN_WIDTH,\n+                SCREEN_HEIGHT,\n+                FrameBufferSource::Border,\n+                context,\n+            ),\n             beam_last: BeamInfo::first_pixel(ZXColor::White),\n             border_changed: true,\n             beam_block: false,\n@@ -96,17 +104,13 @@ impl ZXBorder {\n     /// fills pixels from last pos to passed by arguments with\n     fn fill_to(&mut self, line: usize, pixel: usize) {\n         let last = self.beam_last;\n-        let color_array = self.palette.get_rgba(last.color, ZXBrightness::Normal);\n-        // fill pixels\n         for p in (last.line * SCREEN_WIDTH + last.pixel)..(line * SCREEN_WIDTH + pixel) {\n-            for (b, color_value) in color_array\n-                .iter()\n-                .copied()\n-                .enumerate()\n-                .take(BYTES_PER_PIXEL)\n-            {\n-                self.buffer[p * BYTES_PER_PIXEL + b] = color_value;\n-            }\n+            self.buffer.set_color(\n+                p % SCREEN_WIDTH,\n+                p / SCREEN_WIDTH,\n+                last.color,\n+                ZXBrightness::Normal,\n+            );\n         }\n     }\n \n@@ -143,7 +147,7 @@ impl ZXBorder {\n     }\n \n     /// Returns reference to texture\n-    pub fn texture(&self) -> &[u8] {\n-        &(*self.buffer)\n+    pub fn frame_buffer(&self) -> &FB {\n+        &self.buffer\n     }\n }\ndiff --git a/rustzx-core/src/zx/video/colors.rs b/rustzx-core/src/zx/video/colors.rs\nnew file mode 100644\nindex 0000000..2248852\n--- /dev/null\n+++ b/rustzx-core/src/zx/video/colors.rs\n@@ -0,0 +1,76 @@\n+/// Represents color brightness\n+#[derive(Clone, Copy)]\n+pub enum ZXBrightness {\n+    Normal,\n+    Bright,\n+}\n+\n+/// ZX Spectrum color enum\n+/// Constructs self from 3-bit value\n+#[derive(Clone, Copy)]\n+pub enum ZXColor {\n+    Black,\n+    Blue,\n+    Red,\n+    Purple,\n+    Green,\n+    Cyan,\n+    Yellow,\n+    White,\n+}\n+\n+impl ZXColor {\n+    /// Returns ZXColor from 3 bits\n+    /// # Panics\n+    /// Panics when input color is bigger than 7\n+    pub fn from_bits(bits: u8) -> ZXColor {\n+        assert!(bits <= 7);\n+        match bits {\n+            0 => ZXColor::Black,\n+            1 => ZXColor::Blue,\n+            2 => ZXColor::Red,\n+            3 => ZXColor::Purple,\n+            4 => ZXColor::Green,\n+            5 => ZXColor::Cyan,\n+            6 => ZXColor::Yellow,\n+            7 => ZXColor::White,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+/// ZX Spectrum attribute structure\n+/// It contains information about ink, paper color,\n+/// flash attribute and brightness\n+#[derive(Clone, Copy)]\n+pub(crate) struct ZXAttribute {\n+    pub ink: ZXColor,\n+    pub paper: ZXColor,\n+    pub brightness: ZXBrightness,\n+    pub flash: bool,\n+}\n+\n+impl ZXAttribute {\n+    /// Constructs self from byte\n+    pub fn from_byte(data: u8) -> ZXAttribute {\n+        ZXAttribute {\n+            ink: ZXColor::from_bits(data & 0x07),\n+            paper: ZXColor::from_bits((data >> 3) & 0x07),\n+            flash: (data & 0x80) != 0,\n+            brightness: if (data & 0x40) != 0 {\n+                ZXBrightness::Bright\n+            } else {\n+                ZXBrightness::Normal\n+            },\n+        }\n+    }\n+\n+    /// Returns active color of pixel in current attribute\n+    pub fn active_color(&self, state: bool, enable_flash: bool) -> ZXColor {\n+        if state ^ (self.flash && enable_flash) {\n+            self.ink\n+        } else {\n+            self.paper\n+        }\n+    }\n+}\ndiff --git a/rustzx-core/src/zx/screen/mod.rs b/rustzx-core/src/zx/video/mod.rs\nsimilarity index 55%\nrename from rustzx-core/src/zx/screen/mod.rs\nrename to rustzx-core/src/zx/video/mod.rs\nindex 9ed21ec..36a3026 100644\n--- a/rustzx-core/src/zx/screen/mod.rs\n+++ b/rustzx-core/src/zx/video/mod.rs\n@@ -1,5 +1,7 @@\n //! Module contains all screen-rendering platform-independent\n //! types and functions\n-pub mod border;\n-pub mod canvas;\n+#[cfg(feature = "precise-border")]\n+pub(crate) mod border;\n+pub(crate) mod screen;\n+\n pub mod colors;\ndiff --git a/rustzx-core/src/zx/screen/canvas.rs b/rustzx-core/src/zx/video/screen.rs\nsimilarity index 80%\nrename from rustzx-core/src/zx/screen/canvas.rs\nrename to rustzx-core/src/zx/video/screen.rs\nindex 75e976f..30081e0 100644\n--- a/rustzx-core/src/zx/screen/canvas.rs\n+++ b/rustzx-core/src/zx/video/screen.rs\n@@ -1,15 +1,23 @@\n //! Module describes ZX Spectrum screen\n //! *block* - is 8x1 pxels stripe.\n use crate::{\n-    utils::{screen::*, *},\n-    zx::{constants::*, machine::ZXMachine, screen::colors::*},\n+    host::{FrameBuffer, FrameBufferSource},\n+    utils::{\n+        screen::{attr_col_rel, attr_row_rel, bitmap_col_rel, bitmap_line_rel},\n+        Clocks,\n+    },\n+    zx::{\n+        constants::{\n+            ATTR_BASE_REL, ATTR_COLS, ATTR_MAX_REL, ATTR_ROWS, BITMAP_MAX_REL, CANVAS_HEIGHT,\n+            CANVAS_WIDTH, CLOCKS_PER_COL,\n+        },\n+        machine::ZXMachine,\n+        video::colors::ZXAttribute,\n+    },\n };\n use alloc::boxed::Box;\n \n-// size of screen buffer in bytes\n-const BUFFER_LENGTH: usize = CANVAS_HEIGHT * CANVAS_WIDTH * BYTES_PER_PIXEL;\n-\n-/// Represents how much 8x1 have been **passed**.\n+/// Represents how much 8x1 have been already **rendered**.\n #[derive(PartialEq, Eq, Debug)]\n pub struct BlocksCount {\n     pub lines: usize,\n@@ -76,32 +84,38 @@ struct ScreenBank {\n }\n \n /// Represents ZXSpectrum emulated mid part of screen (canvas)\n-pub struct ZXCanvas {\n+pub struct ZXScreen<FB: FrameBuffer> {\n     machine: ZXMachine,\n-    palette: ZXPalette,\n     last_blocks: BlocksCount,\n     flash: bool,\n     frame_counter: usize,\n-    // bitmap buffers\n-    buffer: Box<[u8; BUFFER_LENGTH]>,\n-    back_buffer: Box<[u8; BUFFER_LENGTH]>,\n-    // memory\n+    buffer: FB,\n+    back_buffer: FB,\n     banks: [ScreenBank; 2],\n     active_bank: usize,\n     next_bank: usize,\n }\n \n-impl ZXCanvas {\n+impl<FB: FrameBuffer> ZXScreen<FB> {\n     /// Constructs new canvas of `machine`\n-    pub fn new(machine: ZXMachine) -> ZXCanvas {\n-        ZXCanvas {\n+    pub fn new(machine: ZXMachine, context: FB::Context) -> Self {\n+        Self {\n             machine,\n-            palette: ZXPalette::default(),\n             last_blocks: BlocksCount::new(0, 0),\n             flash: false,\n             frame_counter: 0,\n-            buffer: Box::new([0; BUFFER_LENGTH]),\n-            back_buffer: Box::new([0; BUFFER_LENGTH]),\n+            buffer: FB::new(\n+                CANVAS_WIDTH,\n+                CANVAS_HEIGHT,\n+                FrameBufferSource::Screen,\n+                context.clone(),\n+            ),\n+            back_buffer: FB::new(\n+                CANVAS_WIDTH,\n+                CANVAS_HEIGHT,\n+                FrameBufferSource::Screen,\n+                context,\n+            ),\n             banks: [\n                 ScreenBank {\n                     attributes: Box::new([ZXAttribute::from_byte(0); ATTR_COLS * ATTR_ROWS]),\n@@ -161,11 +175,12 @@ impl ZXCanvas {\n                 for pixel in 0..8 {\n                     // from most significant bit\n                     let state = ((bitmap << pixel) & 0x80) != 0;\n-                    let color = self\n-                        .palette\n-                        .get_rgba(attr.active_color(state, self.flash), attr.brightness);\n-                    let index = (block * 8 + pixel) * BYTES_PER_PIXEL;\n-                    self.back_buffer[index..index + BYTES_PER_PIXEL].clone_from_slice(color);\n+                    self.back_buffer.set_color(\n+                        (block % ATTR_COLS) * 8 + pixel,\n+                        block / ATTR_COLS,\n+                        attr.active_color(state, self.flash),\n+                        attr.brightness,\n+                    );\n                 }\n             }\n             // cahnge last block to current\n@@ -176,7 +191,14 @@ impl ZXCanvas {\n     /// starts new frame\n     pub fn new_frame(&mut self) {\n         // post finished bitmap to second buffer (all not-rendered part will be updated)\n-        self.buffer.clone_from_slice(&(*self.back_buffer));\n+        {\n+            let Self {\n+                buffer,\n+                back_buffer,\n+                ..\n+            } = self;\n+            core::mem::swap(buffer, back_buffer);\n+        }\n         self.last_blocks = BlocksCount::new(0, 0);\n         if self.frame_counter % 16 == 0 {\n             self.switch_flash();\n@@ -207,9 +229,7 @@ impl ZXCanvas {\n         }\n     }\n \n-    /// Returns reference to canvas main texture\n-    pub fn texture(&self) -> &[u8] {\n-        // TODO(#51): Perform texture generation and color mapping on the host implementation side\n-        &(*self.buffer)\n+    pub fn frame_buffer(&self) -> &FB {\n+        &self.buffer\n     }\n }\ndiff --git a/rustzx/Cargo.toml b/rustzx/Cargo.toml\nindex 6986387..5ea006e 100644\n--- a/rustzx/Cargo.toml\n+++ b/rustzx/Cargo.toml\n@@ -1,9 +1,8 @@\n [package]\n name = "rustzx"\n-version = "0.10.0"\n+version = "0.11.0"\n authors = ["Vladyslav Nikonov <mail@pacmancoder.xyz>"]\n-publish = false\n-description = "ZX Spectum emulator application"\n+description = "ZX Spectum emulator"\n repository = "https://github.com/pacmancoder/rustzx"\n readme = "../README.md"\n keywords = ["emulator", "game", "z80"]\n@@ -14,8 +13,8 @@ edition = "2018"\n \n [dependencies]\n sdl2 = { version = "0.34", features = ["unsafe_textures", "bundled", "static-link"] }\n-rustzx-core = { path =  "../rustzx-core" }\n+rustzx-core = { path =  "../rustzx-core", features = ["full"] }\n log = "0.4"\n anyhow = "1"\n-clap = "3.0.0-beta.2"\n+structopt = "0.3"\n env_logger = "0.8"\ndiff --git a/rustzx/src/app/events/events_sdl.rs b/rustzx/src/app/events/events_sdl.rs\nindex fc1f261..84f4a2c 100644\n--- a/rustzx/src/app/events/events_sdl.rs\n+++ b/rustzx/src/app/events/events_sdl.rs\n@@ -2,8 +2,8 @@\n use super::{Event, EventDevice};\n use crate::{app::settings::Settings, backends::SDL_CONTEXT};\n use rustzx_core::{\n-    utils::EmulationSpeed,\n-    zx::{joy::kempston::KempstonKey, keys::*},\n+    zx::{joy::kempston::KempstonKey, keys::ZXKey},\n+    EmulationSpeed,\n };\n use sdl2::{event::Event as SdlEvent, keyboard::Scancode, EventPump};\n \n@@ -32,53 +32,53 @@ impl EventsSdl {\n     fn scancode_to_zxkey(&self, scancode: Option<Scancode>) -> Option<ZXKey> {\n         match scancode? {\n             // FEFE\n-            Scancode::LShift | Scancode::RShift => Some(ZX_KEY_SHIFT),\n-            Scancode::Z => Some(ZX_KEY_Z),\n-            Scancode::X => Some(ZX_KEY_X),\n-            Scancode::C => Some(ZX_KEY_C),\n-            Scancode::V => Some(ZX_KEY_V),\n+            Scancode::LShift | Scancode::RShift => Some(ZXKey::Shift),\n+            Scancode::Z => Some(ZXKey::Z),\n+            Scancode::X => Some(ZXKey::X),\n+            Scancode::C => Some(ZXKey::C),\n+            Scancode::V => Some(ZXKey::V),\n             // FDDE\n-            Scancode::A => Some(ZX_KEY_A),\n-            Scancode::S => Some(ZX_KEY_S),\n-            Scancode::D => Some(ZX_KEY_D),\n-            Scancode::F => Some(ZX_KEY_F),\n-            Scancode::G => Some(ZX_KEY_G),\n+            Scancode::A => Some(ZXKey::A),\n+            Scancode::S => Some(ZXKey::S),\n+            Scancode::D => Some(ZXKey::D),\n+            Scancode::F => Some(ZXKey::F),\n+            Scancode::G => Some(ZXKey::G),\n             // FBFE\n-            Scancode::Q => Some(ZX_KEY_Q),\n-            Scancode::W => Some(ZX_KEY_W),\n-            Scancode::E => Some(ZX_KEY_E),\n-            Scancode::R => Some(ZX_KEY_R),\n-            Scancode::T => Some(ZX_KEY_T),\n+            Scancode::Q => Some(ZXKey::Q),\n+            Scancode::W => Some(ZXKey::W),\n+            Scancode::E => Some(ZXKey::E),\n+            Scancode::R => Some(ZXKey::R),\n+            Scancode::T => Some(ZXKey::T),\n             // F7FE\n-            Scancode::Num1 => Some(ZX_KEY_1),\n-            Scancode::Num2 => Some(ZX_KEY_2),\n-            Scancode::Num3 => Some(ZX_KEY_3),\n-            Scancode::Num4 => Some(ZX_KEY_4),\n-            Scancode::Num5 => Some(ZX_KEY_5),\n+            Scancode::Num1 => Some(ZXKey::N1),\n+            Scancode::Num2 => Some(ZXKey::N2),\n+            Scancode::Num3 => Some(ZXKey::N3),\n+            Scancode::Num4 => Some(ZXKey::N4),\n+            Scancode::Num5 => Some(ZXKey::N5),\n             // EFFE\n-            Scancode::Num0 => Some(ZX_KEY_0),\n-            Scancode::Num9 => Some(ZX_KEY_9),\n-            Scancode::Num8 => Some(ZX_KEY_8),\n-            Scancode::Num7 => Some(ZX_KEY_7),\n-            Scancode::Num6 => Some(ZX_KEY_6),\n+            Scancode::Num0 => Some(ZXKey::N0),\n+            Scancode::Num9 => Some(ZXKey::N9),\n+            Scancode::Num8 => Some(ZXKey::N8),\n+            Scancode::Num7 => Some(ZXKey::N7),\n+            Scancode::Num6 => Some(ZXKey::N6),\n             // DFFE\n-            Scancode::P => Some(ZX_KEY_P),\n-            Scancode::O => Some(ZX_KEY_O),\n-            Scancode::I => Some(ZX_KEY_I),\n-            Scancode::U => Some(ZX_KEY_U),\n-            Scancode::Y => Some(ZX_KEY_Y),\n+            Scancode::P => Some(ZXKey::P),\n+            Scancode::O => Some(ZXKey::O),\n+            Scancode::I => Some(ZXKey::I),\n+            Scancode::U => Some(ZXKey::U),\n+            Scancode::Y => Some(ZXKey::Y),\n             // BFFE\n-            Scancode::Return => Some(ZX_KEY_ENTER),\n-            Scancode::L => Some(ZX_KEY_L),\n-            Scancode::K => Some(ZX_KEY_K),\n-            Scancode::J => Some(ZX_KEY_J),\n-            Scancode::H => Some(ZX_KEY_H),\n+            Scancode::Return => Some(ZXKey::Enter),\n+            Scancode::L => Some(ZXKey::L),\n+            Scancode::K => Some(ZXKey::K),\n+            Scancode::J => Some(ZXKey::J),\n+            Scancode::H => Some(ZXKey::H),\n             // 7FFE\n-            Scancode::Space => Some(ZX_KEY_SPACE),\n-            Scancode::LCtrl | Scancode::RCtrl => Some(ZX_KEY_SYM_SHIFT),\n-            Scancode::M => Some(ZX_KEY_M),\n-            Scancode::N => Some(ZX_KEY_N),\n-            Scancode::B => Some(ZX_KEY_B),\n+            Scancode::Space => Some(ZXKey::Space),\n+            Scancode::LCtrl | Scancode::RCtrl => Some(ZXKey::SymShift),\n+            Scancode::M => Some(ZXKey::M),\n+            Scancode::N => Some(ZXKey::N),\n+            Scancode::B => Some(ZXKey::B),\n             _ => None,\n         }\n     }\ndiff --git a/rustzx/src/app/events/mod.rs b/rustzx/src/app/events/mod.rs\nindex 9230527..75b1194 100644\n--- a/rustzx/src/app/events/mod.rs\n+++ b/rustzx/src/app/events/mod.rs\n@@ -3,8 +3,8 @@\n mod events_sdl;\n \n use rustzx_core::{\n-    utils::EmulationSpeed,\n-    zx::{joy::kempston::KempstonKey, keys::*},\n+    zx::{joy::kempston::KempstonKey, keys::ZXKey},\n+    EmulationSpeed,\n };\n use std::path::PathBuf;\n \ndiff --git a/rustzx/src/app/mod.rs b/rustzx/src/app/mod.rs\nindex 25f1095..48612e7 100644\n--- a/rustzx/src/app/mod.rs\n+++ b/rustzx/src/app/mod.rs\n@@ -3,7 +3,7 @@ mod events;\n mod rustzx;\n mod settings;\n mod sound;\n-mod video;\n+pub(crate) mod video;\n \n // main re-export\n pub use self::{rustzx::RustzxApp, settings::Settings};\ndiff --git a/rustzx/src/app/rustzx.rs b/rustzx/src/app/rustzx.rs\nindex cf05c3e..dadb2db 100644\n--- a/rustzx/src/app/rustzx.rs\n+++ b/rustzx/src/app/rustzx.rs\n@@ -3,12 +3,23 @@\n //! and command-line interface\n \n use crate::{\n-    app::{events::*, settings::Settings, sound::*, video::*},\n-    host::{self, DetectedFileKind, GuiHost},\n+    app::{\n+        events::{Event, EventDevice, EventsSdl},\n+        settings::Settings,\n+        sound::{SoundDevice, SoundSdl},\n+        video::{Rect, TextureInfo, VideoDevice, VideoSdl},\n+    },\n+    host::{self, AppHost, AppHostContext, DetectedFileKind},\n };\n use anyhow::anyhow;\n-use rustzx_core::{emulator::*, zx::constants::*};\n+use rustzx_core::{\n+    zx::constants::{\n+        CANVAS_HEIGHT, CANVAS_WIDTH, CANVAS_X, CANVAS_Y, FPS, SCREEN_HEIGHT, SCREEN_WIDTH,\n+    },\n+    Emulator, Stopwatch,\n+};\n use std::{\n+    path::Path,\n     thread,\n     time::{Duration, Instant},\n };\n@@ -56,7 +67,7 @@ fn frame_length(fps: usize) -> Duration {\n /// Application instance type\n pub struct RustzxApp {\n     /// main emulator object\n-    emulator: Emulator<GuiHost>,\n+    emulator: Emulator<AppHost>,\n     /// Sound rendering in a separate thread\n     snd: Option<Box<dyn SoundDevice>>,\n     video: Box<dyn VideoDevice>,\n@@ -69,7 +80,7 @@ pub struct RustzxApp {\n impl RustzxApp {\n     /// Starts application itself\n     pub fn from_config(settings: Settings) -> anyhow::Result<RustzxApp> {\n-        let snd: Option<Box<dyn SoundDevice>> = if settings.sound_enabled {\n+        let snd: Option<Box<dyn SoundDevice>> = if !settings.disable_sound {\n             Some(Box::new(SoundSdl::new(&settings)))\n         } else {\n             None\n@@ -80,7 +91,7 @@ impl RustzxApp {\n         let scale = settings.scale as u32;\n         let events = Box::new(EventsSdl::new(&settings));\n \n-        let mut emulator = Emulator::new(settings.to_rustzx_settings())\n+        let mut emulator = Emulator::new(settings.to_rustzx_settings(), AppHostContext)\n             .map_err(|e| anyhow!("Failed to construct emulator: {}", e))?;\n \n         if let Some(rom) = settings.rom.as_ref() {\n@@ -88,18 +99,18 @@ impl RustzxApp {\n                 .load_rom(host::load_rom(rom, settings.machine)?)\n                 .map_err(|e| anyhow!("Emulator failed to load rom: {}", e))?;\n         }\n-        if let Some(snapshot) = settings.sna.as_ref() {\n+        if let Some(snapshot) = settings.snap.as_ref() {\n             emulator\n                 .load_snapshot(host::load_snapshot(snapshot)?)\n                 .map_err(|e| anyhow!("Emulator failed to load snapshot: {}", e))?;\n         }\n-        if let Some(tape) = settings.tap.as_ref() {\n+        if let Some(tape) = settings.tape.as_ref() {\n             emulator\n                 .load_tape(host::load_tape(tape)?)\n                 .map_err(|e| anyhow!("Emulator failed to load tape: {}", e))?;\n         }\n \n-        let app = RustzxApp {\n+        let mut app = RustzxApp {\n             emulator,\n             snd,\n             video,\n@@ -109,6 +120,10 @@ impl RustzxApp {\n             scale,\n         };\n \n+        if let Some(file) = settings.file_autodetect.as_ref() {\n+            app.load_file_autodetect(file)?;\n+        }\n+\n         Ok(app)\n     }\n \n@@ -121,7 +136,10 @@ impl RustzxApp {\n             // absolute start time\n             let frame_start = Instant::now();\n             // Emulate all requested frames\n-            let cpu_dt = self.emulator.emulate_frames(MAX_FRAME_TIME, &mut stopwatch);\n+            let cpu_dt = self\n+                .emulator\n+                .emulate_frames(MAX_FRAME_TIME, &mut stopwatch)\n+                .map_err(|e| anyhow!("Emulation step failed: {}", e))?;\n             // if sound enabled sound ganeration allowed then move samples to sound thread\n             if let Some(ref mut snd) = self.snd {\n                 // if can be turned off even on speed change, so check it everytime\n@@ -131,12 +149,12 @@ impl RustzxApp {\n                     }\n                 }\n             }\n-            // load new textures to sdl\n+\n             self.video\n-                .update_texture(self.tex_border, self.emulator.controller.border.texture());\n+                .update_texture(self.tex_border, self.emulator.border_buffer().rgba_data());\n             self.video\n-                .update_texture(self.tex_canvas, self.emulator.controller.canvas.texture());\n-            // rendering block\n+                .update_texture(self.tex_canvas, self.emulator.screen_buffer().rgba_data());\n+\n             self.video.begin();\n             self.video.draw_texture_2d(\n                 self.tex_border,\n@@ -181,22 +199,7 @@ impl RustzxApp {\n                     }\n                     Event::InsertTape => self.emulator.play_tape(),\n                     Event::StopTape => self.emulator.stop_tape(),\n-                    Event::OpenFile(path) => match host::detect_file_type(&path)? {\n-                        DetectedFileKind::Snapshot => {\n-                            self.emulator\n-                                .load_snapshot(host::load_snapshot(&path)?)\n-                                .map_err(|e| {\n-                                    anyhow!("Emulator failed to drag-n-drop load snapshot: {}", e)\n-                                })?;\n-                        }\n-                        DetectedFileKind::Tape => {\n-                            self.emulator\n-                                .load_tape(host::load_tape(&path)?)\n-                                .map_err(|e| {\n-                                    anyhow!("Emulator failed to drag-n-drop load tape: {}", e)\n-                                })?;\n-                        }\n-                    },\n+                    Event::OpenFile(path) => self.load_file_autodetect(&path)?,\n                 }\n             }\n             // how long emulation iteration was\n@@ -219,4 +222,22 @@ impl RustzxApp {\n         }\n         Ok(())\n     }\n+\n+    fn load_file_autodetect(&mut self, path: &Path) -> anyhow::Result<()> {\n+        match host::detect_file_type(&path)? {\n+            DetectedFileKind::Snapshot => {\n+                self.emulator\n+                    .load_snapshot(host::load_snapshot(&path)?)\n+                    .map_err(|e| {\n+                        anyhow!("Emulator failed to load auto-detected snapshot: {}", e)\n+                    })?;\n+            }\n+            DetectedFileKind::Tape => {\n+                self.emulator\n+                    .load_tape(host::load_tape(&path)?)\n+                    .map_err(|e| anyhow!("Emulator failed to load auto-detected tape: {}", e))?;\n+            }\n+        }\n+        Ok(())\n+    }\n }\ndiff --git a/rustzx/src/app/settings.rs b/rustzx/src/app/settings.rs\nindex 398776a..a32cb2e 100644\n--- a/rustzx/src/app/settings.rs\n+++ b/rustzx/src/app/settings.rs\n@@ -1,346 +1,159 @@\n use rustzx_core::{\n-    settings::RustzxSettings,\n-    utils::EmulationSpeed,\n-    zx::{\n-        constants::{SCREEN_HEIGHT, SCREEN_WIDTH},\n-        machine::ZXMachine,\n-        sound::ay::ZXAYMode,\n-    },\n+    zx::{machine::ZXMachine, sound::ay::ZXAYMode},\n+    EmulationSpeed, RustzxSettings,\n };\n \n-use clap::{App, AppSettings, Arg};\n-use std::path::{Path, PathBuf};\n+use std::path::PathBuf;\n+\n+use structopt::StructOpt;\n \n /// Structure to handle all emulator runtime settings\n+#[derive(StructOpt)]\n pub struct Settings {\n+    /// Specify machine type for launch. Possible values:\n+    ///   [`48k`, `48`] - Sinclair ZX Spectrum 48K\n+    ///   [`128k`, `128`] - Sinclair ZX Spectrum 128K\n+    #[structopt(verbatim_doc_comment, short, long, default_value = "48k", parse(try_from_str = machine_from_str))]\n     pub machine: ZXMachine,\n+    /// Set emulation speed at emualtor start-up. Can be specified as deciamal non-zero\n+    /// value or as a special value `MAX` to run emulator as fast as possible\n+    #[structopt(long, default_value = "1", parse(try_from_str = emualtion_speed_from_str))]\n     pub speed: EmulationSpeed,\n-    pub fastload: bool,\n+    /// Disable fast tape loading\n+    #[structopt(long = "nofastload")]\n+    pub disable_fastload: bool,\n+    /// Set windows scale for emulator. Can be set as decimal non-zero value. Defaults to 2\n+    #[structopt(short, long, default_value = "2", parse(try_from_str = scale_from_str))]\n     pub scale: usize,\n-    pub screen_size: (usize, usize),\n-    pub kempston: bool,\n+    /// Disable kempston joy support. In enabled, arrow and `Alt` keys are bound by default\n+    /// to the kempston joy.\n+    #[structopt(long = "nokempston")]\n+    pub disable_kempston: bool,\n+    /// Set AY-3-8910 sound chip mode. Can be set to `mono`, `abc`(stereo) or `acb`(stereo).\n+    /// Defaults to `abc`\n+    #[structopt(long, default_value = "abc", parse(try_from_str = ay_mode_from_str))]\n+    /// Disable AY-3-8910 chip support\n     pub ay_mode: ZXAYMode,\n-    pub ay_enabled: bool,\n-    pub beeper_enabled: bool,\n-    pub sound_enabled: bool,\n-    pub volume: usize,\n-    pub latency: usize,\n+    /// Force enable AY-3-8910 chip on unsupported machines\n+    #[structopt(long = "ay", conflicts_with = "force-disable-ay")]\n+    pub force_enable_ay: bool,\n+    /// Force disable AY-3-8910 chip on supported systems\n+    #[structopt(long = "noay", conflicts_with = "force-enable-ay")]\n+    pub force_disable_ay: bool,\n+    /// Disable beeper\n+    #[structopt(long = "nobeeper")]\n+    pub disable_beeper: bool,\n+    /// Disable sound\n+    #[structopt(long = "nosound")]\n+    pub disable_sound: bool,\n+    /// Set custom sound latency. Defaults to 1024 samples\n+    #[structopt(long, default_value = "1024", parse(try_from_str = sound_latency_from_str))]\n+    pub sound_latency: usize,\n+    /// Set custom sound sample rate. Defaults to 44100 samples per second\n+    #[structopt(long, default_value = "44100", parse(try_from_str = sound_sample_rate_from_str))]\n+    pub sound_sample_rate: usize,\n+\n+    /// Set path to custom rom file. in case of multipart ROMs for 128k, the first part file,\n+    /// extension of which should end with `.0`\n+    #[structopt(long, conflicts_with = "file-autodetect")]\n     pub rom: Option<PathBuf>,\n-    pub tap: Option<PathBuf>,\n-    pub sna: Option<PathBuf>,\n+    /// Set tape file path. Only `.tap` files are supported currently\n+    #[structopt(long, conflicts_with = "file-autodetect")]\n+    pub tape: Option<PathBuf>,\n+    /// Set snapshot file path. Only `.sna` files are supported currently\n+    #[structopt(long, conflicts_with = "file-autodetect")]\n+    pub snap: Option<PathBuf>,\n+\n+    /// Load provided file to emulator. Emulator will perform autodetect of format if possible\n+    pub file_autodetect: Option<PathBuf>,\n }\n \n-impl Settings {\n-    /// constructs new Settings\n-    pub fn new() -> Self {\n-        Self {\n-            machine: ZXMachine::Sinclair48K,\n-            speed: EmulationSpeed::Definite(1),\n-            fastload: false,\n-            scale: 2,\n-            screen_size: (SCREEN_WIDTH * 2, SCREEN_HEIGHT * 2),\n-            kempston: false,\n-            ay_mode: ZXAYMode::Mono,\n-            ay_enabled: false,\n-            beeper_enabled: true,\n-            sound_enabled: true,\n-            volume: 100,\n-            latency: 1024,\n-            rom: None,\n-            tap: None,\n-            sna: None,\n-        }\n-    }\n-\n-    pub fn from_clap() -> Self {\n-        // get defaults\n-        let mut out = Self::new();\n-        // parse cli\n-        let cmd = App::new("rustzx")\n-            .setting(AppSettings::ColoredHelp)\n-            .version(env!("CARGO_PKG_VERSION"))\n-            .author("Vladislav Nikonov <pacmancoder@gmail.com>")\n-            .about("ZX Spectrum emulator written in pure Rust")\n-            // machine settings\n-            .arg(\n-                Arg::new("128K")\n-                    .long("128k")\n-                    .about("Enables ZX Spectrum 128K mode"),\n-            )\n-            .arg(\n-                Arg::new("FASTLOAD")\n-                    .short(\'f\')\n-                    .long("fastload")\n-                    .about("Accelerates standard tape loaders"),\n-            )\n-            // media files\n-            .arg(\n-                Arg::new("ROM")\n-                    .long("rom")\n-                    .value_name("ROM_PATH")\n-                    .about("Selects path to rom, otherwise default will be used"),\n-            )\n-            .arg(\n-                Arg::new("TAP")\n-                    .long("tap")\n-                    .value_name("TAP_PATH")\n-                    .about("Selects path to *.tap file"),\n-            )\n-            .arg(\n-                Arg::new("SNA")\n-                    .long("sna")\n-                    .value_name("SNA_PATH")\n-                    .about("Selects path to *.sna snapshot file"),\n-            )\n-            // devices\n-            .arg(Arg::new("KEMPSTON").short(\'k\').long("kempston").about(\n-                "Enables Kempston joystick. Controlls via arrow keys and \\\n-                 Alt buttons",\n-            ))\n-            // emulator settings\n-            .arg(\n-                Arg::new("SPEED")\n-                    .long("speed")\n-                    .value_name("SPEED_VALUE")\n-                    .about("Selects speed for emulator in integer multiplier form"),\n-            )\n-            .arg(\n-                Arg::new("SCALE")\n-                    .long("scale")\n-                    .value_name("SCALE_VALUE")\n-                    .about(\n-                        "Selects default screen size. possible values are positive \\\n-                         integers. Default value is 2",\n-                    ),\n-            )\n-            // sound\n-            .arg(Arg::new("NOSOUND").long("nosound").about(\n-                "Disables sound. Use it when you have problems with audio \\\n-                 playback",\n-            ))\n-            .arg(\n-                Arg::new("NOBEEPER")\n-                    .long("nobeeper")\n-                    .about("Disables beeper"),\n-            )\n-            .arg(\n-                Arg::new("AY")\n-                    .long("ay")\n-                    .value_name("AY_TYPE")\n-                    .possible_values(&["none", "mono", "abc", "acb"])\n-                    .about(\n-                        "Selects AY mode. Use none to disable. \\\n-                         For stereo features use abc or acb, default is mono for \\\n-                         128k and none for 48k.",\n-                    ),\n-            )\n-            .arg(\n-                Arg::new("VOLUME")\n-                    .long("volume")\n-                    .value_name("VOLUME_VALUE")\n-                    .about(\n-                        "Selects volume - value in range 0..200. Volume over 100 \\\n-                         can cause sound artifacts",\n-                    ),\n-            )\n-            .arg(\n-                Arg::new("LATENCY")\n-                    .long("latency")\n-                    .short(\'l\')\n-                    .value_name("SAMPLES")\n-                    .about(\n-                        "Selects audio latency. Default is 1024 samples. Set higher \\\n-                         latency if emulator have sound glitches. Or if your \\\n-                         machine can handle this - try to set it lower. Must be \\\n-                         power of two.",\n-                    ),\n-            )\n-            .get_matches();\n-        // machine type\n-        if cmd.is_present("128K") {\n-            out.machine(ZXMachine::Sinclair128K);\n-        }\n-        if let Some(speed_str) = cmd.value_of("SPEED") {\n-            if let Ok(speed) = speed_str.parse::<usize>() {\n-                out.speed(EmulationSpeed::Definite(speed));\n-            }\n-        };\n-        if let Some(scale_str) = cmd.value_of("SCALE") {\n-            if let Ok(scale) = scale_str.parse::<usize>() {\n-                out.scale(scale);\n-            } else {\n-                println!("[Warning] Invalid scale factor");\n-            };\n-        }\n-        out.fastload(cmd.is_present("FASTLOAD"))\n-            .beeper(!cmd.is_present("NOBEEPER"))\n-            .sound(!cmd.is_present("NOSOUND"))\n-            .kempston(cmd.is_present("KEMPSTON"));\n-        if let Some(path) = cmd.value_of_os("ROM") {\n-            if Path::new(path).is_file() {\n-                out.rom(path);\n-            } else {\n-                println!(\n-                    "[Warning] ROM file \\"{}\\" not found",\n-                    path.to_string_lossy()\n-                );\n-            }\n-        }\n-        if let Some(path) = cmd.value_of_os("TAP") {\n-            if Path::new(path).is_file() {\n-                out.tap(path);\n-            } else {\n-                println!(\n-                    "[Warning] Tape file \\"{}\\" not found",\n-                    path.to_string_lossy()\n-                );\n-            }\n-        }\n-        if let Some(path) = cmd.value_of_os("SNA") {\n-            if out.machine == ZXMachine::Sinclair48K {\n-                if Path::new(path).is_file() {\n-                    out.sna(path);\n-                } else {\n-                    println!(\n-                        "[Warning] Snapshot file \\"{}\\" not found",\n-                        path.to_string_lossy()\n-                    );\n-                }\n-            } else {\n-                println!("[Warning] 128K SNA is not supported!");\n-            }\n-        }\n-        if let Some(value) = cmd.value_of("AY") {\n-            match value {\n-                "none" => out.ay(false),\n-                "mono" => out.ay_mode(ZXAYMode::Mono),\n-                "abc" => out.ay_mode(ZXAYMode::ABC),\n-                "acb" => out.ay_mode(ZXAYMode::ACB),\n-                _ => unreachable!(),\n-            };\n-        };\n-        if let Some(value) = cmd.value_of("VOLUME") {\n-            if let Ok(value) = value.parse::<usize>() {\n-                out.volume(value);\n-            } else {\n-                println!("[Warning] Volume value is incorrect, setting volume to 100");\n-            }\n-        };\n-        if let Some(latency_str) = cmd.value_of("LATENCY") {\n-            if let Ok(latency) = latency_str.parse::<usize>() {\n-                out.latency(latency);\n-            }\n-        };\n-        out\n+fn machine_from_str(s: &str) -> Result<ZXMachine, anyhow::Error> {\n+    match s.to_lowercase().as_str() {\n+        "48k" | "48" => Ok(ZXMachine::Sinclair48K),\n+        "128k" | "128" => Ok(ZXMachine::Sinclair128K),\n+        s => Err(anyhow::anyhow!("Invalid machine type `{}`", s)),\n     }\n+}\n \n-    /// Changes machine type\n-    pub fn machine(&mut self, machine: ZXMachine) -> &mut Self {\n-        self.machine = machine;\n-        match machine {\n-            ZXMachine::Sinclair48K => self.ay_enabled = false,\n-            ZXMachine::Sinclair128K => self.ay_enabled = true,\n-        }\n-        self\n-    }\n+fn emualtion_speed_from_str(s: &str) -> Result<EmulationSpeed, anyhow::Error> {\n+    match s.to_lowercase().as_str() {\n+        "max" => Ok(EmulationSpeed::Max),\n+        s => {\n+            let speed: std::num::NonZeroUsize = s\n+                .parse()\n+                .map_err(|_| anyhow::anyhow!("Invalid emulation speed `{}`", s))?;\n \n-    /// changes screen scale\n-    pub fn scale(&mut self, scale: usize) -> &mut Self {\n-        // place into bounds\n-        if scale > 5 {\n-            self.scale = 2;\n-        } else {\n-            self.scale = scale;\n+            Ok(EmulationSpeed::Definite(speed.into()))\n         }\n-        self.screen_size = (SCREEN_WIDTH * self.scale, SCREEN_HEIGHT * self.scale);\n-        self\n-    }\n-\n-    /// changes fastload flag\n-    pub fn fastload(&mut self, value: bool) -> &mut Self {\n-        self.fastload = value;\n-        self\n     }\n+}\n \n-    /// changes lound latency\n-    pub fn latency(&mut self, latency: usize) -> &mut Self {\n-        self.latency = latency;\n-        self\n-    }\n+fn scale_from_str(s: &str) -> Result<usize, anyhow::Error> {\n+    let scale: std::num::NonZeroUsize = s\n+        .parse()\n+        .map_err(|_| anyhow::anyhow!("Invalid screen scale `{}`", s))?;\n \n-    /// Changes AY chip mode\n-    pub fn ay_mode(&mut self, mode: ZXAYMode) -> &mut Self {\n-        self.ay_enabled = true;\n-        self.ay_mode = mode;\n-        self\n-    }\n+    Ok(scale.into())\n+}\n \n-    /// Changes ay state (on/off)\n-    pub fn ay(&mut self, state: bool) -> &mut Self {\n-        self.ay_enabled = state;\n-        self\n+fn ay_mode_from_str(s: &str) -> Result<ZXAYMode, anyhow::Error> {\n+    match s.to_lowercase().as_str() {\n+        "mono" => Ok(ZXAYMode::Mono),\n+        "abc" => Ok(ZXAYMode::ABC),\n+        "acb" => Ok(ZXAYMode::ACB),\n+        s => Err(anyhow::anyhow!("Invalid AY chip mode `{}`", s)),\n     }\n+}\n \n-    /// Changes beeper state (on/off)\n-    pub fn beeper(&mut self, state: bool) -> &mut Self {\n-        self.beeper_enabled = state;\n-        self\n-    }\n+fn sound_latency_from_str(s: &str) -> Result<usize, anyhow::Error> {\n+    let latency = s\n+        .parse::<usize>()\n+        .map_err(|_| anyhow::anyhow!("Invalid sound latency `{}`", s))?;\n \n-    /// changes sound flag\n-    pub fn sound(&mut self, state: bool) -> &mut Self {\n-        self.sound_enabled = state;\n-        self\n+    if latency < 64 {\n+        anyhow::bail!("Setting sound latency lower than 64 is bad for your health");\n     }\n-\n-    /// Changes volume\n-    pub fn volume(&mut self, val: usize) -> &mut Self {\n-        self.volume = if val > 200 { 200 } else { val };\n-        self\n+    if latency > 1024 * 64 {\n+        anyhow::bail!("This sound latency is HUGE. Please don\'t try this at home!");\n     }\n \n-    /// cahnges kempston joy connection\n-    pub fn kempston(&mut self, value: bool) -> &mut Self {\n-        self.kempston = value;\n-        self\n-    }\n+    Ok(latency)\n+}\n \n-    /// changes TAP path\n-    pub fn tap(&mut self, value: impl AsRef<Path>) -> &mut Self {\n-        self.tap = Some(value.as_ref().into());\n-        self\n-    }\n+fn sound_sample_rate_from_str(s: &str) -> Result<usize, anyhow::Error> {\n+    let sample_rate = s\n+        .parse::<usize>()\n+        .map_err(|_| anyhow::anyhow!("Invalid sound sample rate {}", s))?;\n \n-    /// changes SNA path\n-    pub fn sna(&mut self, value: impl AsRef<Path>) -> &mut Self {\n-        self.sna = Some(value.as_ref().into());\n-        self\n+    // Sample rate range derived from https://github.com/audiojs/sample-rate\n+    if sample_rate < 8000 {\n+        anyhow::bail!("Provided sound sample rate `{}` is too low", sample_rate);\n     }\n-\n-    /// changes ROM path\n-    pub fn rom(&mut self, value: impl AsRef<Path>) -> &mut Self {\n-        self.rom = Some(value.as_ref().into());\n-        self\n+    if sample_rate > 384000 {\n+        anyhow::bail!("Provided sound sample rate `{}` is too high", sample_rate);\n     }\n \n-    /// changes emulation speed\n-    pub fn speed(&mut self, value: EmulationSpeed) -> &mut Self {\n-        self.speed = value;\n-        self\n-    }\n+    Ok(sample_rate)\n+}\n \n+impl Settings {\n     pub fn to_rustzx_settings(&self) -> RustzxSettings {\n+        let ay_enabled = (matches!(self.machine, ZXMachine::Sinclair128K) || self.force_enable_ay)\n+            && (!self.force_disable_ay);\n+\n         RustzxSettings {\n             machine: self.machine,\n             emulation_speed: self.speed,\n-            tape_fastload: self.fastload,\n-            enable_kempston: self.kempston,\n+            tape_fastload: !self.disable_fastload,\n+            enable_kempston: !self.disable_kempston,\n             ay_mode: self.ay_mode,\n-            ay_enabled: self.ay_enabled,\n-            beeper_enabled: self.beeper_enabled,\n-            sound_enabled: self.sound_enabled,\n-            sound_volume: self.volume as u8,\n+            ay_enabled,\n+            beeper_enabled: !self.disable_beeper,\n+            sound_enabled: !self.disable_sound,\n+            sound_volume: 100,\n             load_default_rom: self.rom.is_none(),\n+            sound_sample_rate: self.sound_sample_rate,\n         }\n     }\n }\ndiff --git a/rustzx/src/app/sound/sound_sdl.rs b/rustzx/src/app/sound/sound_sdl.rs\nindex 6f028c6..a7a6117 100644\n--- a/rustzx/src/app/sound/sound_sdl.rs\n+++ b/rustzx/src/app/sound/sound_sdl.rs\n@@ -1,10 +1,11 @@\n //! Real Audio SDL backend\n use super::{SoundDevice, ZXSample};\n use crate::{app::settings::Settings, backends::SDL_CONTEXT};\n-use rustzx_core::zx::sound::{CHANNELS, SAMPLE_RATE};\n use sdl2::audio::{AudioCallback, AudioDevice, AudioSpecDesired};\n use std::sync::mpsc::{sync_channel, Receiver, SyncSender};\n \n+const CHANNEL_COUNT: usize = 2;\n+\n /// Struct which used in SDL audio callback\n struct SdlCallback {\n     samples: Receiver<ZXSample>,\n@@ -15,7 +16,7 @@ impl AudioCallback for SdlCallback {\n \n     /// main callback function\n     fn callback(&mut self, out: &mut [f32]) {\n-        for chunk in out.chunks_mut(CHANNELS) {\n+        for chunk in out.chunks_mut(CHANNEL_COUNT) {\n             // recieve samples from channel\n             if let Ok(sample) = self.samples.recv() {\n                 chunk[0] = sample.left;\n@@ -42,11 +43,11 @@ impl SoundSdl {\n         if let Some(audio) = audio_subsystem {\n             // prepare specs\n             let desired_spec = AudioSpecDesired {\n-                freq: Some(SAMPLE_RATE as i32),\n-                channels: Some(CHANNELS as u8),\n-                samples: Some(settings.latency as u16),\n+                freq: Some(settings.sound_sample_rate as i32),\n+                channels: Some(CHANNEL_COUNT as u8),\n+                samples: Some(settings.sound_latency as u16),\n             };\n-            let (tx, rx) = sync_channel(settings.latency as usize);\n+            let (tx, rx) = sync_channel(settings.sound_latency as usize);\n             let device_handle = audio\n                 .open_playback(None, &desired_spec, |_| SdlCallback { samples: rx })\n                 .expect("[ERROR Sdl audio device error, try --nosound]");\ndiff --git a/rustzx/src/app/video/mod.rs b/rustzx/src/app/video/mod.rs\nindex b976ecb..81acc48 100644\n--- a/rustzx/src/app/video/mod.rs\n+++ b/rustzx/src/app/video/mod.rs\n@@ -1,7 +1,9 @@\n //! platform-independent traits. Submodules with backends will be selectable\n //! via cargo features in future\n+mod palette;\n mod video_sdl;\n \n+pub use palette::Palette;\n pub use video_sdl::VideoSdl;\n \n /// Texture id binging\ndiff --git a/rustzx/src/app/video/palette.rs b/rustzx/src/app/video/palette.rs\nnew file mode 100644\nindex 0000000..d2768a5\n--- /dev/null\n+++ b/rustzx/src/app/video/palette.rs\n@@ -0,0 +1,65 @@\n+use rustzx_core::zx::video::colors::{ZXBrightness, ZXColor};\n+\n+type ColorRgba = [u8; 4];\n+\n+/// represents set of colors\n+struct ColorSet {\n+    black: ColorRgba,\n+    blue: ColorRgba,\n+    red: ColorRgba,\n+    purple: ColorRgba,\n+    green: ColorRgba,\n+    cyan: ColorRgba,\n+    yellow: ColorRgba,\n+    white: ColorRgba,\n+}\n+pub struct Palette {\n+    bright: ColorSet,\n+    normal: ColorSet,\n+}\n+\n+impl Default for Palette {\n+    fn default() -> Self {\n+        Palette {\n+            normal: ColorSet {\n+                black: 0x000000FF_u32.to_be_bytes(),\n+                blue: 0x0000CDFF_u32.to_be_bytes(),\n+                red: 0xCD0000FF_u32.to_be_bytes(),\n+                purple: 0xCD00CDFF_u32.to_be_bytes(),\n+                green: 0x00CD00FF_u32.to_be_bytes(),\n+                cyan: 0x00CDCDFF_u32.to_be_bytes(),\n+                yellow: 0xCDCD00FF_u32.to_be_bytes(),\n+                white: 0xCDCDCDFF_u32.to_be_bytes(),\n+            },\n+            bright: ColorSet {\n+                black: 0x000000FF_u32.to_be_bytes(),\n+                blue: 0x0000FFFF_u32.to_be_bytes(),\n+                red: 0xFF0000FF_u32.to_be_bytes(),\n+                purple: 0xFF00FFFF_u32.to_be_bytes(),\n+                green: 0x00FF00FF_u32.to_be_bytes(),\n+                cyan: 0x00FFFFFF_u32.to_be_bytes(),\n+                yellow: 0xFFFF00FF_u32.to_be_bytes(),\n+                white: 0xFFFFFFFF_u32.to_be_bytes(),\n+            },\n+        }\n+    }\n+}\n+\n+impl Palette {\n+    pub fn get_rgba(&self, color: ZXColor, brightness: ZXBrightness) -> ColorRgba {\n+        let set = match brightness {\n+            ZXBrightness::Normal => &self.normal,\n+            ZXBrightness::Bright => &self.bright,\n+        };\n+        match color {\n+            ZXColor::Black => set.black,\n+            ZXColor::Blue => set.blue,\n+            ZXColor::Red => set.red,\n+            ZXColor::Purple => set.purple,\n+            ZXColor::Green => set.green,\n+            ZXColor::Cyan => set.cyan,\n+            ZXColor::Yellow => set.yellow,\n+            ZXColor::White => set.white,\n+        }\n+    }\n+}\ndiff --git a/rustzx/src/app/video/video_sdl.rs b/rustzx/src/app/video/video_sdl.rs\nindex b71166e..d421f01 100644\n--- a/rustzx/src/app/video/video_sdl.rs\n+++ b/rustzx/src/app/video/video_sdl.rs\n@@ -1,5 +1,6 @@\n use super::{Rect, TextureInfo, VideoDevice};\n use crate::{app::settings::Settings, backends::SDL_CONTEXT};\n+use rustzx_core::zx::constants::{SCREEN_HEIGHT, SCREEN_WIDTH};\n use sdl2::{\n     pixels::PixelFormatEnum as PixelFormat,\n     rect::Rect as SdlRect,\n@@ -26,7 +27,10 @@ impl VideoSdl {\n         });\n         if let Some(video) = video_subsystem {\n             // construct window and renderer form it\n-            let (width, height) = settings.screen_size;\n+            let (width, height) = (\n+                SCREEN_WIDTH * settings.scale,\n+                SCREEN_HEIGHT * settings.scale,\n+            );\n             let window = video\n                 .window(\n                     &format!("RustZX v{}", env!("CARGO_PKG_VERSION")),\ndiff --git a/rustzx/src/host/frame_buffer.rs b/rustzx/src/host/frame_buffer.rs\nnew file mode 100644\nindex 0000000..0c1136e\n--- /dev/null\n+++ b/rustzx/src/host/frame_buffer.rs\n@@ -0,0 +1,50 @@\n+use crate::app::video::Palette;\n+use rustzx_core::{\n+    host::{FrameBuffer, FrameBufferSource},\n+    zx::video::colors::{ZXBrightness, ZXColor},\n+};\n+\n+const RGBA_PIXEL_SIZE: usize = 4;\n+\n+#[derive(Clone)]\n+pub struct FrameBufferContext;\n+\n+pub struct RgbaFrameBuffer {\n+    buffer: Vec<u8>,\n+    palette: Palette,\n+    buffer_row_size: usize,\n+}\n+\n+impl FrameBuffer for RgbaFrameBuffer {\n+    type Context = FrameBufferContext;\n+\n+    fn new(\n+        width: usize,\n+        height: usize,\n+        _source: FrameBufferSource,\n+        _context: Self::Context,\n+    ) -> Self {\n+        Self {\n+            buffer: vec![0u8; width * height * RGBA_PIXEL_SIZE],\n+            palette: Palette::default(),\n+            buffer_row_size: width * RGBA_PIXEL_SIZE,\n+        }\n+    }\n+\n+    fn set_color(&mut self, x: usize, y: usize, color: ZXColor, brightness: ZXBrightness) {\n+        let buffer_pos = y * self.buffer_row_size + x * RGBA_PIXEL_SIZE;\n+\n+        self.palette\n+            .get_rgba(color, brightness)\n+            .iter()\n+            .copied()\n+            .zip(&mut self.buffer[buffer_pos..buffer_pos + RGBA_PIXEL_SIZE])\n+            .for_each(|(source, dest)| *dest = source);\n+    }\n+}\n+\n+impl RgbaFrameBuffer {\n+    pub fn rgba_data(&self) -> &[u8] {\n+        &self.buffer\n+    }\n+}\ndiff --git a/rustzx/src/host/mod.rs b/rustzx/src/host/mod.rs\nindex 4f77144..190a571 100644\n--- a/rustzx/src/host/mod.rs\n+++ b/rustzx/src/host/mod.rs\n@@ -1,24 +1,36 @@\n+mod frame_buffer;\n mod io;\n \n use anyhow::{anyhow, bail, Context};\n+use frame_buffer::{FrameBufferContext, RgbaFrameBuffer};\n use io::FileAsset;\n use rustzx_core::{\n-    host::{Host, RomFormat, RomSet, Snapshot, Tape},\n-    zx::ZXMachine,\n+    host::{FrameBuffer, Host, HostContext, RomFormat, RomSet, Snapshot, Tape},\n+    zx::machine::ZXMachine,\n };\n use std::{collections::VecDeque, fs::File, path::Path};\n \n const SUPPORTED_SNAPSHOT_FORMATS: [&str; 1] = ["sna"];\n const SUPPORTED_TAPE_FORMATS: [&str; 1] = ["tap"];\n \n-pub struct GuiHost;\n+pub struct AppHost;\n \n-impl Host for GuiHost {\n+impl Host for AppHost {\n+    type Context = AppHostContext;\n+    type FrameBuffer = RgbaFrameBuffer;\n     type RomSet = FileRomSet;\n     type SnapshotAsset = FileAsset;\n     type TapeAsset = FileAsset;\n }\n \n+pub struct AppHostContext;\n+\n+impl HostContext<AppHost> for AppHostContext {\n+    fn frame_buffer_context(&self) -> <<AppHost as Host>::FrameBuffer as FrameBuffer>::Context {\n+        FrameBufferContext\n+    }\n+}\n+\n pub struct FileRomSet {\n     pages: VecDeque<FileAsset>,\n }\ndiff --git a/rustzx/src/main.rs b/rustzx/src/main.rs\nindex d899b36..45d98da 100644\n--- a/rustzx/src/main.rs\n+++ b/rustzx/src/main.rs\n@@ -5,11 +5,12 @@ mod backends;\n mod host;\n \n use app::{RustzxApp, Settings};\n+use structopt::StructOpt;\n \n fn main() {\n     env_logger::init();\n \n-    let settings = Settings::from_clap();\n+    let settings = Settings::from_args();\n     let result = RustzxApp::from_config(settings)\n         .and_then(|mut emulator| emulator.start())\n         .map_err(|e| log::error!("ERROR: {}", e));\n', test_patch='', problem_statement='Eliminate loading a whole file to vector in tap loader\nCurrently we already have file-like `libcore`-friendly abstraction over currently loading tap asset but still perform read to `Vec` instead of `seek` + `read` on demand; This will allow to port `rustzx-core` to more resource-restricted hosts.\n', hints_text='', created_at=1620, pull_number=60, issue_numbers=['53'], merge_commit_sha='a59601712747336126bf31434aac664e85019477', ci_name_list=[], retrieved_files=None)